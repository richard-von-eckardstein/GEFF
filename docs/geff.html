<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 15.0.4"/>
    <title>geff API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;z-index:999;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;opacity:0;}nav.pdoc{--pad:clamp(0.5rem, 2vw, 1.75rem);--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent; z-index:1}nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc > div > ul{margin-left:calc(0px - var(--pad));}nav.pdoc li a{padding:.2rem 0 .2rem calc(var(--pad) + var(--indent));}nav.pdoc > div > ul > li > a{padding-left:var(--pad);}nav.pdoc li{transition:all 100ms;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{cursor:pointer;display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .alert{padding:1rem 1rem 1rem calc(1.5rem + 24px);border:1px solid transparent;border-radius:.25rem;background-repeat:no-repeat;background-position:.75rem center;margin-bottom:1rem;}.pdoc .alert > em{display:none;}.pdoc .alert > *:last-child{margin-bottom:0;}.pdoc .alert.note{color:#084298;background-color:#cfe2ff;border-color:#b6d4fe;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23084298%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016zm.93-9.412-1%204.705c-.07.34.029.533.304.533.194%200%20.487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703%200-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381%202.29-.287zM8%205.5a1%201%200%201%201%200-2%201%201%200%200%201%200%202z%22/%3E%3C/svg%3E");}.pdoc .alert.tip{color:#0a3622;background-color:#d1e7dd;border-color:#a3cfbb;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%230a3622%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M2%206a6%206%200%201%201%2010.174%204.31c-.203.196-.359.4-.453.619l-.762%201.769A.5.5%200%200%201%2010.5%2013a.5.5%200%200%201%200%201%20.5.5%200%200%201%200%201l-.224.447a1%201%200%200%201-.894.553H6.618a1%201%200%200%201-.894-.553L5.5%2015a.5.5%200%200%201%200-1%20.5.5%200%200%201%200-1%20.5.5%200%200%201-.46-.302l-.761-1.77a2%202%200%200%200-.453-.618A5.98%205.98%200%200%201%202%206m6-5a5%205%200%200%200-3.479%208.592c.263.254.514.564.676.941L5.83%2012h4.342l.632-1.467c.162-.377.413-.687.676-.941A5%205%200%200%200%208%201%22/%3E%3C/svg%3E");}.pdoc .alert.important{color:#055160;background-color:#cff4fc;border-color:#9eeaf9;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23055160%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M2%200a2%202%200%200%200-2%202v12a2%202%200%200%200%202%202h12a2%202%200%200%200%202-2V2a2%202%200%200%200-2-2zm6%204c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%204.995A.905.905%200%200%201%208%204m.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2%22/%3E%3C/svg%3E");}.pdoc .alert.warning{color:#664d03;background-color:#fff3cd;border-color:#ffecb5;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23664d03%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8.982%201.566a1.13%201.13%200%200%200-1.96%200L.165%2013.233c-.457.778.091%201.767.98%201.767h13.713c.889%200%201.438-.99.98-1.767L8.982%201.566zM8%205c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%205.995A.905.905%200%200%201%208%205zm.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2z%22/%3E%3C/svg%3E");}.pdoc .alert.caution{color:#842029;background-color:#f8d7da;border-color:#f5c2c7;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23842029%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M11.46.146A.5.5%200%200%200%2011.107%200H4.893a.5.5%200%200%200-.353.146L.146%204.54A.5.5%200%200%200%200%204.893v6.214a.5.5%200%200%200%20.146.353l4.394%204.394a.5.5%200%200%200%20.353.146h6.214a.5.5%200%200%200%20.353-.146l4.394-4.394a.5.5%200%200%200%20.146-.353V4.893a.5.5%200%200%200-.146-.353zM8%204c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%204.995A.905.905%200%200%201%208%204m.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2%22/%3E%3C/svg%3E");}.pdoc .alert.danger{color:#842029;background-color:#f8d7da;border-color:#f5c2c7;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23842029%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M5.52.359A.5.5%200%200%201%206%200h4a.5.5%200%200%201%20.474.658L8.694%206H12.5a.5.5%200%200%201%20.395.807l-7%209a.5.5%200%200%201-.873-.454L6.823%209.5H3.5a.5.5%200%200%201-.48-.641l2.5-8.5z%22/%3E%3C/svg%3E");}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc > section:not(.module-info) h1{font-size:1.5rem;font-weight:500;}.pdoc > section:not(.module-info) h2{font-size:1.4rem;font-weight:500;}.pdoc > section:not(.module-info) h3{font-size:1.3rem;font-weight:500;}.pdoc > section:not(.module-info) h4{font-size:1.2rem;}.pdoc > section:not(.module-info) h5{font-size:1.1rem;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--accent);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc > section:not(.module-info){margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.view-source-toggle-state,.view-source-toggle-state ~ .pdoc-code{display:none;}.view-source-toggle-state:checked ~ .pdoc-code{display:block;}.view-source-button{display:inline-block;float:right;font-size:.75rem;line-height:1.5rem;color:var(--muted);padding:0 .4rem 0 1.3rem;cursor:pointer;text-indent:-2px;}.view-source-button > span{visibility:hidden;}.module-info .view-source-button{float:none;display:flex;justify-content:flex-end;margin:-1.2rem .4rem -.2rem 0;}.view-source-button::before{position:absolute;content:"View Source";display:list-item;list-style-type:disclosure-closed;}.view-source-toggle-state:checked ~ .attr .view-source-button::before,.view-source-toggle-state:checked ~ .view-source-button::before{list-style-type:disclosure-open;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc section:not(.module-info) .docstring{margin-left:clamp(0rem, 5vw - 2rem, 1rem);}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target,.pdoc .pdoc-code > pre > span:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc .pdoc-code > pre > span:target{display:block;}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc *{scroll-margin:2rem;}.pdoc .pdoc-code .linenos{user-select:none;}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc section, .pdoc .classattr{position:relative;}.pdoc .headerlink{--width:clamp(1rem, 3vw, 2rem);position:absolute;top:0;left:calc(0rem - var(--width));transition:all 100ms ease-in-out;opacity:0;}.pdoc .headerlink::before{content:"#";display:block;text-align:center;width:var(--width);height:2.3rem;line-height:2.3rem;font-size:1.5rem;}.pdoc .attr:hover ~ .headerlink,.pdoc *:target > .headerlink,.pdoc .headerlink:hover{opacity:1;}.pdoc .attr{display:block;margin:.5rem 0 .5rem;padding:.4rem .4rem .4rem 1rem;background-color:var(--accent);overflow-x:auto;}.pdoc .classattr{margin-left:2rem;}.pdoc .decorator-deprecated{color:#842029;}.pdoc .decorator-deprecated ~ span{filter:grayscale(1) opacity(0.8);}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{background-color:transparent;}.pdoc .param, .pdoc .return-annotation{white-space:pre;}.pdoc .signature.multiline .param{display:block;}.pdoc .signature.condensed .param{display:inline-block;}.pdoc .annotation{color:var(--annotation);}.pdoc .view-value-toggle-state,.pdoc .view-value-toggle-state ~ .default_value{display:none;}.pdoc .view-value-toggle-state:checked ~ .default_value{display:inherit;}.pdoc .view-value-button{font-size:.5rem;vertical-align:middle;border-style:dashed;margin-top:-0.1rem;}.pdoc .view-value-button:hover{background:white;}.pdoc .view-value-button::before{content:"show";text-align:center;width:2.2em;display:inline-block;}.pdoc .view-value-toggle-state:checked ~ .view-value-button::before{content:"hide";}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style><script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
    /* Re-invoke MathJax when DOM content changes, for example during search. */
    document.addEventListener("DOMContentLoaded", () => {
        new MutationObserver(() => MathJax.typeset()).observe(
            document.querySelector("main.pdoc").parentNode,
            {childList: true}
        );
    })
</script>
<style>
    mjx-container {
        overflow-x: auto;
        overflow-y: hidden;
    }
</style><style>
    .pdoc .mermaid-pre {
        border: none;
        background: none;
    }
</style>
<script type="module" defer>
    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs";

    /* Re-invoke Mermaid when DOM content changes, for example during search. */
    document.addEventListener("DOMContentLoaded", () => {
        new MutationObserver(() => mermaid.run()).observe(
            document.querySelector("main.pdoc").parentNode,
            {childList: true}
        );
    })
</script></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>

            <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                   pattern=".+" required>

            <h2>Contents</h2>
            <ul>
  <li><a href="#geff-established-in-2025">GEFF: Established in 2025</a></li>
  <li><a href="#the-refreshing-taste-of-gef">The refreshing taste of GEF</a></li>
  <li><a href="#sampling-the-gef-flavors">Sampling the GEF flavors</a>
  <ul>
    <li><a href="#choosing-your-flavor">Choosing your flavor</a></li>
    <li><a href="#getting-a-taste">Getting a taste</a></li>
    <li><a href="#a-rich-palette">A rich palette</a></li>
  </ul></li>
  <li><a href="#on-the-factory-floor">On the factory floor</a></li>
  <li><a href="#create-your-own-flavor">Create your own flavor</a>
  <ul>
    <li><a href="#the-first-step-is-the-hardest">The first step is the hardest</a></li>
    <li><a href="#only-the-best-ingredients">Only the best ingredients</a></li>
    <li><a href="#write-a-recipe">Write a recipe</a></li>
    <li><a href="#the-finishing-touch">The finishing touch</a></li>
  </ul></li>
</ul>


            <h2>Submodules</h2>
            <ul>
                    <li><a href="geff/bgtypes.html">bgtypes</a></li>
                    <li><a href="geff/gef.html">gef</a></li>
                    <li><a href="geff/mbm.html">mbm</a></li>
                    <li><a href="geff/models.html">models</a></li>
                    <li><a href="geff/solver.html">solver</a></li>
                    <li><a href="geff/tools.html">tools</a></li>
                    <li><a href="geff/utility.html">utility</a></li>
            </ul>

            <h2>API Documentation</h2>
                <ul class="memberlist">
    </ul>


            <footer>GEFF v0.1.0</footer>

        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev" target="_blank">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section class="module-info">
                    <h1 class="modulename">
geff    </h1>

                        <div class="docstring"><p>Welcome to our visitors tour of the <strong>Gradient Expansion Formalism Factory</strong>!</p>

<hr />

<h1 id="geff-established-in-2025">GEFF: Established in 2025</h1>

<p>This python package is designed to handle gauge-field production during cosmic inflation
using the <em>gradient expansion formalism</em> (GEF).</p>

<p>If you are interested in axion inflation, the package comes with everything you need:</p>

<ul>
<li><strong>a variety of flavors</strong>
<ul>
<li>pure axion inflation (PAI) : <em>good ol' axion inflation</em></li>
<li>fermionic axion inflation (FAI) : <em>axion inflation with Standard Model fermions!</em></li>
</ul></li>
<li><strong>useful tools</strong>
<ul>
<li>Resolve the dynamics of axion inflation including homogeneous backreaction.</li>
<li>Analyze the gauge-field spectrum.</li>
<li>Determine the vacuum and induced tensor power spectrum.</li>
<li>Compute gravitational-wave spectra.</li>
</ul></li>
</ul>

<p>But we don't want to hold you back! The package provides a flexible framework to create your <strong>own GEF flavor</strong>, with all built-in tools at your disposable. 
It is indeed a true GEF <em>factory</em> !</p>

<p>You can install this package using pip</p>

<div class="pdoc-code codehilite">
<pre><span></span><code>pip<span class="w"> </span>install<span class="w"> </span>cosmo-geff
</code></pre>
</div>

<p>or using the <code>geff.yml</code> file found at the <a href="https://github.com/riroro13/GEFF">GitHub repository</a> for this package,</p>

<div class="pdoc-code codehilite">
<pre><span></span><code>conda<span class="w"> </span>env<span class="w"> </span>create<span class="w"> </span>-f<span class="w"> </span>geff.yml
</code></pre>
</div>

<p>If you use this package in your work, please cite (...).</p>

<hr />

<h1 id="the-refreshing-taste-of-gef">The refreshing taste of GEF</h1>

<p>The GEF is a numerical technique to determine the dynamics and backreaction of gauge-fields during inflation
by directly evolving the time-dependent quantum expectation values of the gauge field, 
e.g., $\langle {\bf E}^2 \rangle$, $\langle {\bf B}^2 \rangle$, $\langle {\bf E} \cdot {\bf B} \rangle$ etc.
If this is the first time you encounter the GEF, here are some useful articles on the topic:</p>

<ul>
<li><a href="https://arxiv.org/abs/2109.01651">2109.01651</a></li>
<li><a href="https://arxiv.org/abs/2310.09186">2310.09186</a></li>
<li><a href="https://arxiv.org/abs/2408.16538">2408.16538</a></li>
</ul>

<p>The strategy behind the GEF is to take Maxwell's equations in an expanding spacetime,</p>

<p><a name="max">$$\operatorname{div} {\bf E} = 0\, , \qquad \operatorname{div} {\bf B} = 0\, ,$$</a>
$$\dot{{\bf E}} + 2 H {\bf E} - \frac{1}{a}\operatorname{rot} {\bf B} + {\bf J} = 0 \, ,$$
$$\dot{{\bf B}}  + 2 H {\bf B} + \frac{1}{a}\operatorname{rot} {\bf E} = 0 \,$$</p>

<p>and use them to formulate a tower of ODEs for the quantities</p>

<p>$$ \mathcal{F}_\mathcal{E}^{(n)} = \frac{a^4}{k_{{\rm UV}}^{n+4}}\langle {\bf E} \cdot \operatorname{rot}^n {\bf E}\rangle = \int\limits_{0}^{k_{{\rm UV}}(t)}\frac{{\rm d} k}{k} \frac{a^2 k^{n+3}}{2 \pi^2 k_{{\rm UV}}^{n+4}}  \sum_{\lambda}\lambda^n |\dot{A}_\lambda(t,k)|^2\, ,$$
$$ \mathcal{F}_\mathcal{G}^{(n)} = -\frac{a^4}{2 k_{{\rm UV}}^{n+4}}\langle {\bf E} \cdot \operatorname{rot}^n {\bf B} + {\bf B} \cdot \operatorname{rot}^n {\bf E}\rangle = \int\limits_{0}^{k_{{\rm UV}}(t)} \frac{{\rm d} k}{k} \frac{a k^{n+4}}{2 \pi^2 k_{{\rm UV}}^{n+4}}\sum_{\lambda}\lambda^{n+1} \operatorname{Re}[\dot{A}_\lambda(t,k)A_\lambda^*(t,k)] \, ,$$
$$ \mathcal{F}_\mathcal{B}^{(n)} = \frac{a^4}{k_{{\rm UV}}^{n+4}}\langle {\bf B} \cdot \operatorname{rot}^n {\bf B}\rangle = \int\limits_{0}^{k_{{\rm UV}}(t)}\frac{{\rm d} k}{k} \frac{k^{n+5}}{2 \pi^{2}k_{{\rm UV}}^{n+4}} \sum_{\lambda}\lambda^n |A_\lambda(t,k)|^2 \, ,$$</p>

<p>where, $k_{\rm UV}$ is a suitably chosen UV regulator which can vary with time. 
For completeness, we have also given the expression for $\mathcal{F}_\mathcal{X}^{(n)}$ in terms of the mode functions $A_\lambda(t,k)$.</p>

<p>The ODE for the $\mathcal{F}_\mathcal{X}^{(n)}$'s are then given by</p>

<p>$$\frac{\rm d}{{\rm d} t} \mathcal{F}_\mathcal{E}^{(n)} + (4+n)\frac{{\rm d} \ln k_{\rm UV}}{{\rm d} t} \mathcal{F}_\mathcal{E}^{(n)}  + 2\frac{k_{\rm UV}}{a}\mathcal{F}_\mathcal{G}^{(n+1)} + 2 \frac{a^4}{k_{\rm UV}^{n+4}} \langle {\bf J} \cdot \operatorname{rot}^n {\bf E} \rangle =  S_{\mathcal{E}}^{(n)}\, , $$
$$\frac{\rm d}{{\rm d} t} \mathcal{F}_\mathcal{G}^{(n)} + (4+n)\frac{{\rm d} \ln k_{\rm UV}}{{\rm d} t} \mathcal{F}_\mathcal{G}^{(n)} - \frac{k_{\rm UV}}{a}\left(\mathcal{F}_\mathcal{E}^{(n+1)} - \mathcal{F}_\mathcal{B}^{(n+1)}\right) - \frac{a^4}{k_{\rm UV}^{n+4}} \langle {\bf J} \cdot \operatorname{rot}^n {\bf B} \rangle= S_{\mathcal{G}}^{(n)}\, , $$
$$\frac{\rm d}{{\rm d} t} \mathcal{F}_\mathcal{B}^{(n)} + (4+n)\frac{{\rm d} \ln k_{\rm UV}}{{\rm d} t} \mathcal{F}_\mathcal{B}^{(n)} - 2\frac{k_{\rm UV}}{a}\mathcal{F}_\mathcal{G}^{(n+1)}  =  S_{\mathcal{B}}^{(n)}\, .$$</p>

<p>Although these are infinitely many coupled ODE's, one can typically determine an analytical closing condition, such that they may be truncated at some order $n_{\rm tr}$.</p>

<p>The ODEs for the $\mathcal{F}_\mathcal{X}^{(n)}$ can now be simply solved alongside those of the inflationary background.
This way, one can handle gauge-field backreaction onto the background dynamics of inflation.</p>

<p>The GEFF package is designed to help the user in the process of solving these equations in the following way</p>

<ul>
<li>pre-defined and ready-to-use <a href="#basics">GEF flavors</a></li>
<li>tailored <a href="#algorithm">algorithm</a> to solve the inflationary background dynamics</li>
<li>options to <a href="#model_creation">implement your own GEF flavor</a></li>
</ul>

<hr />

<p><a name="basics"></p>

<h1 id="sampling-the-gef-flavors">Sampling the GEF flavors</h1>

<p>GEF models come in various flavors, some of the most intresting applications of the GEF are already implemented in this package.
As the first part of our tour, we explore the basic application of the GEFF code using these pre-defined models.</p>

<h2 id="choosing-your-flavor">Choosing your flavor</h2>

<p>We start by sampling a first flavor of our choice; the model "pai":</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">geff</span><span class="w"> </span><span class="kn">import</span> <span class="n">compile_model</span>

<span class="c1"># Create the GEF model of our choice</span>
<span class="n">paiGEF</span> <span class="o">=</span> <span class="n">compile_model</span><span class="p">(</span><span class="s2">&quot;pai&quot;</span><span class="p">)</span>
</code></pre>
</div>

<p>The object <code>paiGEF</code> is the compiled version of the model found under <code><a href="geff/models/pai.html">geff.models.pai</a></code>. It defines an ODE solver 
which needs to be initialized with information on the setup we want to study:
The "pai" model expects information on the inflaton--vector coupling $\beta / M_{\rm P}$, 
initial conditions for the inflaton field, $\varphi(0)$, $\dot\varphi(0)$, and the shape of the inflaton potential, $V(\varphi)$.</p>

<p>In this example, we configure the model to start on the slow-roll attractor of a chaotic inflation potential:</p>

<p>$$ \varphi(0) = 15.55 M_{\rm P}, \qquad \dot{\varphi}(0) = -\sqrt{\frac{2}{3}} m M_{\rm P}, \qquad V(\varphi) = \frac{1}{2}m^2 \varphi^2$$</p>

<p>where $m = 6.16 \times 10^{-6} M_{\rm P}$. We set the coupling to $\beta = 15$.</p>

<p>The necessary information is passed to <code>paiGEF</code> as keyword arguments:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">m</span> <span class="o">=</span> <span class="mf">6.16e-6</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mi">15</span>

<span class="n">phi</span> <span class="o">=</span> <span class="mf">15.55</span>
<span class="n">dphi</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">m</span>

<span class="k">def</span><span class="w"> </span><span class="nf">V</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">m</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="k">def</span><span class="w"> </span><span class="nf">dV</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">m</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span>

<span class="n">mod</span> <span class="o">=</span> <span class="n">paiGEF</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">phi</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span> <span class="n">dphi</span><span class="o">=</span><span class="n">dphi</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="n">V</span><span class="p">,</span> <span class="n">dV</span><span class="o">=</span><span class="n">dV</span><span class="p">)</span>
</code></pre>
</div>

<p>If you want to know what input is expected by the GEF model, use the <code>print_input</code> method of <code>paiGEF</code>.</p>

<blockquote>
  <p><strong>A note on units</strong>:
  The pre-defined GEF flavors in the GEFF package work in Planck units $M_{\rm P}=1$. 
  From the input, the GEF determines the Hubble rate at initialization, $H_0$, (also in Planck units).
  Internally, the numerical routines work with dimensionless quantities, e.g., $\bar{X} = X H_0^{-a} M_{\rm P}^{-b}$ with $a$ and $b$ indicating
  how $X$ scales with an inverse timescale (e.g., $H_0$) and an energy scale (e.g., $M_{\rm P}$).
  For example, the dimensionless inflaton velocity would be like $\dot{\bar{\varphi}} = \dot{\varphi}/(H_0 M_{\rm P})$,
  i.e., $\dot{\varphi}$ scales like an amplitude, $\varphi \sim M_{\rm P}$, and a derivative, $\partial_t \sim H_0$.
  Don't worry, this is happening under the hood, but if you want more details, see <code><a href="geff/bgtypes.html">geff.bgtypes</a></code>.</p>
</blockquote>

<h2 id="getting-a-taste">Getting a taste</h2>

<p>Now, that our model is initialized, we can solve the inflationary background evolution from these initial conditions:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">sol</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</code></pre>
</div>

<p>The <code>run</code> method returned three objects. The evolution of the background dynamics is contained in <code>sol</code>,
the evolution on the gauge-field mode functions, $A_\lambda(t, k)$, are computed and returned as the
object <code>spec</code>, while <code>info</code> is just a byproduct that contains full information on the ODE solution in <code>sol</code>.
For basic applications, all information we actually want is in <code>sol</code> and <code>spec</code>.</p>

<p>Let us focus on <code>sol</code>. It is a <code>BGSystem</code> object which we can use to access the time evolution of several important inflationary quantities defined by our "pai" model.
For example, you can use it to make a basic plot showing the evolution of the energy densities during inflation as a function of $e$-folds</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Plot the evolution of the inflaton amplitude as a function of e-folds:</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">dphi</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">sol</span><span class="o">.</span><span class="n">H</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># inflaton kinetic energy density</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">E</span> <span class="o">+</span> <span class="n">sol</span><span class="o">.</span><span class="n">B</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">sol</span><span class="o">.</span><span class="n">H</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># electromagnetic energy density</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">phi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">sol</span><span class="o">.</span><span class="n">H</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># inflaton potential energy density</span>

<span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre>
</div>

<p>How did we know that <code>sol</code> owns the attributes <code>N</code>,<code>phi</code>, etc.? You can find out using <code>sol.value_names()</code>.
To print a full description of all available variables for "pai", you can use <code>paiGEF.print_ingredients()</code>. 
Otherwise, this information can also be found at <code><a href="geff/models/pai.html">geff.models.pai</a></code>. 
If you need a brief description of any variable <code>X</code>, use <code>X.get_description()</code>.</p>

<blockquote>
  <p><strong>A note on variables:</strong>
  The variables encoded in a GEF model use a custom class called <code>Variable</code>. They work like a <code>numpy</code> array. 
  Additionally, constants are realized using the class <code>Constant</code>, and work like a <code>float</code>.
  Dimensionful functions like the inflaton potential use the <code>Func</code> class, and can be used like a regular function.
  These classes are defined to take care of unit conversions and are collectively attatched to a <code>BGSystem</code>. If you are curious, have a look at <code><a href="geff/bgtypes.html">geff.bgtypes</a></code>.</p>
</blockquote>

<p>We did not only get back a <code>sol</code> object, but also <code>spec</code>. This object contains the gauge-field mode functions $A_\lambda(t,k)$.
The code computes these mode functions after having solved the dynamics of the background system ($H(t)$, $\varphi(t)$ etc.),
and uses them for estimating the convergence of the background solution. 
We briefly discuss this algorithm in <a href="#algorithm">the next section</a>.</p>

<p>The object <code>spec</code> is an instance of the <code>GaugeSpec</code> class, which defines useful methods for handling time-dependent gauge-field spectra.
For details, see <code><a href="geff/mbm.html#GaugeSpec">.mbm.GaugeSpec</a></code>.</p>

<blockquote>
  <p><strong>A note on gauge-field spectra</strong>
  If you are only interested in the background evolution and not in the gauge-field spectrum, set <code>nmodes=None</code> in <code>run()</code>.
  However, it is advised to compute gauge-field spectra to ensure consistency between the background evolution and the spectra.</p>
</blockquote>

<p>Next, let us store our GEF and mode solutions in a file:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="c1"># some dummy paths for illustration</span>
<span class="n">gefpath</span> <span class="o">=</span> <span class="s2">&quot;some_gef_file.dat&quot;</span>
<span class="n">mbmpath</span> <span class="o">=</span> <span class="s2">&quot;some_mbm_file.dat&quot;</span>

<span class="n">sol</span><span class="o">.</span><span class="n">save_variables</span><span class="p">(</span><span class="n">gefpath</span><span class="p">)</span>
<span class="n">spec</span><span class="o">.</span><span class="n">save_spec</span><span class="p">(</span><span class="n">mbmpath</span><span class="p">)</span>
</code></pre>
</div>

<p>The data can be restored from these files using</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">geff</span><span class="w"> </span><span class="kn">import</span> <span class="n">GaugeSpec</span>

<span class="n">sol</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">load_GEFdata</span><span class="p">(</span><span class="n">gefpath</span><span class="p">)</span>
<span class="n">spec</span> <span class="o">=</span> <span class="n">GaugeSpec</span><span class="o">.</span><span class="n">read_spec</span><span class="p">(</span><span class="n">mbmpath</span><span class="p">)</span>
</code></pre>
</div>

<blockquote>
  <p><strong>A note on storage:</strong>
  The <code>save_variables</code> method does not store information on constants or functions. So, to retrieve
  the full information on our GEF run, we need to use an appropriately configured instance of
  <code>paiGEF</code>. In the example above, this is achieved by reusing <code>mod</code>.</p>
</blockquote>

<h2 id="a-rich-palette">A rich palette</h2>

<p>Obtaining the inflationary dynamics is nice, but it is not all the GEFF can do. For example, let's use our results to compute the corresponding gravitational-wave spectrum:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn"><a href="geff/tools.html">geff.tools</a></span><span class="w"> </span><span class="kn">import</span> <span class="n">PowSpecT</span><span class="p">,</span> <span class="n">omega_gw</span>

<span class="c1"># Use sol to initialize the PowSpecT class</span>
<span class="n">pt_fai</span> <span class="o">=</span> <span class="n">PowSpecT</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>

<span class="c1"># Compute the vacuum and induced power spectrum for 100 momentum modes k using spec:</span>
<span class="n">ks</span><span class="p">,</span> <span class="n">pt_spec</span> <span class="o">=</span> <span class="n">pt_fai</span><span class="o">.</span><span class="n">compute_pt</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span>

<span class="c1"># from the power spectrum, we can then deduce the gravitational-wave spectrum:</span>
<span class="n">f</span><span class="p">,</span> <span class="n">gwspec</span> <span class="o">=</span> <span class="n">omega_gw</span><span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">pt_spec</span><span class="p">[</span><span class="s2">&quot;tot&quot;</span><span class="p">],</span> <span class="n">Nend</span><span class="o">=</span><span class="n">sol</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Hend</span><span class="o">=</span><span class="n">sol</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre>
</div>

<p>We can just use  <code>sol</code> to extract the relevant information on the background solution.
It's that easy!</p>

<p>To finish this first part of our tour, let us sample a second GEF flavor, "fai_kh":</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="c1"># initialize the model</span>
<span class="n">faiGEF</span> <span class="o">=</span> <span class="n">GEFModel</span><span class="p">(</span><span class="s2">&quot;fai_kh&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;picture&quot;</span><span class="p">:</span><span class="s2">&quot;electric&quot;</span><span class="p">})</span>

<span class="c1"># chose initial conditions</span>
<span class="n">mod</span> <span class="o">=</span> <span class="n">faiGEF</span><span class="p">(</span><span class="n">beta</span><span class="o">=...</span><span class="p">)</span>

<span class="c1"># solve the ODEs as before</span>
<span class="n">sol</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="o">...</span>
<span class="o">...</span>
</code></pre>
</div>

<p>This model comes in three varieties ("pictures") corresponding to the effective treatment of fermions in the model.
We specified the particular variety py passing a <code>settings</code> dictionary upon creating the model.</p>

<p>For more details on the available models, see <code><a href="geff/models.html">geff.models</a></code>.</p>

<p><a name="algorithm"></p>

<h1 id="on-the-factory-floor">On the factory floor</h1>

<p>Next on the tour of the GEF factory, we visit the production line.
The following diagram sketches the basic algorithm behind the <code>run</code> method.</p>

<pre class="mermaid-pre"><div class="mermaid">---
config:
    flowchart:
        defaultRenderer: "elk"
    theme: 'base'
    themeVariables:
        secondaryColor: '#CFCFC6'
        tertiaryColor: '#FAFAFA'
---
graph TB
    subgraph A["`**GEFModel**`"]
        direction TB
        St((initial data &lt;br&gt;from model))--&gt; GS
        subgraph GS["`**GEFSolver**`"]
            direction LR
            GS1[/initial data/] --&gt; GS2[solve background ODEs] --&gt; GS3[/background &lt;br&gt; dynamics/]
        end
        GS -.-&gt; MbM
        subgraph MbM["`**ModeSolver**`"]
            direction LR
            MbM1[/background &lt;br&gt; dynamics/] --&gt; MbM2[compute &lt;br&gt;mode functions] --&gt; MbM3[/spectrum/]
        end
        MbM -.-&gt; A2[compare &lt;br&gt;background dynamics &lt;br&gt;&amp; spectrum]
        C[self-correction &lt;br&gt; using spectrum]
        GS --&gt; A2
        A2 -.-&gt; |disagreement| C -.-&gt;  GS
    A2 --&gt; |agreement|Fin[finalize] --&gt; R1((background &lt;br&gt; dynamics))
    Fin -.-&gt; R2((spectrum))
    end
</div></pre>

<p>As we have seen in the <a href="#basics">first section</a>, the <code>run</code> method is executed as part of a GEF Model.
Each GEF Model consists of two components, the <code>GEFSolver</code> and the <code>ModeSolver</code>. The former determines the time-dependent inflationary background, 
the latter computes the mode functions $A_\lambda(t,k)$.
The two results can then be compared to eachother to assess the convergence of the background dynamics.
If the two disagree, the GEF will attempt to self-correct using $A_\lambda(t,k)$.</p>

<p>Note that, if you use <code>run(nmodes=None)</code>, the dotted lines in the diagram can be ignored; the background solution is immediately returned without
computing the gauge-field spectrum.</p>

<p>For more details on the <code>GEFSolver</code>, see <code><a href="geff/solver.html">geff.solver</a></code>, while for the <code>ModeSolver</code> see <code><a href="geff/mbm.html">geff.mbm</a></code>.</p>

<hr />

<p><a name="model_creation"></p>

<h1 id="create-your-own-flavor">Create your own flavor</h1>

<p>Having explored the potential of the GEFF code, you may be inclined to create your own GEF flavor.
To help you in this process, we show how to implement an example toy model.</p>

<blockquote>
  <p><strong>Warning</strong>: Before jumping into this section, we advise that you first familiarize yourself with the GEF method.
  Also, this tutorial works best, if you have a basic knowledge of the classes defined in <code><a href="geff/bgtypes.html">geff.bgtypes</a></code>.</p>
</blockquote>

<h2 id="the-first-step-is-the-hardest">The first step is the hardest</h2>

<p>First, we need to work out the mathematical formulation of our model.</p>

<p>Let us consider the case of Abelian gauge-field production in de Sitter space ($H={\rm const.}$) by a current of the type ${\bf J} = 2 H \xi {\bf B}$, 
where $\xi$ is a constant, which we refer to as instability parameter.The ODE tower for the gauge-field bilinears are then given by:</p>

<p>$$\frac{\rm d}{{\rm d} t} \mathcal{F}_\mathcal{E}^{(n)} + (4+n)\frac{{\rm d} \ln k_\mathrm{h}}{{\rm d} t} \mathcal{F}_\mathcal{E}^{(n)}  + 2\frac{k_\mathrm{h}}{a}\mathcal{F}_\mathcal{G}^{(n+1)} - 4 H \xi \mathcal{F}_\mathcal{G}^{(n)}=  S_{\mathcal{E}}^{(n)}\, , $$
$$\frac{{\rm d}}{{\rm d} t} \mathcal{F}_\mathcal{G}^{(n)} + (4+n)\frac{{\rm d} \ln k_\mathrm{h}}{{\rm d} t} \mathcal{F}_\mathcal{G}^{(n)} - \frac{k_\mathrm{h}}{a}\left(\mathcal{F}_\mathcal{E}^{(n+1)} - \mathcal{F}_\mathcal{B}^{(n+1)}\right) - 2 H \xi \mathcal{F}_\mathcal{B}^{(n)}= S_{\mathcal{G}}^{(n)}\, , $$
$$\frac{{\rm d}}{{\rm d} t} \mathcal{F}_\mathcal{B}^{(n)} + (4+n)\frac{{\rm d} \ln k_\mathrm{h}}{{\rm d} t} \mathcal{F}_\mathcal{B}^{(n)} - 2\frac{k_\mathrm{h}}{a}\mathcal{F}_\mathcal{G}^{(n+1)}  =  S_{\mathcal{B}}^{(n)}\, .$$</p>

<p>One can determine that a sensible regularization scale for this model is given by $k_{\rm h}(t) = 2aH\xi$. </p>

<p>The boundary terms $S_\mathcal{X}^{(n)}$ are a consequence of the time dependence of $k_{\rm h}$. They are expressed in terms of Whittaker functions,
but the GEFF has a module that takes care of them. We will see this later.</p>

<p>Once we have worked out the equations, we can turn to writing a new model file.</p>

<h2 id="only-the-best-ingredients">Only the best ingredients</h2>

<p>The first thing we should state in our model file is the name of the new GEF flavor:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;tutorial&quot;</span>
</code></pre>
</div>

<blockquote>
  <p><strong>A note on settings</strong>: Following the model's name, you can also define a <code>settings</code> dictionary.
  This dictionary should contain some key&ndash;value pair defining its name and the default setting.
  The <code>settings</code> should be accompanied by a function called <code>interpret_settings</code>. This method will be called on model creation,
  so you can use it to define how user input settings are handled. See, e.g., <code>.models.SE_kh</code> for how this is done in practice.</p>
</blockquote>

<p>Next, we need to define define and categorize the variables which appear in our model. This is taken care of by the functions <code>define_var</code>, <code>define_const</code>,  and <code>define_func</code>.
The <code><a href="geff/bgtypes.html">geff.bgtypes</a></code> module also contains some pre-defined variables, which are often encountered in GEF models.</p>

<p>There are three variables which every GEF model needs to define:</p>

<ul>
<li>$t$ - <em>cosmic time</em> : all ODE's are solved in terms of $t$ starting from $t=0$.</li>
<li>$N$ - <em>$e$-folds</em> : needed by most internal methods. It should be defined such that $N(t=0)=0$.</li>
<li>$H$ - <em>Hubble rate</em> : needed by most internal methods.</li>
</ul>

<p>Beyond these staples, some extra variables appear in our ODE's:</p>

<ul>
<li>$\mathcal{F}_\mathcal{X}^{(n)}$ - <em>the gauge-field bilinears</em></li>
<li>$k_{\rm h}$ - <em>the UV regulator</em></li>
<li>$\xi$ -  <em>the instability parameter</em></li>
</ul>

<p>To properly account for the gauge field, we also need to add in the following three variables:</p>

<ul>
<li>$\mathcal{E}^{(0)} = \langle {\bf E}^2 \rangle$ - <em>called <code>E</code> by the GEF</em></li>
<li>$\mathcal{B}^{(0)} = \langle {\bf B}^2 \rangle$ - <em>called <code>B</code> by the GEF</em></li>
<li>$\mathcal{G}^{(0)} = -\langle {\bf E} \cdot {\bf B} \rangle$ - <em>called <code>G</code> by the GEF</em></li>
</ul>

<blockquote>
  <p><strong>Note on gauge field bilinears</strong> The time evolution of the variables $\mathcal{F}_\mathcal{X}^{(n)}$ will not be saved by the GEFF code,
  since we are typically only interest in the quantities with $n=0$. The output <code>info</code> returned by the <code>run</code> method contains the full information on $\mathcal{F}_\mathcal{X}^{(n)}$,
  but only the information on $n=0$ is passed to <code>sol</code> in the form of  <code>E</code>, <code>B</code> and <code>G</code>.</p>
</blockquote>

<p>All these variables need to be defined in our model file. This is done as follows:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn"><a href="geff/bgtypes.html">geff.bgtypes</a></span><span class="w"> </span><span class="kn">import</span> <span class="n">define_const</span>

<span class="c1"># We make use of the fact that a lot of these variables are pre-defined:</span>
<span class="kn">from</span><span class="w"> </span><span class="nn"><a href="geff/bgtypes.html">geff.bgtypes</a></span><span class="w"> </span><span class="kn">import</span> <span class="n">t</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">kh</span><span class="p">,</span> <span class="n">GF</span>

<span class="c1"># We also need to define some new objects:</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">define_const</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="n">qu_omega</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">qu_mu</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Hubble rate (scales like inverse time)</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">define_const</span><span class="p">(</span><span class="s2">&quot;xi&quot;</span><span class="p">,</span> <span class="n">qu_omega</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">qu_mu</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># instability parameter</span>
</code></pre>
</div>

<p>We use <code>define_const</code> to define the constants for our model: $H$ and $\xi$.
The Hubble rate has mass dimension one, and scales with an inverse time-scale $\omega$ as, $H = \bar{H} \omega$.
It does not scale like an amplitude $\mu$. Hence, <code>qu_omega=1</code> and <code>qu_mu=0</code>.
Similarly, $\xi$ is just a number, and we set <code>qu_omega=0</code> and <code>qu_mu=0</code>.
This information needs to be passed to properly allow for unit conversions in the code.
More information on units and scaling is given in <code><a href="geff/bgtypes.html">geff.bgtypes</a></code>.</p>

<p>All the variables we have defined serve a specific purpose in our GEF model. To inform the GEFF of this, we need to classify each of them in one of these categories:</p>

<ul>
<li><strong>time</strong>: a time variable (needs to be <code>t</code>)</li>
<li><strong>dynamical</strong>: variables whose time-evolution is determined from a differential equation.</li>
<li><strong>gauge</strong>: the gauge-field variable <code>GF</code> representing $\mathcal{F}_\mathcal{X}^{(n)}$.</li>
<li><strong>static</strong>: variables whose time-evolution is computed from other variables.</li>
<li><strong>constant</strong>: constants of time.</li>
<li><strong>function</strong>: functions of the above.</li>
</ul>

<p>In our case, this would look as follows:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">quantities</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:[</span><span class="n">t</span><span class="p">],</span> <span class="c1"># this is mandatory!</span>
            <span class="s2">&quot;dynamical&quot;</span><span class="p">:[</span><span class="n">kh</span><span class="p">],</span> <span class="c1"># kh is best evolved from an ODE</span>
            <span class="s2">&quot;gauge&quot;</span><span class="p">:[</span><span class="n">GF</span><span class="p">],</span> <span class="c1"># state the obvious</span>
            <span class="s2">&quot;static&quot;</span><span class="p">:[</span><span class="n">N</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">],</span> <span class="c1"># directly computed from other variables</span>
            <span class="s2">&quot;constant&quot;</span><span class="p">:[</span><span class="n">H</span><span class="p">,</span> <span class="n">xi</span><span class="p">],</span> <span class="c1"># we assume de-Sitter space, and xi is a constant</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:[]</span>  <span class="c1"># our model does not need any functions</span>
            <span class="p">}</span>
</code></pre>
</div>

<h2 id="write-a-recipe">Write a recipe</h2>

<p>With the variables defined, an important step towards our GEF model is already taken. 
Next, let us set up the <code>GEFSolver</code>. (For more details, see <code><a href="geff/solver.html#GEFSolver">.solver.GEFSolver</a></code>.)</p>

<p>Internally, the GEFF package uses <code>scipy.integrate.solve_ivp</code> to solve differential equations. 
This requires that ODE's are formulated as $\dot{\vec{y}} = f(t, \vec{y})$ with $\vec{y}$ as a <code>numpy</code> array.
However, the GEFF prefers the <code>BGSystem</code> class, which takes care of unit conversions.
So, we need to define how to translate between the two.</p>

<p>First up, we define how to interpret user input to initialize the array $\vec{y}$:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">initial_conditions</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">ntr</span><span class="p">):</span>
    <span class="n">yini</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">ntr</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">yini</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sys</span><span class="o">.</span><span class="n">xi</span><span class="o">*</span><span class="n">sys</span><span class="o">.</span><span class="n">H</span><span class="p">)</span> <span class="c1">#index 0 of yini is log(kh)</span>

    <span class="c1"># initialize all F_X^n as zero at indices [1:]</span>

    <span class="k">return</span> <span class="n">yini</span>
</code></pre>
</div>

<p>Note how <code>sys</code> has attributes <code>xi</code> and <code>H</code>. These correspond to the variables we have defined in the previous step.</p>

<p>Importantly, upon defining <code>initial_conditions</code>, we also make a choice; which entries in $\vec{y}$ correspond to which dynamical variable.
In our simple toy model, there actually is no choice to be made: The GEFF package expects that the gauge-field variables are stored <em>after</em> all
dynamical variables, as the number of the $\mathcal{F}_\mathcal{X}^{(n)}$'s will vary depending on $n_{\rm tr}$.
Hence, $k_{\rm h}$ necessarily goes first. However, we do have the choice of evolving $\log k_{\rm h}$ instead of $k_{\rm h}$.</p>

<p>Next, we write the recipe used to define our GEF ODE. The ODE evolution is computed in two steps:</p>

<ol>
<li><code>update_values</code>: Update <code>sys</code> according to $\vec{y}(t)$.</li>
<li><code>timestep</code>: Compute $\dot{\vec{y}}(t)$ from <code>sys</code>.</li>
</ol>

<p>To define <code>update_values</code>, we can use all the variables which we have previously declared (they are assumed to be in numerical units):</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">update_values</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sys</span><span class="p">):</span>
    <span class="c1"># evolution of spacetime</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">t</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">N</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">t</span><span class="o">*</span><span class="n">sys</span><span class="o">.</span><span class="n">H</span> <span class="c1">#perfect de Sitter</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">N</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="c1"># define how kh is computed from xi:</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">kh</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># y[0] is log(kh)</span>

    <span class="c1"># use that y[1] = F_E^0, y[2] = F_B^0, y[3] = F_G^0</span>
    <span class="n">rescale</span> <span class="o">=</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">kh</span><span class="o">/</span><span class="n">sys</span><span class="o">.</span><span class="n">a</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">rescale</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">rescale</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">G</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">rescale</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="k">return</span>
</code></pre>
</div>

<p>For <code>timestep</code>, we can make use of some pre-defined functions in the <code><a href="geff/utility.html">geff.utility</a></code> module.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn"><a href="geff/utility/eom.html">geff.utility.eom</a></span><span class="w"> </span><span class="kn">import</span> <span class="n">gauge_field_ode</span>
<span class="kn">from</span><span class="w"> </span><span class="nn"><a href="geff/utility/boundary.html">geff.utility.boundary</a></span><span class="w"> </span><span class="kn">import</span> <span class="n">boundary_approx</span>
<span class="kn">from</span><span class="w"> </span><span class="nn"><a href="geff/utility/general.html">geff.utility.general</a></span><span class="w"> </span><span class="kn">import</span> <span class="n">heaviside</span>

<span class="k">def</span><span class="w"> </span><span class="nf">timestep</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sys</span><span class="p">):</span>
    <span class="n">dydt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">dlnkhdt</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">value</span> <span class="c1">#dlnkhdt derivative</span>
    <span class="n">dydt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dlnkhdt</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">xi</span><span class="o">.</span><span class="n">value</span>

    <span class="c1"># compute boundary terms</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">boundary_approx</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>

    <span class="c1"># reshape arrays to fit gauge_field_ode</span>
    <span class="n">Fcol</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">3</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Fcol</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># compute the gauge-field ODEs</span>
    <span class="n">dFdt</span> <span class="o">=</span> <span class="n">gauge_field_ode</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">kh</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">sys</span><span class="o">.</span><span class="n">H</span><span class="o">*</span><span class="n">xi</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">dlnkhdt</span><span class="p">)</span>
    <span class="c1"># note that we can use &#39;a&#39;, &#39;kh&#39; etc.;</span>
    <span class="c1"># &#39;update_values&#39; is called before &#39;timestep&#39;</span>

    <span class="n">dydt</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">dFdt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Fcol</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># reshape to fit dydt</span>

    <span class="k">return</span> <span class="n">dydt</span>
</code></pre>
</div>

<p>These are all the ingredients we need to formulate the GEF ODE's. We can combine them using the <code><a href="geff/solver.html#GEFSolver">.solver.GEFSolver</a></code> class factory:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn"><a href="geff/solver.html">geff.solver</a></span><span class="w"> </span><span class="kn">import</span> <span class="n">GEFSolver</span>

<span class="n">solver</span> <span class="o">=</span> <span class="n">GEFSolver</span><span class="p">(</span><span class="n">initial_conditions</span><span class="p">,</span> <span class="n">update_values</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">quantities</span><span class="p">)</span>
</code></pre>
</div>

<blockquote>
  <p><strong>Note</strong>: This is just a basic <code>GEFSolver</code>. You can also define <code>Event</code> objects for a solver.
  An <code>Event</code> will check for a certain condition while the ODEs are being solved, and can terminate the solver if the condition is met.
  For example, you can define an <code>Event</code> to check if the end of inflation has been reached, or if some positive definite quantity has become negative.
  A <code>GEFSolver</code> can be configured to check for any <code>Event</code> occurrences and react to them in user-specified ways.
  For more details, see <code><a href="geff/solver.html">geff.solver</a></code>.</p>
</blockquote>

<p>We also should define the <code>ModeSolver</code>. In this toy model, we can just use a pre-defined class. For more complex situations, use <code><a href="geff/mbm.html#ModeSolver">.mbm.ModeSolver</a></code>.</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn"><a href="geff/mbm.html">geff.mbm</a></span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseModeSolver</span>

<span class="n">MbM</span> <span class="o">=</span> <span class="n">BaseModeSolver</span>
</code></pre>
</div>

<h2 id="the-finishing-touch">The finishing touch</h2>

<p>The last thing we need to do is define how our new GEF model is initialized.</p>

<p>First, we need to declare, what input our GEF model expects from the user.
There are two constants, $H$ and $\xi$, and the user should tell us their value:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="n">model_input</span> <span class="o">=</span> <span class="p">[</span><span class="n">H</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">dxi</span><span class="p">]</span>
</code></pre>
</div>

<p>Our model does not require other input; $\mathcal{F}_{\mathcal{X}}^{(n)}$ is initially set to zero, and $k_h(0)$ is determined from $\xi$ and $H$. </p>

<p>The last step is to define the units of our GEF model based on the user input. This is achieved by the <code>define_units</code> function:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">define_units</span><span class="p">(</span><span class="n">H</span><span class="p">):</span>
    <span class="c1"># The characteristic inverse time scale is the constant Hubble rate in Planck units</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">H</span>
    <span class="c1"># The charateristic energy scale is the Planck mass (in Planck units)</span>
    <span class="n">amp</span> <span class="o">=</span> <span class="mf">1.</span> 
    <span class="k">return</span> <span class="n">freq</span><span class="p">,</span> <span class="n">amp</span>
</code></pre>
</div>

<p>The arguments of <code>define_units</code> necessarily needs to be a subset of <code>model_input</code>. In this case, we only need the Hubble rate, <code>H</code> to define our unit system:
The energy scale $\mu$ is the Planck mass in Planck units, while the inverse time scale is the constant Hubble rate $H$.</p>

<p>We are finally done! We can put everything we defined above in a file, which we call "tutorial.py", and we are good to go!</p>

<p>If all went well, you can now use your own GEF flavor just like the pre-defined ones:</p>

<div class="pdoc-code codehilite">
<pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">geff</span><span class="w"> </span><span class="kn">import</span> <span class="n">compile_model</span>
<span class="c1"># Here, we assume you have saved your model as &quot;tutorial.py&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tutorial</span>

<span class="n">TutorialGEF</span> <span class="o">=</span> <span class="n">compile_model</span><span class="p">(</span><span class="n">tutorial</span><span class="p">)</span>

<span class="n">H</span> <span class="o">=</span> <span class="mf">5e-6</span>
<span class="n">xi</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">mod</span> <span class="o">=</span> <span class="n">TutorialGEF</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">xi</span><span class="o">=</span><span class="n">xi</span><span class="p">)</span>

<span class="n">sol</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="o">...</span>
</code></pre>
</div>

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
  import elkLayouts from 'https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0/dist/mermaid-layout-elk.esm.min.mjs';
  mermaid.registerLayoutLoaders(elkLayouts);
</script>
</div>

                        <input id="mod-geff-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">

                        <label class="view-source-button" for="mod-geff-view-source"><span>View Source</span></label>

                        <div class="pdoc-code codehilite"><pre><span></span><span id="L-1"><a href="#L-1"><span class="linenos">  1</span></a><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-2"><a href="#L-2"><span class="linenos">  2</span></a><span class="sd">Welcome to our visitors tour of the **Gradient Expansion Formalism Factory**!</span>
</span><span id="L-3"><a href="#L-3"><span class="linenos">  3</span></a>
</span><span id="L-4"><a href="#L-4"><span class="linenos">  4</span></a><span class="sd">---</span>
</span><span id="L-5"><a href="#L-5"><span class="linenos">  5</span></a>
</span><span id="L-6"><a href="#L-6"><span class="linenos">  6</span></a><span class="sd"># GEFF: Established in 2025</span>
</span><span id="L-7"><a href="#L-7"><span class="linenos">  7</span></a>
</span><span id="L-8"><a href="#L-8"><span class="linenos">  8</span></a><span class="sd">This python package is designed to handle gauge-field production during cosmic inflation</span>
</span><span id="L-9"><a href="#L-9"><span class="linenos">  9</span></a><span class="sd">using the *gradient expansion formalism* (GEF).</span>
</span><span id="L-10"><a href="#L-10"><span class="linenos"> 10</span></a>
</span><span id="L-11"><a href="#L-11"><span class="linenos"> 11</span></a><span class="sd">If you are interested in axion inflation, the package comes with everything you need:</span>
</span><span id="L-12"><a href="#L-12"><span class="linenos"> 12</span></a><span class="sd">- **a variety of flavors**</span>
</span><span id="L-13"><a href="#L-13"><span class="linenos"> 13</span></a><span class="sd">    - pure axion inflation (PAI) : *good ol&#39; axion inflation*</span>
</span><span id="L-14"><a href="#L-14"><span class="linenos"> 14</span></a><span class="sd">    - fermionic axion inflation (FAI) : *axion inflation with Standard Model fermions!*</span>
</span><span id="L-15"><a href="#L-15"><span class="linenos"> 15</span></a><span class="sd">- **useful tools**</span>
</span><span id="L-16"><a href="#L-16"><span class="linenos"> 16</span></a><span class="sd">    - Resolve the dynamics of axion inflation including homogeneous backreaction.</span>
</span><span id="L-17"><a href="#L-17"><span class="linenos"> 17</span></a><span class="sd">    - Analyze the gauge-field spectrum.</span>
</span><span id="L-18"><a href="#L-18"><span class="linenos"> 18</span></a><span class="sd">    - Determine the vacuum and induced tensor power spectrum.</span>
</span><span id="L-19"><a href="#L-19"><span class="linenos"> 19</span></a><span class="sd">    - Compute gravitational-wave spectra.</span>
</span><span id="L-20"><a href="#L-20"><span class="linenos"> 20</span></a>
</span><span id="L-21"><a href="#L-21"><span class="linenos"> 21</span></a>
</span><span id="L-22"><a href="#L-22"><span class="linenos"> 22</span></a><span class="sd">But we don&#39;t want to hold you back! The package provides a flexible framework to create your **own GEF flavor**, with all built-in tools at your disposable. </span>
</span><span id="L-23"><a href="#L-23"><span class="linenos"> 23</span></a><span class="sd">It is indeed a true GEF *factory* !</span>
</span><span id="L-24"><a href="#L-24"><span class="linenos"> 24</span></a>
</span><span id="L-25"><a href="#L-25"><span class="linenos"> 25</span></a><span class="sd">You can install this package using pip</span>
</span><span id="L-26"><a href="#L-26"><span class="linenos"> 26</span></a>
</span><span id="L-27"><a href="#L-27"><span class="linenos"> 27</span></a><span class="sd">```bash</span>
</span><span id="L-28"><a href="#L-28"><span class="linenos"> 28</span></a><span class="sd">pip install cosmo-geff</span>
</span><span id="L-29"><a href="#L-29"><span class="linenos"> 29</span></a><span class="sd">```</span>
</span><span id="L-30"><a href="#L-30"><span class="linenos"> 30</span></a>
</span><span id="L-31"><a href="#L-31"><span class="linenos"> 31</span></a><span class="sd">or using the `geff.yml` file found at the [GitHub repository](https://github.com/riroro13/GEFF) for this package,</span>
</span><span id="L-32"><a href="#L-32"><span class="linenos"> 32</span></a>
</span><span id="L-33"><a href="#L-33"><span class="linenos"> 33</span></a><span class="sd">```bash</span>
</span><span id="L-34"><a href="#L-34"><span class="linenos"> 34</span></a><span class="sd">conda env create -f geff.yml</span>
</span><span id="L-35"><a href="#L-35"><span class="linenos"> 35</span></a><span class="sd">``` </span>
</span><span id="L-36"><a href="#L-36"><span class="linenos"> 36</span></a>
</span><span id="L-37"><a href="#L-37"><span class="linenos"> 37</span></a><span class="sd">If you use this package in your work, please cite (...).</span>
</span><span id="L-38"><a href="#L-38"><span class="linenos"> 38</span></a>
</span><span id="L-39"><a href="#L-39"><span class="linenos"> 39</span></a><span class="sd">---</span>
</span><span id="L-40"><a href="#L-40"><span class="linenos"> 40</span></a>
</span><span id="L-41"><a href="#L-41"><span class="linenos"> 41</span></a><span class="sd"># The refreshing taste of GEF</span>
</span><span id="L-42"><a href="#L-42"><span class="linenos"> 42</span></a>
</span><span id="L-43"><a href="#L-43"><span class="linenos"> 43</span></a><span class="sd">The GEF is a numerical technique to determine the dynamics and backreaction of gauge-fields during inflation</span>
</span><span id="L-44"><a href="#L-44"><span class="linenos"> 44</span></a><span class="sd">by directly evolving the time-dependent quantum expectation values of the gauge field, </span>
</span><span id="L-45"><a href="#L-45"><span class="linenos"> 45</span></a><span class="sd">e.g., $\langle {\bf E}^2 \rangle$, $\langle {\bf B}^2 \rangle$, $\langle {\bf E} \cdot {\bf B} \rangle$ etc.</span>
</span><span id="L-46"><a href="#L-46"><span class="linenos"> 46</span></a><span class="sd">If this is the first time you encounter the GEF, here are some useful articles on the topic:</span>
</span><span id="L-47"><a href="#L-47"><span class="linenos"> 47</span></a><span class="sd">* [2109.01651](https://arxiv.org/abs/2109.01651)</span>
</span><span id="L-48"><a href="#L-48"><span class="linenos"> 48</span></a><span class="sd">* [2310.09186](https://arxiv.org/abs/2310.09186)</span>
</span><span id="L-49"><a href="#L-49"><span class="linenos"> 49</span></a><span class="sd">* [2408.16538](https://arxiv.org/abs/2408.16538)</span>
</span><span id="L-50"><a href="#L-50"><span class="linenos"> 50</span></a>
</span><span id="L-51"><a href="#L-51"><span class="linenos"> 51</span></a><span class="sd">The strategy behind the GEF is to take Maxwell&#39;s equations in an expanding spacetime,</span>
</span><span id="L-52"><a href="#L-52"><span class="linenos"> 52</span></a>
</span><span id="L-53"><a href="#L-53"><span class="linenos"> 53</span></a><span class="sd">&lt;a name=&quot;max&quot;&gt;$$\operatorname{div} {\bf E} = 0\, , \qquad \operatorname{div} {\bf B} = 0\, ,$$&lt;/a&gt;</span>
</span><span id="L-54"><a href="#L-54"><span class="linenos"> 54</span></a><span class="sd">$$\dot{{\bf E}} + 2 H {\bf E} - \frac{1}{a}\operatorname{rot} {\bf B} + {\bf J} = 0 \, ,$$</span>
</span><span id="L-55"><a href="#L-55"><span class="linenos"> 55</span></a><span class="sd">$$\dot{{\bf B}}  + 2 H {\bf B} + \frac{1}{a}\operatorname{rot} {\bf E} = 0 \,$$</span>
</span><span id="L-56"><a href="#L-56"><span class="linenos"> 56</span></a>
</span><span id="L-57"><a href="#L-57"><span class="linenos"> 57</span></a><span class="sd">and use them to formulate a tower of ODEs for the quantities</span>
</span><span id="L-58"><a href="#L-58"><span class="linenos"> 58</span></a>
</span><span id="L-59"><a href="#L-59"><span class="linenos"> 59</span></a><span class="sd">$$ \mathcal{F}_\mathcal{E}^{(n)} = \frac{a^4}{k_{{\rm UV}}^{n+4}}\langle {\bf E} \cdot \operatorname{rot}^n {\bf E}\rangle = \int\limits_{0}^{k_{{\rm UV}}(t)}\frac{{\rm d} k}{k} \frac{a^2 k^{n+3}}{2 \pi^2 k_{{\rm UV}}^{n+4}}  \sum_{\lambda}\lambda^n |\dot{A}_\lambda(t,k)|^2\, ,$$</span>
</span><span id="L-60"><a href="#L-60"><span class="linenos"> 60</span></a><span class="sd">$$ \mathcal{F}_\mathcal{G}^{(n)} = -\frac{a^4}{2 k_{{\rm UV}}^{n+4}}\langle {\bf E} \cdot \operatorname{rot}^n {\bf B} + {\bf B} \cdot \operatorname{rot}^n {\bf E}\rangle = \int\limits_{0}^{k_{{\rm UV}}(t)} \frac{{\rm d} k}{k} \frac{a k^{n+4}}{2 \pi^2 k_{{\rm UV}}^{n+4}}\sum_{\lambda}\lambda^{n+1} \operatorname{Re}[\dot{A}_\lambda(t,k)A_\lambda^*(t,k)] \, ,$$</span>
</span><span id="L-61"><a href="#L-61"><span class="linenos"> 61</span></a><span class="sd">$$ \mathcal{F}_\mathcal{B}^{(n)} = \frac{a^4}{k_{{\rm UV}}^{n+4}}\langle {\bf B} \cdot \operatorname{rot}^n {\bf B}\rangle = \int\limits_{0}^{k_{{\rm UV}}(t)}\frac{{\rm d} k}{k} \frac{k^{n+5}}{2 \pi^{2}k_{{\rm UV}}^{n+4}} \sum_{\lambda}\lambda^n |A_\lambda(t,k)|^2 \, ,$$</span>
</span><span id="L-62"><a href="#L-62"><span class="linenos"> 62</span></a>
</span><span id="L-63"><a href="#L-63"><span class="linenos"> 63</span></a><span class="sd">where, $k_{\rm UV}$ is a suitably chosen UV regulator which can vary with time. </span>
</span><span id="L-64"><a href="#L-64"><span class="linenos"> 64</span></a><span class="sd">For completeness, we have also given the expression for $\mathcal{F}_\mathcal{X}^{(n)}$ in terms of the mode functions $A_\lambda(t,k)$.</span>
</span><span id="L-65"><a href="#L-65"><span class="linenos"> 65</span></a>
</span><span id="L-66"><a href="#L-66"><span class="linenos"> 66</span></a><span class="sd">The ODE for the $\mathcal{F}_\mathcal{X}^{(n)}$&#39;s are then given by</span>
</span><span id="L-67"><a href="#L-67"><span class="linenos"> 67</span></a>
</span><span id="L-68"><a href="#L-68"><span class="linenos"> 68</span></a><span class="sd">$$\frac{\rm d}{{\rm d} t} \mathcal{F}_\mathcal{E}^{(n)} + (4+n)\frac{{\rm d} \ln k_{\rm UV}}{{\rm d} t} \mathcal{F}_\mathcal{E}^{(n)}  + 2\frac{k_{\rm UV}}{a}\mathcal{F}_\mathcal{G}^{(n+1)} + 2 \frac{a^4}{k_{\rm UV}^{n+4}} \langle {\bf J} \cdot \operatorname{rot}^n {\bf E} \rangle =  S_{\mathcal{E}}^{(n)}\, , $$</span>
</span><span id="L-69"><a href="#L-69"><span class="linenos"> 69</span></a><span class="sd">$$\frac{\rm d}{{\rm d} t} \mathcal{F}_\mathcal{G}^{(n)} + (4+n)\frac{{\rm d} \ln k_{\rm UV}}{{\rm d} t} \mathcal{F}_\mathcal{G}^{(n)} - \frac{k_{\rm UV}}{a}\left(\mathcal{F}_\mathcal{E}^{(n+1)} - \mathcal{F}_\mathcal{B}^{(n+1)}\right) - \frac{a^4}{k_{\rm UV}^{n+4}} \langle {\bf J} \cdot \operatorname{rot}^n {\bf B} \rangle= S_{\mathcal{G}}^{(n)}\, , $$</span>
</span><span id="L-70"><a href="#L-70"><span class="linenos"> 70</span></a><span class="sd">$$\frac{\rm d}{{\rm d} t} \mathcal{F}_\mathcal{B}^{(n)} + (4+n)\frac{{\rm d} \ln k_{\rm UV}}{{\rm d} t} \mathcal{F}_\mathcal{B}^{(n)} - 2\frac{k_{\rm UV}}{a}\mathcal{F}_\mathcal{G}^{(n+1)}  =  S_{\mathcal{B}}^{(n)}\, .$$</span>
</span><span id="L-71"><a href="#L-71"><span class="linenos"> 71</span></a>
</span><span id="L-72"><a href="#L-72"><span class="linenos"> 72</span></a><span class="sd">Although these are infinitely many coupled ODE&#39;s, one can typically determine an analytical closing condition, such that they may be truncated at some order $n_{\rm tr}$.</span>
</span><span id="L-73"><a href="#L-73"><span class="linenos"> 73</span></a>
</span><span id="L-74"><a href="#L-74"><span class="linenos"> 74</span></a><span class="sd">The ODEs for the $\mathcal{F}_\mathcal{X}^{(n)}$ can now be simply solved alongside those of the inflationary background.</span>
</span><span id="L-75"><a href="#L-75"><span class="linenos"> 75</span></a><span class="sd">This way, one can handle gauge-field backreaction onto the background dynamics of inflation.</span>
</span><span id="L-76"><a href="#L-76"><span class="linenos"> 76</span></a>
</span><span id="L-77"><a href="#L-77"><span class="linenos"> 77</span></a><span class="sd">The GEFF package is designed to help the user in the process of solving these equations in the following way</span>
</span><span id="L-78"><a href="#L-78"><span class="linenos"> 78</span></a><span class="sd"> - pre-defined and ready-to-use [GEF flavors](#basics)</span>
</span><span id="L-79"><a href="#L-79"><span class="linenos"> 79</span></a><span class="sd"> - tailored [algorithm](#algorithm) to solve the inflationary background dynamics</span>
</span><span id="L-80"><a href="#L-80"><span class="linenos"> 80</span></a><span class="sd"> - options to [implement your own GEF flavor](#model_creation)</span>
</span><span id="L-81"><a href="#L-81"><span class="linenos"> 81</span></a>
</span><span id="L-82"><a href="#L-82"><span class="linenos"> 82</span></a><span class="sd"> ---</span>
</span><span id="L-83"><a href="#L-83"><span class="linenos"> 83</span></a>
</span><span id="L-84"><a href="#L-84"><span class="linenos"> 84</span></a><span class="sd">&lt;a name=&quot;basics&quot;&gt;</span>
</span><span id="L-85"><a href="#L-85"><span class="linenos"> 85</span></a><span class="sd"># Sampling the GEF flavors</span>
</span><span id="L-86"><a href="#L-86"><span class="linenos"> 86</span></a>
</span><span id="L-87"><a href="#L-87"><span class="linenos"> 87</span></a><span class="sd">GEF models come in various flavors, some of the most intresting applications of the GEF are already implemented in this package.</span>
</span><span id="L-88"><a href="#L-88"><span class="linenos"> 88</span></a><span class="sd">As the first part of our tour, we explore the basic application of the GEFF code using these pre-defined models.</span>
</span><span id="L-89"><a href="#L-89"><span class="linenos"> 89</span></a>
</span><span id="L-90"><a href="#L-90"><span class="linenos"> 90</span></a><span class="sd">## Choosing your flavor</span>
</span><span id="L-91"><a href="#L-91"><span class="linenos"> 91</span></a>
</span><span id="L-92"><a href="#L-92"><span class="linenos"> 92</span></a><span class="sd">We start by sampling a first flavor of our choice; the model &quot;pai&quot;:</span>
</span><span id="L-93"><a href="#L-93"><span class="linenos"> 93</span></a>
</span><span id="L-94"><a href="#L-94"><span class="linenos"> 94</span></a><span class="sd">```python</span>
</span><span id="L-95"><a href="#L-95"><span class="linenos"> 95</span></a><span class="sd">from geff import compile_model</span>
</span><span id="L-96"><a href="#L-96"><span class="linenos"> 96</span></a>
</span><span id="L-97"><a href="#L-97"><span class="linenos"> 97</span></a><span class="sd"># Create the GEF model of our choice</span>
</span><span id="L-98"><a href="#L-98"><span class="linenos"> 98</span></a><span class="sd">paiGEF = compile_model(&quot;pai&quot;)</span>
</span><span id="L-99"><a href="#L-99"><span class="linenos"> 99</span></a><span class="sd">``` </span>
</span><span id="L-100"><a href="#L-100"><span class="linenos">100</span></a><span class="sd">The object `paiGEF` is the compiled version of the model found under `.models.pai`. It defines an ODE solver </span>
</span><span id="L-101"><a href="#L-101"><span class="linenos">101</span></a><span class="sd">which needs to be initialized with information on the setup we want to study:</span>
</span><span id="L-102"><a href="#L-102"><span class="linenos">102</span></a><span class="sd">The &quot;pai&quot; model expects information on the inflaton--vector coupling $\beta / M_{\rm P}$, </span>
</span><span id="L-103"><a href="#L-103"><span class="linenos">103</span></a><span class="sd">initial conditions for the inflaton field, $\varphi(0)$, $\dot\varphi(0)$, and the shape of the inflaton potential, $V(\varphi)$.</span>
</span><span id="L-104"><a href="#L-104"><span class="linenos">104</span></a>
</span><span id="L-105"><a href="#L-105"><span class="linenos">105</span></a><span class="sd">In this example, we configure the model to start on the slow-roll attractor of a chaotic inflation potential:</span>
</span><span id="L-106"><a href="#L-106"><span class="linenos">106</span></a>
</span><span id="L-107"><a href="#L-107"><span class="linenos">107</span></a><span class="sd">$$ \varphi(0) = 15.55 M_{\rm P}, \qquad \dot{\varphi}(0) = -\sqrt{\frac{2}{3}} m M_{\rm P}, \qquad V(\varphi) = \frac{1}{2}m^2 \varphi^2$$</span>
</span><span id="L-108"><a href="#L-108"><span class="linenos">108</span></a>
</span><span id="L-109"><a href="#L-109"><span class="linenos">109</span></a><span class="sd">where $m = 6.16 \times 10^{-6} M_{\rm P}$. We set the coupling to $\beta = 15$.</span>
</span><span id="L-110"><a href="#L-110"><span class="linenos">110</span></a>
</span><span id="L-111"><a href="#L-111"><span class="linenos">111</span></a><span class="sd">The necessary information is passed to `paiGEF` as keyword arguments:</span>
</span><span id="L-112"><a href="#L-112"><span class="linenos">112</span></a><span class="sd">```python</span>
</span><span id="L-113"><a href="#L-113"><span class="linenos">113</span></a><span class="sd">import numpy as np</span>
</span><span id="L-114"><a href="#L-114"><span class="linenos">114</span></a>
</span><span id="L-115"><a href="#L-115"><span class="linenos">115</span></a><span class="sd">m = 6.16e-6</span>
</span><span id="L-116"><a href="#L-116"><span class="linenos">116</span></a><span class="sd">beta = 15</span>
</span><span id="L-117"><a href="#L-117"><span class="linenos">117</span></a>
</span><span id="L-118"><a href="#L-118"><span class="linenos">118</span></a><span class="sd">phi = 15.55</span>
</span><span id="L-119"><a href="#L-119"><span class="linenos">119</span></a><span class="sd">dphi = -np.sqrt(2/3)*m</span>
</span><span id="L-120"><a href="#L-120"><span class="linenos">120</span></a>
</span><span id="L-121"><a href="#L-121"><span class="linenos">121</span></a><span class="sd">def V(x): return 0.5*m**2*x**2</span>
</span><span id="L-122"><a href="#L-122"><span class="linenos">122</span></a><span class="sd">def dV(x): return m**2*x</span>
</span><span id="L-123"><a href="#L-123"><span class="linenos">123</span></a>
</span><span id="L-124"><a href="#L-124"><span class="linenos">124</span></a><span class="sd">mod = paiGEF(beta=beta, phi=phi, dphi=dphi, V=V, dV=dV)</span>
</span><span id="L-125"><a href="#L-125"><span class="linenos">125</span></a><span class="sd">```</span>
</span><span id="L-126"><a href="#L-126"><span class="linenos">126</span></a><span class="sd">If you want to know what input is expected by the GEF model, use the `print_input` method of `paiGEF`.</span>
</span><span id="L-127"><a href="#L-127"><span class="linenos">127</span></a>
</span><span id="L-128"><a href="#L-128"><span class="linenos">128</span></a><span class="sd">&gt; **A note on units**:</span>
</span><span id="L-129"><a href="#L-129"><span class="linenos">129</span></a><span class="sd">&gt; The pre-defined GEF flavors in the GEFF package work in Planck units $M_{\rm P}=1$. </span>
</span><span id="L-130"><a href="#L-130"><span class="linenos">130</span></a><span class="sd">&gt; From the input, the GEF determines the Hubble rate at initialization, $H_0$, (also in Planck units).</span>
</span><span id="L-131"><a href="#L-131"><span class="linenos">131</span></a><span class="sd">&gt; Internally, the numerical routines work with dimensionless quantities, e.g., $\bar{X} = X H_0^{-a} M_{\rm P}^{-b}$ with $a$ and $b$ indicating</span>
</span><span id="L-132"><a href="#L-132"><span class="linenos">132</span></a><span class="sd">&gt; how $X$ scales with an inverse timescale (e.g., $H_0$) and an energy scale (e.g., $M_{\rm P}$).</span>
</span><span id="L-133"><a href="#L-133"><span class="linenos">133</span></a><span class="sd">&gt; For example, the dimensionless inflaton velocity would be like $\dot{\bar{\varphi}} = \dot{\varphi}/(H_0 M_{\rm P})$,</span>
</span><span id="L-134"><a href="#L-134"><span class="linenos">134</span></a><span class="sd">&gt; i.e., $\dot{\varphi}$ scales like an amplitude, $\varphi \sim M_{\rm P}$, and a derivative, $\partial_t \sim H_0$.</span>
</span><span id="L-135"><a href="#L-135"><span class="linenos">135</span></a><span class="sd">&gt; Don&#39;t worry, this is happening under the hood, but if you want more details, see `.bgtypes`.</span>
</span><span id="L-136"><a href="#L-136"><span class="linenos">136</span></a>
</span><span id="L-137"><a href="#L-137"><span class="linenos">137</span></a><span class="sd">## Getting a taste</span>
</span><span id="L-138"><a href="#L-138"><span class="linenos">138</span></a>
</span><span id="L-139"><a href="#L-139"><span class="linenos">139</span></a><span class="sd">Now, that our model is initialized, we can solve the inflationary background evolution from these initial conditions:</span>
</span><span id="L-140"><a href="#L-140"><span class="linenos">140</span></a><span class="sd">```python</span>
</span><span id="L-141"><a href="#L-141"><span class="linenos">141</span></a><span class="sd">sol, spec, info = mod.run()</span>
</span><span id="L-142"><a href="#L-142"><span class="linenos">142</span></a><span class="sd">```</span>
</span><span id="L-143"><a href="#L-143"><span class="linenos">143</span></a><span class="sd">The `run` method returned three objects. The evolution of the background dynamics is contained in `sol`,</span>
</span><span id="L-144"><a href="#L-144"><span class="linenos">144</span></a><span class="sd">the evolution on the gauge-field mode functions, $A_\lambda(t, k)$, are computed and returned as the</span>
</span><span id="L-145"><a href="#L-145"><span class="linenos">145</span></a><span class="sd">object `spec`, while `info` is just a byproduct that contains full information on the ODE solution in `sol`.</span>
</span><span id="L-146"><a href="#L-146"><span class="linenos">146</span></a><span class="sd">For basic applications, all information we actually want is in `sol` and `spec`.</span>
</span><span id="L-147"><a href="#L-147"><span class="linenos">147</span></a>
</span><span id="L-148"><a href="#L-148"><span class="linenos">148</span></a><span class="sd">Let us focus on `sol`. It is a `BGSystem` object which we can use to access the time evolution of several important inflationary quantities defined by our &quot;pai&quot; model.</span>
</span><span id="L-149"><a href="#L-149"><span class="linenos">149</span></a><span class="sd">For example, you can use it to make a basic plot showing the evolution of the energy densities during inflation as a function of $e$-folds</span>
</span><span id="L-150"><a href="#L-150"><span class="linenos">150</span></a>
</span><span id="L-151"><a href="#L-151"><span class="linenos">151</span></a><span class="sd">```python</span>
</span><span id="L-152"><a href="#L-152"><span class="linenos">152</span></a><span class="sd">import matplotlib.pyplot as plt</span>
</span><span id="L-153"><a href="#L-153"><span class="linenos">153</span></a>
</span><span id="L-154"><a href="#L-154"><span class="linenos">154</span></a><span class="sd"># Plot the evolution of the inflaton amplitude as a function of e-folds:</span>
</span><span id="L-155"><a href="#L-155"><span class="linenos">155</span></a><span class="sd">plt.plot(sol.N, sol.dphi**2/(6*sol.H**2)) # inflaton kinetic energy density</span>
</span><span id="L-156"><a href="#L-156"><span class="linenos">156</span></a><span class="sd">plt.plot(sol.N, (sol.E + sol.B)/(6*sol.H**2)) # electromagnetic energy density</span>
</span><span id="L-157"><a href="#L-157"><span class="linenos">157</span></a><span class="sd">plt.plot(sol.N, sol.V(sol.phi)/(3*sol.H**2)) # inflaton potential energy density</span>
</span><span id="L-158"><a href="#L-158"><span class="linenos">158</span></a>
</span><span id="L-159"><a href="#L-159"><span class="linenos">159</span></a><span class="sd">plt.yscale(&quot;log&quot;)</span>
</span><span id="L-160"><a href="#L-160"><span class="linenos">160</span></a><span class="sd">plt.ylim()</span>
</span><span id="L-161"><a href="#L-161"><span class="linenos">161</span></a>
</span><span id="L-162"><a href="#L-162"><span class="linenos">162</span></a><span class="sd">plt.show()</span>
</span><span id="L-163"><a href="#L-163"><span class="linenos">163</span></a><span class="sd">``` </span>
</span><span id="L-164"><a href="#L-164"><span class="linenos">164</span></a>
</span><span id="L-165"><a href="#L-165"><span class="linenos">165</span></a><span class="sd">How did we know that `sol` owns the attributes `N`,`phi`, etc.? You can find out using `sol.value_names()`.</span>
</span><span id="L-166"><a href="#L-166"><span class="linenos">166</span></a><span class="sd">To print a full description of all available variables for &quot;pai&quot;, you can use `paiGEF.print_ingredients()`. </span>
</span><span id="L-167"><a href="#L-167"><span class="linenos">167</span></a><span class="sd">Otherwise, this information can also be found at `.models.pai`. </span>
</span><span id="L-168"><a href="#L-168"><span class="linenos">168</span></a><span class="sd">If you need a brief description of any variable `X`, use `X.get_description()`.</span>
</span><span id="L-169"><a href="#L-169"><span class="linenos">169</span></a>
</span><span id="L-170"><a href="#L-170"><span class="linenos">170</span></a><span class="sd">&gt; **A note on variables:**</span>
</span><span id="L-171"><a href="#L-171"><span class="linenos">171</span></a><span class="sd">&gt; The variables encoded in a GEF model use a custom class called `Variable`. They work like a `numpy` array. </span>
</span><span id="L-172"><a href="#L-172"><span class="linenos">172</span></a><span class="sd">&gt; Additionally, constants are realized using the class `Constant`, and work like a `float`.</span>
</span><span id="L-173"><a href="#L-173"><span class="linenos">173</span></a><span class="sd">&gt; Dimensionful functions like the inflaton potential use the `Func` class, and can be used like a regular function.</span>
</span><span id="L-174"><a href="#L-174"><span class="linenos">174</span></a><span class="sd">&gt; These classes are defined to take care of unit conversions and are collectively attatched to a `BGSystem`. If you are curious, have a look at `.bgtypes`.</span>
</span><span id="L-175"><a href="#L-175"><span class="linenos">175</span></a>
</span><span id="L-176"><a href="#L-176"><span class="linenos">176</span></a><span class="sd">We did not only get back a `sol` object, but also `spec`. This object contains the gauge-field mode functions $A_\lambda(t,k)$.</span>
</span><span id="L-177"><a href="#L-177"><span class="linenos">177</span></a><span class="sd">The code computes these mode functions after having solved the dynamics of the background system ($H(t)$, $\varphi(t)$ etc.),</span>
</span><span id="L-178"><a href="#L-178"><span class="linenos">178</span></a><span class="sd">and uses them for estimating the convergence of the background solution. </span>
</span><span id="L-179"><a href="#L-179"><span class="linenos">179</span></a><span class="sd">We briefly discuss this algorithm in [the next section](#algorithm).</span>
</span><span id="L-180"><a href="#L-180"><span class="linenos">180</span></a>
</span><span id="L-181"><a href="#L-181"><span class="linenos">181</span></a><span class="sd">The object `spec` is an instance of the `GaugeSpec` class, which defines useful methods for handling time-dependent gauge-field spectra.</span>
</span><span id="L-182"><a href="#L-182"><span class="linenos">182</span></a><span class="sd">For details, see `.mbm.GaugeSpec`.</span>
</span><span id="L-183"><a href="#L-183"><span class="linenos">183</span></a>
</span><span id="L-184"><a href="#L-184"><span class="linenos">184</span></a><span class="sd">&gt; **A note on gauge-field spectra**</span>
</span><span id="L-185"><a href="#L-185"><span class="linenos">185</span></a><span class="sd">&gt; If you are only interested in the background evolution and not in the gauge-field spectrum, set `nmodes=None` in `run()`.</span>
</span><span id="L-186"><a href="#L-186"><span class="linenos">186</span></a><span class="sd">&gt; However, it is advised to compute gauge-field spectra to ensure consistency between the background evolution and the spectra.</span>
</span><span id="L-187"><a href="#L-187"><span class="linenos">187</span></a>
</span><span id="L-188"><a href="#L-188"><span class="linenos">188</span></a><span class="sd">Next, let us store our GEF and mode solutions in a file:</span>
</span><span id="L-189"><a href="#L-189"><span class="linenos">189</span></a><span class="sd">```python</span>
</span><span id="L-190"><a href="#L-190"><span class="linenos">190</span></a><span class="sd"># some dummy paths for illustration</span>
</span><span id="L-191"><a href="#L-191"><span class="linenos">191</span></a><span class="sd">gefpath = &quot;some_gef_file.dat&quot;</span>
</span><span id="L-192"><a href="#L-192"><span class="linenos">192</span></a><span class="sd">mbmpath = &quot;some_mbm_file.dat&quot;</span>
</span><span id="L-193"><a href="#L-193"><span class="linenos">193</span></a>
</span><span id="L-194"><a href="#L-194"><span class="linenos">194</span></a><span class="sd">sol.save_variables(gefpath)</span>
</span><span id="L-195"><a href="#L-195"><span class="linenos">195</span></a><span class="sd">spec.save_spec(mbmpath)</span>
</span><span id="L-196"><a href="#L-196"><span class="linenos">196</span></a><span class="sd">```</span>
</span><span id="L-197"><a href="#L-197"><span class="linenos">197</span></a>
</span><span id="L-198"><a href="#L-198"><span class="linenos">198</span></a><span class="sd">The data can be restored from these files using</span>
</span><span id="L-199"><a href="#L-199"><span class="linenos">199</span></a><span class="sd">```python</span>
</span><span id="L-200"><a href="#L-200"><span class="linenos">200</span></a><span class="sd">from geff import GaugeSpec</span>
</span><span id="L-201"><a href="#L-201"><span class="linenos">201</span></a>
</span><span id="L-202"><a href="#L-202"><span class="linenos">202</span></a><span class="sd">sol = mod.load_GEFdata(gefpath)</span>
</span><span id="L-203"><a href="#L-203"><span class="linenos">203</span></a><span class="sd">spec = GaugeSpec.read_spec(mbmpath)</span>
</span><span id="L-204"><a href="#L-204"><span class="linenos">204</span></a><span class="sd">```</span>
</span><span id="L-205"><a href="#L-205"><span class="linenos">205</span></a>
</span><span id="L-206"><a href="#L-206"><span class="linenos">206</span></a><span class="sd">&gt; **A note on storage:**</span>
</span><span id="L-207"><a href="#L-207"><span class="linenos">207</span></a><span class="sd">&gt; The `save_variables` method does not store information on constants or functions. So, to retrieve</span>
</span><span id="L-208"><a href="#L-208"><span class="linenos">208</span></a><span class="sd">&gt; the full information on our GEF run, we need to use an appropriately configured instance of</span>
</span><span id="L-209"><a href="#L-209"><span class="linenos">209</span></a><span class="sd">&gt; `paiGEF`. In the example above, this is achieved by reusing `mod`.</span>
</span><span id="L-210"><a href="#L-210"><span class="linenos">210</span></a>
</span><span id="L-211"><a href="#L-211"><span class="linenos">211</span></a><span class="sd">## A rich palette</span>
</span><span id="L-212"><a href="#L-212"><span class="linenos">212</span></a>
</span><span id="L-213"><a href="#L-213"><span class="linenos">213</span></a><span class="sd">Obtaining the inflationary dynamics is nice, but it is not all the GEFF can do. For example, let&#39;s use our results to compute the corresponding gravitational-wave spectrum:</span>
</span><span id="L-214"><a href="#L-214"><span class="linenos">214</span></a><span class="sd">```python</span>
</span><span id="L-215"><a href="#L-215"><span class="linenos">215</span></a><span class="sd">from geff.tools import PowSpecT, omega_gw</span>
</span><span id="L-216"><a href="#L-216"><span class="linenos">216</span></a>
</span><span id="L-217"><a href="#L-217"><span class="linenos">217</span></a><span class="sd"># Use sol to initialize the PowSpecT class</span>
</span><span id="L-218"><a href="#L-218"><span class="linenos">218</span></a><span class="sd">pt_fai = PowSpecT(sol)</span>
</span><span id="L-219"><a href="#L-219"><span class="linenos">219</span></a>
</span><span id="L-220"><a href="#L-220"><span class="linenos">220</span></a><span class="sd"># Compute the vacuum and induced power spectrum for 100 momentum modes k using spec:</span>
</span><span id="L-221"><a href="#L-221"><span class="linenos">221</span></a><span class="sd">ks, pt_spec = pt_fai.compute_pt(100, spec)</span>
</span><span id="L-222"><a href="#L-222"><span class="linenos">222</span></a>
</span><span id="L-223"><a href="#L-223"><span class="linenos">223</span></a><span class="sd"># from the power spectrum, we can then deduce the gravitational-wave spectrum:</span>
</span><span id="L-224"><a href="#L-224"><span class="linenos">224</span></a><span class="sd">f, gwspec = omega_gw(ks, pt_spec[&quot;tot&quot;], Nend=sol.N[-1], Hend=sol.H[-1])</span>
</span><span id="L-225"><a href="#L-225"><span class="linenos">225</span></a><span class="sd">``` </span>
</span><span id="L-226"><a href="#L-226"><span class="linenos">226</span></a><span class="sd">We can just use  `sol` to extract the relevant information on the background solution.</span>
</span><span id="L-227"><a href="#L-227"><span class="linenos">227</span></a><span class="sd">It&#39;s that easy!</span>
</span><span id="L-228"><a href="#L-228"><span class="linenos">228</span></a>
</span><span id="L-229"><a href="#L-229"><span class="linenos">229</span></a><span class="sd">To finish this first part of our tour, let us sample a second GEF flavor, &quot;fai_kh&quot;:</span>
</span><span id="L-230"><a href="#L-230"><span class="linenos">230</span></a><span class="sd">```python</span>
</span><span id="L-231"><a href="#L-231"><span class="linenos">231</span></a><span class="sd"># initialize the model</span>
</span><span id="L-232"><a href="#L-232"><span class="linenos">232</span></a><span class="sd">faiGEF = GEFModel(&quot;fai_kh&quot;, {&quot;picture&quot;:&quot;electric&quot;})</span>
</span><span id="L-233"><a href="#L-233"><span class="linenos">233</span></a>
</span><span id="L-234"><a href="#L-234"><span class="linenos">234</span></a><span class="sd"># chose initial conditions</span>
</span><span id="L-235"><a href="#L-235"><span class="linenos">235</span></a><span class="sd">mod = faiGEF(beta=...)</span>
</span><span id="L-236"><a href="#L-236"><span class="linenos">236</span></a>
</span><span id="L-237"><a href="#L-237"><span class="linenos">237</span></a><span class="sd"># solve the ODEs as before</span>
</span><span id="L-238"><a href="#L-238"><span class="linenos">238</span></a><span class="sd">sol, spec, info = mod.run(...)</span>
</span><span id="L-239"><a href="#L-239"><span class="linenos">239</span></a>
</span><span id="L-240"><a href="#L-240"><span class="linenos">240</span></a><span class="sd">...</span>
</span><span id="L-241"><a href="#L-241"><span class="linenos">241</span></a><span class="sd">...</span>
</span><span id="L-242"><a href="#L-242"><span class="linenos">242</span></a><span class="sd">```</span>
</span><span id="L-243"><a href="#L-243"><span class="linenos">243</span></a><span class="sd">This model comes in three varieties (&quot;pictures&quot;) corresponding to the effective treatment of fermions in the model.</span>
</span><span id="L-244"><a href="#L-244"><span class="linenos">244</span></a><span class="sd">We specified the particular variety py passing a `settings` dictionary upon creating the model.</span>
</span><span id="L-245"><a href="#L-245"><span class="linenos">245</span></a>
</span><span id="L-246"><a href="#L-246"><span class="linenos">246</span></a><span class="sd">For more details on the available models, see `geff.models`.</span>
</span><span id="L-247"><a href="#L-247"><span class="linenos">247</span></a>
</span><span id="L-248"><a href="#L-248"><span class="linenos">248</span></a><span class="sd">&lt;a name=&quot;algorithm&quot;&gt;</span>
</span><span id="L-249"><a href="#L-249"><span class="linenos">249</span></a><span class="sd"># On the factory floor</span>
</span><span id="L-250"><a href="#L-250"><span class="linenos">250</span></a>
</span><span id="L-251"><a href="#L-251"><span class="linenos">251</span></a><span class="sd">Next on the tour of the GEF factory, we visit the production line.</span>
</span><span id="L-252"><a href="#L-252"><span class="linenos">252</span></a><span class="sd">The following diagram sketches the basic algorithm behind the `run` method.</span>
</span><span id="L-253"><a href="#L-253"><span class="linenos">253</span></a>
</span><span id="L-254"><a href="#L-254"><span class="linenos">254</span></a><span class="sd">```mermaid</span>
</span><span id="L-255"><a href="#L-255"><span class="linenos">255</span></a><span class="sd">---</span>
</span><span id="L-256"><a href="#L-256"><span class="linenos">256</span></a><span class="sd">config:</span>
</span><span id="L-257"><a href="#L-257"><span class="linenos">257</span></a><span class="sd">    flowchart:</span>
</span><span id="L-258"><a href="#L-258"><span class="linenos">258</span></a><span class="sd">        defaultRenderer: &quot;elk&quot;</span>
</span><span id="L-259"><a href="#L-259"><span class="linenos">259</span></a><span class="sd">    theme: &#39;base&#39;</span>
</span><span id="L-260"><a href="#L-260"><span class="linenos">260</span></a><span class="sd">    themeVariables:</span>
</span><span id="L-261"><a href="#L-261"><span class="linenos">261</span></a><span class="sd">        secondaryColor: &#39;#CFCFC6&#39;</span>
</span><span id="L-262"><a href="#L-262"><span class="linenos">262</span></a><span class="sd">        tertiaryColor: &#39;#FAFAFA&#39;</span>
</span><span id="L-263"><a href="#L-263"><span class="linenos">263</span></a><span class="sd">---</span>
</span><span id="L-264"><a href="#L-264"><span class="linenos">264</span></a><span class="sd">graph TB</span>
</span><span id="L-265"><a href="#L-265"><span class="linenos">265</span></a><span class="sd">    subgraph A[&quot;`**GEFModel**`&quot;]</span>
</span><span id="L-266"><a href="#L-266"><span class="linenos">266</span></a><span class="sd">        direction TB</span>
</span><span id="L-267"><a href="#L-267"><span class="linenos">267</span></a><span class="sd">        St((initial data &lt;br&gt;from model))--&gt; GS</span>
</span><span id="L-268"><a href="#L-268"><span class="linenos">268</span></a><span class="sd">        subgraph GS[&quot;`**GEFSolver**`&quot;]</span>
</span><span id="L-269"><a href="#L-269"><span class="linenos">269</span></a><span class="sd">            direction LR</span>
</span><span id="L-270"><a href="#L-270"><span class="linenos">270</span></a><span class="sd">            GS1[/initial data/] --&gt; GS2[solve background ODEs] --&gt; GS3[/background &lt;br&gt; dynamics/]</span>
</span><span id="L-271"><a href="#L-271"><span class="linenos">271</span></a><span class="sd">        end</span>
</span><span id="L-272"><a href="#L-272"><span class="linenos">272</span></a><span class="sd">        GS -.-&gt; MbM</span>
</span><span id="L-273"><a href="#L-273"><span class="linenos">273</span></a><span class="sd">        subgraph MbM[&quot;`**ModeSolver**`&quot;]</span>
</span><span id="L-274"><a href="#L-274"><span class="linenos">274</span></a><span class="sd">            direction LR</span>
</span><span id="L-275"><a href="#L-275"><span class="linenos">275</span></a><span class="sd">            MbM1[/background &lt;br&gt; dynamics/] --&gt; MbM2[compute &lt;br&gt;mode functions] --&gt; MbM3[/spectrum/]</span>
</span><span id="L-276"><a href="#L-276"><span class="linenos">276</span></a><span class="sd">        end</span>
</span><span id="L-277"><a href="#L-277"><span class="linenos">277</span></a><span class="sd">        MbM -.-&gt; A2[compare &lt;br&gt;background dynamics &lt;br&gt;&amp; spectrum]</span>
</span><span id="L-278"><a href="#L-278"><span class="linenos">278</span></a><span class="sd">        C[self-correction &lt;br&gt; using spectrum]</span>
</span><span id="L-279"><a href="#L-279"><span class="linenos">279</span></a><span class="sd">        GS --&gt; A2</span>
</span><span id="L-280"><a href="#L-280"><span class="linenos">280</span></a><span class="sd">        A2 -.-&gt; |disagreement| C -.-&gt;  GS</span>
</span><span id="L-281"><a href="#L-281"><span class="linenos">281</span></a><span class="sd">    A2 --&gt; |agreement|Fin[finalize] --&gt; R1((background &lt;br&gt; dynamics))</span>
</span><span id="L-282"><a href="#L-282"><span class="linenos">282</span></a><span class="sd">    Fin -.-&gt; R2((spectrum))</span>
</span><span id="L-283"><a href="#L-283"><span class="linenos">283</span></a><span class="sd">    end</span>
</span><span id="L-284"><a href="#L-284"><span class="linenos">284</span></a><span class="sd">```</span>
</span><span id="L-285"><a href="#L-285"><span class="linenos">285</span></a>
</span><span id="L-286"><a href="#L-286"><span class="linenos">286</span></a><span class="sd">As we have seen in the [first section](#basics), the `run` method is executed as part of a GEF Model.</span>
</span><span id="L-287"><a href="#L-287"><span class="linenos">287</span></a><span class="sd">Each GEF Model consists of two components, the `GEFSolver` and the `ModeSolver`. The former determines the time-dependent inflationary background, </span>
</span><span id="L-288"><a href="#L-288"><span class="linenos">288</span></a><span class="sd">the latter computes the mode functions $A_\lambda(t,k)$.</span>
</span><span id="L-289"><a href="#L-289"><span class="linenos">289</span></a><span class="sd">The two results can then be compared to eachother to assess the convergence of the background dynamics.</span>
</span><span id="L-290"><a href="#L-290"><span class="linenos">290</span></a><span class="sd">If the two disagree, the GEF will attempt to self-correct using $A_\lambda(t,k)$.</span>
</span><span id="L-291"><a href="#L-291"><span class="linenos">291</span></a>
</span><span id="L-292"><a href="#L-292"><span class="linenos">292</span></a><span class="sd">Note that, if you use `run(nmodes=None)`, the dotted lines in the diagram can be ignored; the background solution is immediately returned without</span>
</span><span id="L-293"><a href="#L-293"><span class="linenos">293</span></a><span class="sd">computing the gauge-field spectrum.</span>
</span><span id="L-294"><a href="#L-294"><span class="linenos">294</span></a>
</span><span id="L-295"><a href="#L-295"><span class="linenos">295</span></a><span class="sd">For more details on the `GEFSolver`, see `geff.solver`, while for the `ModeSolver` see `geff.mbm`.</span>
</span><span id="L-296"><a href="#L-296"><span class="linenos">296</span></a>
</span><span id="L-297"><a href="#L-297"><span class="linenos">297</span></a><span class="sd">---</span>
</span><span id="L-298"><a href="#L-298"><span class="linenos">298</span></a>
</span><span id="L-299"><a href="#L-299"><span class="linenos">299</span></a><span class="sd">&lt;a name=&quot;model_creation&quot;&gt;</span>
</span><span id="L-300"><a href="#L-300"><span class="linenos">300</span></a><span class="sd"># Create your own flavor</span>
</span><span id="L-301"><a href="#L-301"><span class="linenos">301</span></a>
</span><span id="L-302"><a href="#L-302"><span class="linenos">302</span></a><span class="sd">Having explored the potential of the GEFF code, you may be inclined to create your own GEF flavor.</span>
</span><span id="L-303"><a href="#L-303"><span class="linenos">303</span></a><span class="sd">To help you in this process, we show how to implement an example toy model.</span>
</span><span id="L-304"><a href="#L-304"><span class="linenos">304</span></a>
</span><span id="L-305"><a href="#L-305"><span class="linenos">305</span></a><span class="sd">&gt; **Warning**: Before jumping into this section, we advise that you first familiarize yourself with the GEF method.</span>
</span><span id="L-306"><a href="#L-306"><span class="linenos">306</span></a><span class="sd">&gt; Also, this tutorial works best, if you have a basic knowledge of the classes defined in `.bgtypes`.</span>
</span><span id="L-307"><a href="#L-307"><span class="linenos">307</span></a>
</span><span id="L-308"><a href="#L-308"><span class="linenos">308</span></a><span class="sd">## The first step is the hardest</span>
</span><span id="L-309"><a href="#L-309"><span class="linenos">309</span></a>
</span><span id="L-310"><a href="#L-310"><span class="linenos">310</span></a><span class="sd">First, we need to work out the mathematical formulation of our model.</span>
</span><span id="L-311"><a href="#L-311"><span class="linenos">311</span></a>
</span><span id="L-312"><a href="#L-312"><span class="linenos">312</span></a><span class="sd">Let us consider the case of Abelian gauge-field production in de Sitter space ($H={\rm const.}$) by a current of the type ${\bf J} = 2 H \xi {\bf B}$, </span>
</span><span id="L-313"><a href="#L-313"><span class="linenos">313</span></a><span class="sd">where $\xi$ is a constant, which we refer to as instability parameter.The ODE tower for the gauge-field bilinears are then given by:</span>
</span><span id="L-314"><a href="#L-314"><span class="linenos">314</span></a>
</span><span id="L-315"><a href="#L-315"><span class="linenos">315</span></a><span class="sd">$$\frac{\rm d}{{\rm d} t} \mathcal{F}_\mathcal{E}^{(n)} + (4+n)\frac{{\rm d} \ln k_\mathrm{h}}{{\rm d} t} \mathcal{F}_\mathcal{E}^{(n)}  + 2\frac{k_\mathrm{h}}{a}\mathcal{F}_\mathcal{G}^{(n+1)} - 4 H \xi \mathcal{F}_\mathcal{G}^{(n)}=  S_{\mathcal{E}}^{(n)}\, , $$</span>
</span><span id="L-316"><a href="#L-316"><span class="linenos">316</span></a><span class="sd">$$\frac{{\rm d}}{{\rm d} t} \mathcal{F}_\mathcal{G}^{(n)} + (4+n)\frac{{\rm d} \ln k_\mathrm{h}}{{\rm d} t} \mathcal{F}_\mathcal{G}^{(n)} - \frac{k_\mathrm{h}}{a}\left(\mathcal{F}_\mathcal{E}^{(n+1)} - \mathcal{F}_\mathcal{B}^{(n+1)}\right) - 2 H \xi \mathcal{F}_\mathcal{B}^{(n)}= S_{\mathcal{G}}^{(n)}\, , $$</span>
</span><span id="L-317"><a href="#L-317"><span class="linenos">317</span></a><span class="sd">$$\frac{{\rm d}}{{\rm d} t} \mathcal{F}_\mathcal{B}^{(n)} + (4+n)\frac{{\rm d} \ln k_\mathrm{h}}{{\rm d} t} \mathcal{F}_\mathcal{B}^{(n)} - 2\frac{k_\mathrm{h}}{a}\mathcal{F}_\mathcal{G}^{(n+1)}  =  S_{\mathcal{B}}^{(n)}\, .$$</span>
</span><span id="L-318"><a href="#L-318"><span class="linenos">318</span></a>
</span><span id="L-319"><a href="#L-319"><span class="linenos">319</span></a><span class="sd">One can determine that a sensible regularization scale for this model is given by $k_{\rm h}(t) = 2aH\xi$. </span>
</span><span id="L-320"><a href="#L-320"><span class="linenos">320</span></a>
</span><span id="L-321"><a href="#L-321"><span class="linenos">321</span></a><span class="sd">The boundary terms $S_\mathcal{X}^{(n)}$ are a consequence of the time dependence of $k_{\rm h}$. They are expressed in terms of Whittaker functions,</span>
</span><span id="L-322"><a href="#L-322"><span class="linenos">322</span></a><span class="sd">but the GEFF has a module that takes care of them. We will see this later.</span>
</span><span id="L-323"><a href="#L-323"><span class="linenos">323</span></a>
</span><span id="L-324"><a href="#L-324"><span class="linenos">324</span></a><span class="sd">Once we have worked out the equations, we can turn to writing a new model file.</span>
</span><span id="L-325"><a href="#L-325"><span class="linenos">325</span></a>
</span><span id="L-326"><a href="#L-326"><span class="linenos">326</span></a><span class="sd">## Only the best ingredients</span>
</span><span id="L-327"><a href="#L-327"><span class="linenos">327</span></a>
</span><span id="L-328"><a href="#L-328"><span class="linenos">328</span></a><span class="sd">The first thing we should state in our model file is the name of the new GEF flavor:</span>
</span><span id="L-329"><a href="#L-329"><span class="linenos">329</span></a><span class="sd">```python</span>
</span><span id="L-330"><a href="#L-330"><span class="linenos">330</span></a><span class="sd">import numpy as np</span>
</span><span id="L-331"><a href="#L-331"><span class="linenos">331</span></a>
</span><span id="L-332"><a href="#L-332"><span class="linenos">332</span></a><span class="sd">name = &quot;tutorial&quot;</span>
</span><span id="L-333"><a href="#L-333"><span class="linenos">333</span></a><span class="sd">```</span>
</span><span id="L-334"><a href="#L-334"><span class="linenos">334</span></a><span class="sd">&gt; **A note on settings**: Following the model&#39;s name, you can also define a `settings` dictionary.</span>
</span><span id="L-335"><a href="#L-335"><span class="linenos">335</span></a><span class="sd">&gt; This dictionary should contain some key&amp;ndash;value pair defining its name and the default setting.</span>
</span><span id="L-336"><a href="#L-336"><span class="linenos">336</span></a><span class="sd">&gt; The `settings` should be accompanied by a function called `interpret_settings`. This method will be called on model creation,</span>
</span><span id="L-337"><a href="#L-337"><span class="linenos">337</span></a><span class="sd">&gt; so you can use it to define how user input settings are handled. See, e.g., `.models.SE_kh` for how this is done in practice.</span>
</span><span id="L-338"><a href="#L-338"><span class="linenos">338</span></a>
</span><span id="L-339"><a href="#L-339"><span class="linenos">339</span></a><span class="sd">Next, we need to define define and categorize the variables which appear in our model. This is taken care of by the functions `define_var`, `define_const`,  and `define_func`.</span>
</span><span id="L-340"><a href="#L-340"><span class="linenos">340</span></a><span class="sd">The `.bgtypes` module also contains some pre-defined variables, which are often encountered in GEF models.</span>
</span><span id="L-341"><a href="#L-341"><span class="linenos">341</span></a>
</span><span id="L-342"><a href="#L-342"><span class="linenos">342</span></a><span class="sd">There are three variables which every GEF model needs to define:</span>
</span><span id="L-343"><a href="#L-343"><span class="linenos">343</span></a><span class="sd">* $t$ - *cosmic time* : all ODE&#39;s are solved in terms of $t$ starting from $t=0$.</span>
</span><span id="L-344"><a href="#L-344"><span class="linenos">344</span></a><span class="sd">* $N$ - *$e$-folds* : needed by most internal methods. It should be defined such that $N(t=0)=0$.</span>
</span><span id="L-345"><a href="#L-345"><span class="linenos">345</span></a><span class="sd">* $H$ - *Hubble rate* : needed by most internal methods.</span>
</span><span id="L-346"><a href="#L-346"><span class="linenos">346</span></a>
</span><span id="L-347"><a href="#L-347"><span class="linenos">347</span></a><span class="sd">Beyond these staples, some extra variables appear in our ODE&#39;s:</span>
</span><span id="L-348"><a href="#L-348"><span class="linenos">348</span></a><span class="sd">* $\mathcal{F}_\mathcal{X}^{(n)}$ - *the gauge-field bilinears*</span>
</span><span id="L-349"><a href="#L-349"><span class="linenos">349</span></a><span class="sd">* $k_{\rm h}$ - *the UV regulator*</span>
</span><span id="L-350"><a href="#L-350"><span class="linenos">350</span></a><span class="sd">* $\xi$ -  *the instability parameter*</span>
</span><span id="L-351"><a href="#L-351"><span class="linenos">351</span></a>
</span><span id="L-352"><a href="#L-352"><span class="linenos">352</span></a><span class="sd">To properly account for the gauge field, we also need to add in the following three variables:</span>
</span><span id="L-353"><a href="#L-353"><span class="linenos">353</span></a><span class="sd">* $\mathcal{E}^{(0)} = \langle {\bf E}^2 \rangle$ - *called `E` by the GEF*</span>
</span><span id="L-354"><a href="#L-354"><span class="linenos">354</span></a><span class="sd">* $\mathcal{B}^{(0)} = \langle {\bf B}^2 \rangle$ - *called `B` by the GEF*</span>
</span><span id="L-355"><a href="#L-355"><span class="linenos">355</span></a><span class="sd">* $\mathcal{G}^{(0)} = -\langle {\bf E} \cdot {\bf B} \rangle$ - *called `G` by the GEF*</span>
</span><span id="L-356"><a href="#L-356"><span class="linenos">356</span></a>
</span><span id="L-357"><a href="#L-357"><span class="linenos">357</span></a><span class="sd">&gt; **Note on gauge field bilinears** The time evolution of the variables $\mathcal{F}_\mathcal{X}^{(n)}$ will not be saved by the GEFF code,</span>
</span><span id="L-358"><a href="#L-358"><span class="linenos">358</span></a><span class="sd">&gt; since we are typically only interest in the quantities with $n=0$. The output `info` returned by the `run` method contains the full information on $\mathcal{F}_\mathcal{X}^{(n)}$,</span>
</span><span id="L-359"><a href="#L-359"><span class="linenos">359</span></a><span class="sd">&gt; but only the information on $n=0$ is passed to `sol` in the form of  `E`, `B` and `G`.</span>
</span><span id="L-360"><a href="#L-360"><span class="linenos">360</span></a>
</span><span id="L-361"><a href="#L-361"><span class="linenos">361</span></a><span class="sd">All these variables need to be defined in our model file. This is done as follows:</span>
</span><span id="L-362"><a href="#L-362"><span class="linenos">362</span></a><span class="sd">```python</span>
</span><span id="L-363"><a href="#L-363"><span class="linenos">363</span></a><span class="sd">from geff.bgtypes import define_const</span>
</span><span id="L-364"><a href="#L-364"><span class="linenos">364</span></a>
</span><span id="L-365"><a href="#L-365"><span class="linenos">365</span></a><span class="sd"># We make use of the fact that a lot of these variables are pre-defined:</span>
</span><span id="L-366"><a href="#L-366"><span class="linenos">366</span></a><span class="sd">from geff.bgtypes import t, N, a, E, B, G, kh, GF</span>
</span><span id="L-367"><a href="#L-367"><span class="linenos">367</span></a>
</span><span id="L-368"><a href="#L-368"><span class="linenos">368</span></a><span class="sd"># We also need to define some new objects:</span>
</span><span id="L-369"><a href="#L-369"><span class="linenos">369</span></a><span class="sd">H = define_const(&quot;H&quot;, qu_omega=1, qu_mu=0) # Hubble rate (scales like inverse time)</span>
</span><span id="L-370"><a href="#L-370"><span class="linenos">370</span></a><span class="sd">xi = define_const(&quot;xi&quot;, qu_omega=0, qu_mu=0) # instability parameter</span>
</span><span id="L-371"><a href="#L-371"><span class="linenos">371</span></a><span class="sd">```</span>
</span><span id="L-372"><a href="#L-372"><span class="linenos">372</span></a><span class="sd">We use `define_const` to define the constants for our model: $H$ and $\xi$.</span>
</span><span id="L-373"><a href="#L-373"><span class="linenos">373</span></a><span class="sd">The Hubble rate has mass dimension one, and scales with an inverse time-scale $\omega$ as, $H = \bar{H} \omega$.</span>
</span><span id="L-374"><a href="#L-374"><span class="linenos">374</span></a><span class="sd">It does not scale like an amplitude $\mu$. Hence, `qu_omega=1` and `qu_mu=0`.</span>
</span><span id="L-375"><a href="#L-375"><span class="linenos">375</span></a><span class="sd">Similarly, $\xi$ is just a number, and we set `qu_omega=0` and `qu_mu=0`.</span>
</span><span id="L-376"><a href="#L-376"><span class="linenos">376</span></a><span class="sd">This information needs to be passed to properly allow for unit conversions in the code.</span>
</span><span id="L-377"><a href="#L-377"><span class="linenos">377</span></a><span class="sd">More information on units and scaling is given in `.bgtypes`.</span>
</span><span id="L-378"><a href="#L-378"><span class="linenos">378</span></a>
</span><span id="L-379"><a href="#L-379"><span class="linenos">379</span></a><span class="sd">All the variables we have defined serve a specific purpose in our GEF model. To inform the GEFF of this, we need to classify each of them in one of these categories:</span>
</span><span id="L-380"><a href="#L-380"><span class="linenos">380</span></a><span class="sd">* **time**: a time variable (needs to be `t`)</span>
</span><span id="L-381"><a href="#L-381"><span class="linenos">381</span></a><span class="sd">* **dynamical**: variables whose time-evolution is determined from a differential equation.</span>
</span><span id="L-382"><a href="#L-382"><span class="linenos">382</span></a><span class="sd">* **gauge**: the gauge-field variable `GF` representing $\mathcal{F}_\mathcal{X}^{(n)}$.</span>
</span><span id="L-383"><a href="#L-383"><span class="linenos">383</span></a><span class="sd">* **static**: variables whose time-evolution is computed from other variables.</span>
</span><span id="L-384"><a href="#L-384"><span class="linenos">384</span></a><span class="sd">* **constant**: constants of time.</span>
</span><span id="L-385"><a href="#L-385"><span class="linenos">385</span></a><span class="sd">* **function**: functions of the above.</span>
</span><span id="L-386"><a href="#L-386"><span class="linenos">386</span></a>
</span><span id="L-387"><a href="#L-387"><span class="linenos">387</span></a><span class="sd">In our case, this would look as follows:</span>
</span><span id="L-388"><a href="#L-388"><span class="linenos">388</span></a><span class="sd">```python</span>
</span><span id="L-389"><a href="#L-389"><span class="linenos">389</span></a><span class="sd">quantities = {</span>
</span><span id="L-390"><a href="#L-390"><span class="linenos">390</span></a><span class="sd">            &quot;time&quot;:[t], # this is mandatory!</span>
</span><span id="L-391"><a href="#L-391"><span class="linenos">391</span></a><span class="sd">            &quot;dynamical&quot;:[kh], # kh is best evolved from an ODE</span>
</span><span id="L-392"><a href="#L-392"><span class="linenos">392</span></a><span class="sd">            &quot;gauge&quot;:[GF], # state the obvious</span>
</span><span id="L-393"><a href="#L-393"><span class="linenos">393</span></a><span class="sd">            &quot;static&quot;:[N, a, E, B, G], # directly computed from other variables</span>
</span><span id="L-394"><a href="#L-394"><span class="linenos">394</span></a><span class="sd">            &quot;constant&quot;:[H, xi], # we assume de-Sitter space, and xi is a constant</span>
</span><span id="L-395"><a href="#L-395"><span class="linenos">395</span></a><span class="sd">            &quot;function&quot;:[]  # our model does not need any functions</span>
</span><span id="L-396"><a href="#L-396"><span class="linenos">396</span></a><span class="sd">            }</span>
</span><span id="L-397"><a href="#L-397"><span class="linenos">397</span></a><span class="sd">```</span>
</span><span id="L-398"><a href="#L-398"><span class="linenos">398</span></a>
</span><span id="L-399"><a href="#L-399"><span class="linenos">399</span></a><span class="sd">## Write a recipe</span>
</span><span id="L-400"><a href="#L-400"><span class="linenos">400</span></a>
</span><span id="L-401"><a href="#L-401"><span class="linenos">401</span></a><span class="sd">With the variables defined, an important step towards our GEF model is already taken. </span>
</span><span id="L-402"><a href="#L-402"><span class="linenos">402</span></a><span class="sd">Next, let us set up the `GEFSolver`. (For more details, see `.solver.GEFSolver`.)</span>
</span><span id="L-403"><a href="#L-403"><span class="linenos">403</span></a>
</span><span id="L-404"><a href="#L-404"><span class="linenos">404</span></a><span class="sd">Internally, the GEFF package uses `scipy.integrate.solve_ivp` to solve differential equations. </span>
</span><span id="L-405"><a href="#L-405"><span class="linenos">405</span></a><span class="sd">This requires that ODE&#39;s are formulated as $\dot{\vec{y}} = f(t, \vec{y})$ with $\vec{y}$ as a `numpy` array.</span>
</span><span id="L-406"><a href="#L-406"><span class="linenos">406</span></a><span class="sd">However, the GEFF prefers the `BGSystem` class, which takes care of unit conversions.</span>
</span><span id="L-407"><a href="#L-407"><span class="linenos">407</span></a><span class="sd">So, we need to define how to translate between the two.</span>
</span><span id="L-408"><a href="#L-408"><span class="linenos">408</span></a>
</span><span id="L-409"><a href="#L-409"><span class="linenos">409</span></a><span class="sd">First up, we define how to interpret user input to initialize the array $\vec{y}$:</span>
</span><span id="L-410"><a href="#L-410"><span class="linenos">410</span></a><span class="sd">```python</span>
</span><span id="L-411"><a href="#L-411"><span class="linenos">411</span></a><span class="sd">def initial_conditions(sys, ntr):</span>
</span><span id="L-412"><a href="#L-412"><span class="linenos">412</span></a><span class="sd">    yini = np.zeros(1 + 3*(ntr+1))</span>
</span><span id="L-413"><a href="#L-413"><span class="linenos">413</span></a><span class="sd">    yini[0] = np.log(2*sys.xi*sys.H) #index 0 of yini is log(kh)</span>
</span><span id="L-414"><a href="#L-414"><span class="linenos">414</span></a>
</span><span id="L-415"><a href="#L-415"><span class="linenos">415</span></a><span class="sd">    # initialize all F_X^n as zero at indices [1:]</span>
</span><span id="L-416"><a href="#L-416"><span class="linenos">416</span></a>
</span><span id="L-417"><a href="#L-417"><span class="linenos">417</span></a><span class="sd">    return yini</span>
</span><span id="L-418"><a href="#L-418"><span class="linenos">418</span></a><span class="sd">``` </span>
</span><span id="L-419"><a href="#L-419"><span class="linenos">419</span></a><span class="sd">Note how `sys` has attributes `xi` and `H`. These correspond to the variables we have defined in the previous step.</span>
</span><span id="L-420"><a href="#L-420"><span class="linenos">420</span></a>
</span><span id="L-421"><a href="#L-421"><span class="linenos">421</span></a><span class="sd">Importantly, upon defining `initial_conditions`, we also make a choice; which entries in $\vec{y}$ correspond to which dynamical variable.</span>
</span><span id="L-422"><a href="#L-422"><span class="linenos">422</span></a><span class="sd">In our simple toy model, there actually is no choice to be made: The GEFF package expects that the gauge-field variables are stored *after* all</span>
</span><span id="L-423"><a href="#L-423"><span class="linenos">423</span></a><span class="sd">dynamical variables, as the number of the $\mathcal{F}_\mathcal{X}^{(n)}$&#39;s will vary depending on $n_{\rm tr}$.</span>
</span><span id="L-424"><a href="#L-424"><span class="linenos">424</span></a><span class="sd">Hence, $k_{\rm h}$ necessarily goes first. However, we do have the choice of evolving $\log k_{\rm h}$ instead of $k_{\rm h}$.</span>
</span><span id="L-425"><a href="#L-425"><span class="linenos">425</span></a>
</span><span id="L-426"><a href="#L-426"><span class="linenos">426</span></a>
</span><span id="L-427"><a href="#L-427"><span class="linenos">427</span></a><span class="sd">Next, we write the recipe used to define our GEF ODE. The ODE evolution is computed in two steps:</span>
</span><span id="L-428"><a href="#L-428"><span class="linenos">428</span></a><span class="sd">1. `update_values`: Update `sys` according to $\vec{y}(t)$.</span>
</span><span id="L-429"><a href="#L-429"><span class="linenos">429</span></a><span class="sd">2. `timestep`: Compute $\dot{\vec{y}}(t)$ from `sys`.</span>
</span><span id="L-430"><a href="#L-430"><span class="linenos">430</span></a>
</span><span id="L-431"><a href="#L-431"><span class="linenos">431</span></a><span class="sd">To define `update_values`, we can use all the variables which we have previously declared (they are assumed to be in numerical units):</span>
</span><span id="L-432"><a href="#L-432"><span class="linenos">432</span></a><span class="sd">```python</span>
</span><span id="L-433"><a href="#L-433"><span class="linenos">433</span></a><span class="sd">def update_values(t, y, sys):</span>
</span><span id="L-434"><a href="#L-434"><span class="linenos">434</span></a><span class="sd">    # evolution of spacetime</span>
</span><span id="L-435"><a href="#L-435"><span class="linenos">435</span></a><span class="sd">    sys.t.value = t</span>
</span><span id="L-436"><a href="#L-436"><span class="linenos">436</span></a><span class="sd">    sys.N.value = sys.t*sys.H #perfect de Sitter</span>
</span><span id="L-437"><a href="#L-437"><span class="linenos">437</span></a><span class="sd">    sys.a.value = np.exp(sys.N.value)</span>
</span><span id="L-438"><a href="#L-438"><span class="linenos">438</span></a>
</span><span id="L-439"><a href="#L-439"><span class="linenos">439</span></a><span class="sd">    # define how kh is computed from xi:</span>
</span><span id="L-440"><a href="#L-440"><span class="linenos">440</span></a><span class="sd">    sys.kh.value = np.exp(y[0]) # y[0] is log(kh)</span>
</span><span id="L-441"><a href="#L-441"><span class="linenos">441</span></a>
</span><span id="L-442"><a href="#L-442"><span class="linenos">442</span></a><span class="sd">    # use that y[1] = F_E^0, y[2] = F_B^0, y[3] = F_G^0</span>
</span><span id="L-443"><a href="#L-443"><span class="linenos">443</span></a><span class="sd">    rescale = (sys.kh/sys.a)**4</span>
</span><span id="L-444"><a href="#L-444"><span class="linenos">444</span></a><span class="sd">    sys.E.value = rescale * y[1]</span>
</span><span id="L-445"><a href="#L-445"><span class="linenos">445</span></a><span class="sd">    sys.B.value = rescale * y[2]</span>
</span><span id="L-446"><a href="#L-446"><span class="linenos">446</span></a><span class="sd">    sys.G.value = rescale * y[3]</span>
</span><span id="L-447"><a href="#L-447"><span class="linenos">447</span></a>
</span><span id="L-448"><a href="#L-448"><span class="linenos">448</span></a><span class="sd">    return</span>
</span><span id="L-449"><a href="#L-449"><span class="linenos">449</span></a><span class="sd">```</span>
</span><span id="L-450"><a href="#L-450"><span class="linenos">450</span></a><span class="sd">For `timestep`, we can make use of some pre-defined functions in the `.utility` module.</span>
</span><span id="L-451"><a href="#L-451"><span class="linenos">451</span></a>
</span><span id="L-452"><a href="#L-452"><span class="linenos">452</span></a><span class="sd">```python</span>
</span><span id="L-453"><a href="#L-453"><span class="linenos">453</span></a><span class="sd">from geff.utility.eom import gauge_field_ode</span>
</span><span id="L-454"><a href="#L-454"><span class="linenos">454</span></a><span class="sd">from geff.utility.boundary import boundary_approx</span>
</span><span id="L-455"><a href="#L-455"><span class="linenos">455</span></a><span class="sd">from geff.utility.general import heaviside</span>
</span><span id="L-456"><a href="#L-456"><span class="linenos">456</span></a>
</span><span id="L-457"><a href="#L-457"><span class="linenos">457</span></a><span class="sd">def timestep(t, y, sys):</span>
</span><span id="L-458"><a href="#L-458"><span class="linenos">458</span></a><span class="sd">    dydt = np.zeros_like(y)</span>
</span><span id="L-459"><a href="#L-459"><span class="linenos">459</span></a><span class="sd">    </span>
</span><span id="L-460"><a href="#L-460"><span class="linenos">460</span></a><span class="sd">    dlnkhdt = sys.H.value #dlnkhdt derivative</span>
</span><span id="L-461"><a href="#L-461"><span class="linenos">461</span></a><span class="sd">    dydt[0] = dlnkhdt</span>
</span><span id="L-462"><a href="#L-462"><span class="linenos">462</span></a>
</span><span id="L-463"><a href="#L-463"><span class="linenos">463</span></a><span class="sd">    xi = sys.xi.value</span>
</span><span id="L-464"><a href="#L-464"><span class="linenos">464</span></a>
</span><span id="L-465"><a href="#L-465"><span class="linenos">465</span></a><span class="sd">    # compute boundary terms</span>
</span><span id="L-466"><a href="#L-466"><span class="linenos">466</span></a><span class="sd">    W = boundary_approx(xi)</span>
</span><span id="L-467"><a href="#L-467"><span class="linenos">467</span></a>
</span><span id="L-468"><a href="#L-468"><span class="linenos">468</span></a><span class="sd">    # reshape arrays to fit gauge_field_ode</span>
</span><span id="L-469"><a href="#L-469"><span class="linenos">469</span></a><span class="sd">    Fcol = y[1:].shape[0]//3</span>
</span><span id="L-470"><a href="#L-470"><span class="linenos">470</span></a><span class="sd">    F = y[1:].reshape(Fcol,3)</span>
</span><span id="L-471"><a href="#L-471"><span class="linenos">471</span></a>
</span><span id="L-472"><a href="#L-472"><span class="linenos">472</span></a><span class="sd">    # compute the gauge-field ODEs</span>
</span><span id="L-473"><a href="#L-473"><span class="linenos">473</span></a><span class="sd">    dFdt = gauge_field_ode(F, sys.a, sys.kh, 2*sys.H*xi, W, dlnkhdt)</span>
</span><span id="L-474"><a href="#L-474"><span class="linenos">474</span></a><span class="sd">    # note that we can use &#39;a&#39;, &#39;kh&#39; etc.;</span>
</span><span id="L-475"><a href="#L-475"><span class="linenos">475</span></a><span class="sd">    # &#39;update_values&#39; is called before &#39;timestep&#39;</span>
</span><span id="L-476"><a href="#L-476"><span class="linenos">476</span></a>
</span><span id="L-477"><a href="#L-477"><span class="linenos">477</span></a><span class="sd">    dydt[1:] = dFdt.reshape(Fcol*3) # reshape to fit dydt</span>
</span><span id="L-478"><a href="#L-478"><span class="linenos">478</span></a>
</span><span id="L-479"><a href="#L-479"><span class="linenos">479</span></a><span class="sd">    return dydt</span>
</span><span id="L-480"><a href="#L-480"><span class="linenos">480</span></a><span class="sd">``` </span>
</span><span id="L-481"><a href="#L-481"><span class="linenos">481</span></a>
</span><span id="L-482"><a href="#L-482"><span class="linenos">482</span></a><span class="sd">These are all the ingredients we need to formulate the GEF ODE&#39;s. We can combine them using the `.solver.GEFSolver` class factory:</span>
</span><span id="L-483"><a href="#L-483"><span class="linenos">483</span></a>
</span><span id="L-484"><a href="#L-484"><span class="linenos">484</span></a><span class="sd">```python</span>
</span><span id="L-485"><a href="#L-485"><span class="linenos">485</span></a><span class="sd">from geff.solver import GEFSolver</span>
</span><span id="L-486"><a href="#L-486"><span class="linenos">486</span></a>
</span><span id="L-487"><a href="#L-487"><span class="linenos">487</span></a><span class="sd">solver = GEFSolver(initial_conditions, update_values, timestep, quantities)</span>
</span><span id="L-488"><a href="#L-488"><span class="linenos">488</span></a><span class="sd">``` </span>
</span><span id="L-489"><a href="#L-489"><span class="linenos">489</span></a>
</span><span id="L-490"><a href="#L-490"><span class="linenos">490</span></a><span class="sd">&gt; **Note**: This is just a basic `GEFSolver`. You can also define `Event` objects for a solver.</span>
</span><span id="L-491"><a href="#L-491"><span class="linenos">491</span></a><span class="sd">&gt; An `Event` will check for a certain condition while the ODEs are being solved, and can terminate the solver if the condition is met.</span>
</span><span id="L-492"><a href="#L-492"><span class="linenos">492</span></a><span class="sd">&gt; For example, you can define an `Event` to check if the end of inflation has been reached, or if some positive definite quantity has become negative.</span>
</span><span id="L-493"><a href="#L-493"><span class="linenos">493</span></a><span class="sd">&gt; A `GEFSolver` can be configured to check for any `Event` occurrences and react to them in user-specified ways.</span>
</span><span id="L-494"><a href="#L-494"><span class="linenos">494</span></a><span class="sd">&gt; For more details, see `geff.solver`.</span>
</span><span id="L-495"><a href="#L-495"><span class="linenos">495</span></a>
</span><span id="L-496"><a href="#L-496"><span class="linenos">496</span></a><span class="sd">We also should define the `ModeSolver`. In this toy model, we can just use a pre-defined class. For more complex situations, use `.mbm.ModeSolver`.</span>
</span><span id="L-497"><a href="#L-497"><span class="linenos">497</span></a><span class="sd">```python</span>
</span><span id="L-498"><a href="#L-498"><span class="linenos">498</span></a><span class="sd">from geff.mbm import BaseModeSolver</span>
</span><span id="L-499"><a href="#L-499"><span class="linenos">499</span></a>
</span><span id="L-500"><a href="#L-500"><span class="linenos">500</span></a><span class="sd">MbM = BaseModeSolver</span>
</span><span id="L-501"><a href="#L-501"><span class="linenos">501</span></a><span class="sd">```</span>
</span><span id="L-502"><a href="#L-502"><span class="linenos">502</span></a>
</span><span id="L-503"><a href="#L-503"><span class="linenos">503</span></a><span class="sd">## The finishing touch</span>
</span><span id="L-504"><a href="#L-504"><span class="linenos">504</span></a>
</span><span id="L-505"><a href="#L-505"><span class="linenos">505</span></a><span class="sd"> The last thing we need to do is define how our new GEF model is initialized.</span>
</span><span id="L-506"><a href="#L-506"><span class="linenos">506</span></a>
</span><span id="L-507"><a href="#L-507"><span class="linenos">507</span></a><span class="sd">First, we need to declare, what input our GEF model expects from the user.</span>
</span><span id="L-508"><a href="#L-508"><span class="linenos">508</span></a><span class="sd">There are two constants, $H$ and $\xi$, and the user should tell us their value:</span>
</span><span id="L-509"><a href="#L-509"><span class="linenos">509</span></a><span class="sd">```python</span>
</span><span id="L-510"><a href="#L-510"><span class="linenos">510</span></a><span class="sd">model_input = [H, xi, dxi]</span>
</span><span id="L-511"><a href="#L-511"><span class="linenos">511</span></a><span class="sd">``` </span>
</span><span id="L-512"><a href="#L-512"><span class="linenos">512</span></a><span class="sd">Our model does not require other input; $\mathcal{F}_{\mathcal{X}}^{(n)}$ is initially set to zero, and $k_h(0)$ is determined from $\xi$ and $H$. </span>
</span><span id="L-513"><a href="#L-513"><span class="linenos">513</span></a>
</span><span id="L-514"><a href="#L-514"><span class="linenos">514</span></a><span class="sd">The last step is to define the units of our GEF model based on the user input. This is achieved by the `define_units` function:</span>
</span><span id="L-515"><a href="#L-515"><span class="linenos">515</span></a><span class="sd">```python</span>
</span><span id="L-516"><a href="#L-516"><span class="linenos">516</span></a><span class="sd">def define_units(H):</span>
</span><span id="L-517"><a href="#L-517"><span class="linenos">517</span></a><span class="sd">    # The characteristic inverse time scale is the constant Hubble rate in Planck units</span>
</span><span id="L-518"><a href="#L-518"><span class="linenos">518</span></a><span class="sd">    freq = H</span>
</span><span id="L-519"><a href="#L-519"><span class="linenos">519</span></a><span class="sd">    # The charateristic energy scale is the Planck mass (in Planck units)</span>
</span><span id="L-520"><a href="#L-520"><span class="linenos">520</span></a><span class="sd">    amp = 1. </span>
</span><span id="L-521"><a href="#L-521"><span class="linenos">521</span></a><span class="sd">    return freq, amp</span>
</span><span id="L-522"><a href="#L-522"><span class="linenos">522</span></a><span class="sd">```</span>
</span><span id="L-523"><a href="#L-523"><span class="linenos">523</span></a><span class="sd">The arguments of `define_units` necessarily needs to be a subset of `model_input`. In this case, we only need the Hubble rate, `H` to define our unit system:</span>
</span><span id="L-524"><a href="#L-524"><span class="linenos">524</span></a><span class="sd">The energy scale $\mu$ is the Planck mass in Planck units, while the inverse time scale is the constant Hubble rate $H$.</span>
</span><span id="L-525"><a href="#L-525"><span class="linenos">525</span></a>
</span><span id="L-526"><a href="#L-526"><span class="linenos">526</span></a><span class="sd">We are finally done! We can put everything we defined above in a file, which we call &quot;tutorial.py&quot;, and we are good to go!</span>
</span><span id="L-527"><a href="#L-527"><span class="linenos">527</span></a>
</span><span id="L-528"><a href="#L-528"><span class="linenos">528</span></a><span class="sd">If all went well, you can now use your own GEF flavor just like the pre-defined ones:</span>
</span><span id="L-529"><a href="#L-529"><span class="linenos">529</span></a><span class="sd">```python</span>
</span><span id="L-530"><a href="#L-530"><span class="linenos">530</span></a><span class="sd">import numpy as np</span>
</span><span id="L-531"><a href="#L-531"><span class="linenos">531</span></a><span class="sd">from geff import compile_model</span>
</span><span id="L-532"><a href="#L-532"><span class="linenos">532</span></a><span class="sd"># Here, we assume you have saved your model as &quot;tutorial.py&quot;</span>
</span><span id="L-533"><a href="#L-533"><span class="linenos">533</span></a><span class="sd">import tutorial</span>
</span><span id="L-534"><a href="#L-534"><span class="linenos">534</span></a>
</span><span id="L-535"><a href="#L-535"><span class="linenos">535</span></a><span class="sd">TutorialGEF = compile_model(tutorial)</span>
</span><span id="L-536"><a href="#L-536"><span class="linenos">536</span></a>
</span><span id="L-537"><a href="#L-537"><span class="linenos">537</span></a><span class="sd">H = 5e-6</span>
</span><span id="L-538"><a href="#L-538"><span class="linenos">538</span></a><span class="sd">xi = 5</span>
</span><span id="L-539"><a href="#L-539"><span class="linenos">539</span></a>
</span><span id="L-540"><a href="#L-540"><span class="linenos">540</span></a><span class="sd">mod = TutorialGEF(H=H, xi=xi)</span>
</span><span id="L-541"><a href="#L-541"><span class="linenos">541</span></a>
</span><span id="L-542"><a href="#L-542"><span class="linenos">542</span></a><span class="sd">sol, spec, info = mod.run()</span>
</span><span id="L-543"><a href="#L-543"><span class="linenos">543</span></a><span class="sd">...</span>
</span><span id="L-544"><a href="#L-544"><span class="linenos">544</span></a><span class="sd">```</span>
</span><span id="L-545"><a href="#L-545"><span class="linenos">545</span></a><span class="sd">&lt;script type=&quot;module&quot;&gt;</span>
</span><span id="L-546"><a href="#L-546"><span class="linenos">546</span></a><span class="sd">  import mermaid from &#39;https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs&#39;;</span>
</span><span id="L-547"><a href="#L-547"><span class="linenos">547</span></a><span class="sd">  import elkLayouts from &#39;https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0/dist/mermaid-layout-elk.esm.min.mjs&#39;;</span>
</span><span id="L-548"><a href="#L-548"><span class="linenos">548</span></a><span class="sd">  mermaid.registerLayoutLoaders(elkLayouts);</span>
</span><span id="L-549"><a href="#L-549"><span class="linenos">549</span></a><span class="sd">&lt;/script&gt;</span>
</span><span id="L-550"><a href="#L-550"><span class="linenos">550</span></a><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-551"><a href="#L-551"><span class="linenos">551</span></a><span class="kn">from</span><span class="w"> </span><span class="nn">.gef</span><span class="w"> </span><span class="kn">import</span> <span class="n">compile_model</span>
</span><span id="L-552"><a href="#L-552"><span class="linenos">552</span></a><span class="kn">from</span><span class="w"> </span><span class="nn">.mbm</span><span class="w"> </span><span class="kn">import</span> <span class="n">GaugeSpec</span>
</span><span id="L-553"><a href="#L-553"><span class="linenos">553</span></a><span class="kn">from</span><span class="w"> </span><span class="nn">.bgtypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">BGSystem</span>
</span><span id="L-554"><a href="#L-554"><span class="linenos">554</span></a>
</span><span id="L-555"><a href="#L-555"><span class="linenos">555</span></a><span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.1&quot;</span>
</span></pre></div>


            </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.kind) {
                    case "function":
                        if (doc.fullname.endsWith(".__init__")) {
                            heading = `<span class="name">${doc.fullname.replace(/\.__init__$/, "")}</span>${doc.signature}`;
                        } else {
                            heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span>${doc.signature}`;
                        }
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value"> = ${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.kind}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>