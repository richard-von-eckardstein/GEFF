window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "geff", "modulename": "geff", "kind": "module", "doc": "<p>Welcome to our visitors tour of the <strong>Gradient Expansion Formalism Factory</strong>!</p>\n\n<hr />\n\n<h1 id=\"geff-established-in-2025\">GEFF: Established in 2025</h1>\n\n<p>This python package is designed to handle gauge-field production during cosmic inflation\nusing the <em>gradient expansion formalism</em> (GEF).</p>\n\n<p>If you are interested in axion inflation, the package comes with everything you need:</p>\n\n<ul>\n<li><strong>a variety of flavors</strong>\n<ul>\n<li>pure axion inflation (PAI) : <em>good ol' axion inflation</em></li>\n<li>fermionic axion inflation (FAI) : <em>axion inflation with Standard Model fermions!</em></li>\n</ul></li>\n<li><strong>useful tools</strong>\n<ul>\n<li>Resolve the dynamics of axion inflation including homogeneous backreaction.</li>\n<li>Analyze the gauge-field spectrum.</li>\n<li>Determine the vacuum and induced tensor power spectrum.</li>\n<li>Compute gravitational-wave spectra.</li>\n</ul></li>\n</ul>\n\n<p>But we don't want to hold you back! The package provides a flexible framework to create your <strong>own GEF flavor</strong>, with all built-in tools at your disposable. \nIt is indeed a true GEF <em>factory</em> !</p>\n\n<p>You can install this package using pip</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>cosmo-geff\n</code></pre>\n</div>\n\n<p>or using the <code>geff.yml</code> file found at the <a href=\"https://github.com/riroro13/GEFF\">GitHub repository</a> for this package,</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>conda<span class=\"w\"> </span>env<span class=\"w\"> </span>create<span class=\"w\"> </span>-f<span class=\"w\"> </span>geff.yml\n</code></pre>\n</div>\n\n<p>If you use this package in your work, please cite (...).</p>\n\n<hr />\n\n<h1 id=\"the-refreshing-taste-of-gef\">The refreshing taste of GEF</h1>\n\n<p>The GEF is a numerical technique to determine the dynamics and backreaction of gauge-fields during inflation\nby directly evolving the time-dependent quantum expectation values of the gauge field, \ne.g., $\\langle {\\bf E}^2 \\rangle$, $\\langle {\\bf B}^2 \\rangle$, $\\langle {\\bf E} \\cdot {\\bf B} \\rangle$ etc.\nIf this is the first time you encounter the GEF, here are some useful articles on the topic:</p>\n\n<ul>\n<li><a href=\"https://arxiv.org/abs/2109.01651\">2109.01651</a></li>\n<li><a href=\"https://arxiv.org/abs/2310.09186\">2310.09186</a></li>\n<li><a href=\"https://arxiv.org/abs/2408.16538\">2408.16538</a></li>\n</ul>\n\n<p>The strategy behind the GEF is to take Maxwell's equations in an expanding spacetime,</p>\n\n<p><a name=\"max\">$$\\operatorname{div} {\\bf E} = 0\\, , \\qquad \\operatorname{div} {\\bf B} = 0\\, ,$$</a>\n$$\\dot{{\\bf E}} + 2 H {\\bf E} - \\frac{1}{a}\\operatorname{rot} {\\bf B} + {\\bf J} = 0 \\, ,$$\n$$\\dot{{\\bf B}}  + 2 H {\\bf B} + \\frac{1}{a}\\operatorname{rot} {\\bf E} = 0 \\,$$</p>\n\n<p>and use them to formulate a tower of ODEs for the quantities</p>\n\n<p>$$ \\mathcal{F}_\\mathcal{E}^{(n)} = \\frac{a^4}{k_{{\\rm UV}}^{n+4}}\\langle {\\bf E} \\cdot \\operatorname{rot}^n {\\bf E}\\rangle = \\int\\limits_{0}^{k_{{\\rm UV}}(t)}\\frac{{\\rm d} k}{k} \\frac{a^2 k^{n+3}}{2 \\pi^2 k_{{\\rm UV}}^{n+4}}  \\sum_{\\lambda}\\lambda^n |\\dot{A}_\\lambda(t,k)|^2\\, ,$$\n$$ \\mathcal{F}_\\mathcal{G}^{(n)} = -\\frac{a^4}{2 k_{{\\rm UV}}^{n+4}}\\langle {\\bf E} \\cdot \\operatorname{rot}^n {\\bf B} + {\\bf B} \\cdot \\operatorname{rot}^n {\\bf E}\\rangle = \\int\\limits_{0}^{k_{{\\rm UV}}(t)} \\frac{{\\rm d} k}{k} \\frac{a k^{n+4}}{2 \\pi^2 k_{{\\rm UV}}^{n+4}}\\sum_{\\lambda}\\lambda^{n+1} \\operatorname{Re}[\\dot{A}_\\lambda(t,k)A_\\lambda^*(t,k)] \\, ,$$\n$$ \\mathcal{F}_\\mathcal{B}^{(n)} = \\frac{a^4}{k_{{\\rm UV}}^{n+4}}\\langle {\\bf B} \\cdot \\operatorname{rot}^n {\\bf B}\\rangle = \\int\\limits_{0}^{k_{{\\rm UV}}(t)}\\frac{{\\rm d} k}{k} \\frac{k^{n+5}}{2 \\pi^{2}k_{{\\rm UV}}^{n+4}} \\sum_{\\lambda}\\lambda^n |A_\\lambda(t,k)|^2 \\, ,$$</p>\n\n<p>where, $k_{\\rm UV}$ is a suitably chosen UV regulator which can vary with time. \nFor completeness, we have also given the expression for $\\mathcal{F}_\\mathcal{X}^{(n)}$ in terms of the mode functions $A_\\lambda(t,k)$.</p>\n\n<p>The ODE for the $\\mathcal{F}_\\mathcal{X}^{(n)}$'s are then given by</p>\n\n<p>$$\\frac{\\rm d}{{\\rm d} t} \\mathcal{F}_\\mathcal{E}^{(n)} + (4+n)\\frac{{\\rm d} \\ln k_{\\rm UV}}{{\\rm d} t} \\mathcal{F}_\\mathcal{E}^{(n)}  + 2\\frac{k_{\\rm UV}}{a}\\mathcal{F}_\\mathcal{G}^{(n+1)} + 2 \\frac{a^4}{k_{\\rm UV}^{n+4}} \\langle {\\bf J} \\cdot \\operatorname{rot}^n {\\bf E} \\rangle =  S_{\\mathcal{E}}^{(n)}\\, , $$\n$$\\frac{\\rm d}{{\\rm d} t} \\mathcal{F}_\\mathcal{G}^{(n)} + (4+n)\\frac{{\\rm d} \\ln k_{\\rm UV}}{{\\rm d} t} \\mathcal{F}_\\mathcal{G}^{(n)} - \\frac{k_{\\rm UV}}{a}\\left(\\mathcal{F}_\\mathcal{E}^{(n+1)} - \\mathcal{F}_\\mathcal{B}^{(n+1)}\\right) - \\frac{a^4}{k_{\\rm UV}^{n+4}} \\langle {\\bf J} \\cdot \\operatorname{rot}^n {\\bf B} \\rangle= S_{\\mathcal{G}}^{(n)}\\, , $$\n$$\\frac{\\rm d}{{\\rm d} t} \\mathcal{F}_\\mathcal{B}^{(n)} + (4+n)\\frac{{\\rm d} \\ln k_{\\rm UV}}{{\\rm d} t} \\mathcal{F}_\\mathcal{B}^{(n)} - 2\\frac{k_{\\rm UV}}{a}\\mathcal{F}_\\mathcal{G}^{(n+1)}  =  S_{\\mathcal{B}}^{(n)}\\, .$$</p>\n\n<p>Although these are infinitely many coupled ODE's, one can typically determine an analytical closing condition, such that they may be truncated at some order $n_{\\rm tr}$.</p>\n\n<p>The ODEs for the $\\mathcal{F}_\\mathcal{X}^{(n)}$ can now be simply solved alongside those of the inflationary background.\nThis way, one can handle gauge-field backreaction onto the background dynamics of inflation.</p>\n\n<p>The GEFF package is designed to help the user in the process of solving these equations in the following way</p>\n\n<ul>\n<li>pre-defined and ready-to-use <a href=\"#basics\">GEF flavors</a></li>\n<li>tailored <a href=\"#algorithm\">algorithm</a> to solve the inflationary background dynamics</li>\n<li>options to <a href=\"#model_creation\">implement your own GEF flavor</a></li>\n</ul>\n\n<hr />\n\n<p><a name=\"basics\"></p>\n\n<h1 id=\"sampling-the-gef-flavors\">Sampling the GEF flavors</h1>\n\n<p>GEF models come in various flavors, some of the most intresting applications of the GEF are already implemented in this package.\nAs the first part of our tour, we explore the basic application of the GEFF code using these pre-defined models.</p>\n\n<h2 id=\"choosing-your-flavor\">Choosing your flavor</h2>\n\n<p>We start by sampling a first flavor of our choice; the model \"pai\":</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">geff</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">compile_model</span>\n\n<span class=\"c1\"># Create the GEF model of our choice</span>\n<span class=\"n\">paiGEF</span> <span class=\"o\">=</span> <span class=\"n\">compile_model</span><span class=\"p\">(</span><span class=\"s2\">&quot;pai&quot;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>The object <code>paiGEF</code> is the compiled version of the model found under <code>.models.pai</code>. It defines an ODE solver \nwhich needs to be initialized with information on the setup we want to study:\nThe \"pai\" model expects information on the inflaton--vector coupling $\\beta / M_{\\rm P}$, \ninitial conditions for the inflaton field, $\\varphi(0)$, $\\dot\\varphi(0)$, and the shape of the inflaton potential, $V(\\varphi)$.</p>\n\n<p>In this example, we configure the model to start on the slow-roll attractor of a chaotic inflation potential:</p>\n\n<p>$$ \\varphi(0) = 15.55 M_{\\rm P}, \\qquad \\dot{\\varphi}(0) = -\\sqrt{\\frac{2}{3}} m M_{\\rm P}, \\qquad V(\\varphi) = \\frac{1}{2}m^2 \\varphi^2$$</p>\n\n<p>where $m = 6.16 \\times 10^{-6} M_{\\rm P}$. We set the coupling to $\\beta = 15$.</p>\n\n<p>The necessary information is passed to <code>paiGEF</code> as keyword arguments:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span>\n\n<span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"mf\">6.16e-6</span>\n<span class=\"n\">beta</span> <span class=\"o\">=</span> <span class=\"mi\">15</span>\n\n<span class=\"n\">phi</span> <span class=\"o\">=</span> <span class=\"mf\">15.55</span>\n<span class=\"n\">dphi</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">/</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">m</span>\n\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">V</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span> <span class=\"k\">return</span> <span class=\"mf\">0.5</span><span class=\"o\">*</span><span class=\"n\">m</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span>\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">dV</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span> <span class=\"k\">return</span> <span class=\"n\">m</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span>\n\n<span class=\"n\">mod</span> <span class=\"o\">=</span> <span class=\"n\">paiGEF</span><span class=\"p\">(</span><span class=\"n\">beta</span><span class=\"o\">=</span><span class=\"n\">beta</span><span class=\"p\">,</span> <span class=\"n\">phi</span><span class=\"o\">=</span><span class=\"n\">phi</span><span class=\"p\">,</span> <span class=\"n\">dphi</span><span class=\"o\">=</span><span class=\"n\">dphi</span><span class=\"p\">,</span> <span class=\"n\">V</span><span class=\"o\">=</span><span class=\"n\">V</span><span class=\"p\">,</span> <span class=\"n\">dV</span><span class=\"o\">=</span><span class=\"n\">dV</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>If you want to know what input is expected by the GEF model, use the <code>print_input</code> method of <code>paiGEF</code>.</p>\n\n<blockquote>\n  <p><strong>A note on units</strong>:\n  The pre-defined GEF flavors in the GEFF package work in Planck units $M_{\\rm P}=1$. \n  From the input, the GEF determines the Hubble rate at initialization, $H_0$, (also in Planck units).\n  Internally, the numerical routines work with dimensionless quantities, e.g., $\\bar{X} = X H_0^{-a} M_{\\rm P}^{-b}$ with $a$ and $b$ indicating\n  how $X$ scales with an inverse timescale (e.g., $H_0$) and an energy scale (e.g., $M_{\\rm P}$).\n  For example, the dimensionless inflaton velocity would be like $\\dot{\\bar{\\varphi}} = \\dot{\\varphi}/(H_0 M_{\\rm P})$,\n  i.e., $\\dot{\\varphi}$ scales like an amplitude, $\\varphi \\sim M_{\\rm P}$, and a derivative, $\\partial_t \\sim H_0$.\n  Don't worry, this is happening under the hood, but if you want more details, see <code>.bgtypes</code>.</p>\n</blockquote>\n\n<h2 id=\"getting-a-taste\">Getting a taste</h2>\n\n<p>Now, that our model is initialized, we can solve the inflationary background evolution from these initial conditions:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">sol</span><span class=\"p\">,</span> <span class=\"n\">spec</span><span class=\"p\">,</span> <span class=\"n\">info</span> <span class=\"o\">=</span> <span class=\"n\">mod</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n\n<p>The <code>run</code> method returned three objects. The evolution of the background dynamics is contained in <code>sol</code>,\nthe evolution on the gauge-field mode functions, $A_\\lambda(t, k)$, are computed and returned as the\nobject <code>spec</code>, while <code>info</code> is just a byproduct that contains full information on the ODE solution in <code>sol</code>.\nFor basic applications, all information we actually want is in <code>sol</code> and <code>spec</code>.</p>\n\n<p>Let us focus on <code>sol</code>. It is a <code>BGSystem</code> object which we can use to access the time evolution of several important inflationary quantities defined by our \"pai\" model.\nFor example, you can use it to make a basic plot showing the evolution of the energy densities during inflation as a function of $e$-folds</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">matplotlib.pyplot</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">plt</span>\n\n<span class=\"c1\"># Plot the evolution of the inflaton amplitude as a function of e-folds:</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">dphi</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"mi\">6</span><span class=\"o\">*</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">H</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"c1\"># inflaton kinetic energy density</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">E</span> <span class=\"o\">+</span> <span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">B</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"mi\">6</span><span class=\"o\">*</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">H</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"c1\"># electromagnetic energy density</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">phi</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">H</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"c1\"># inflaton potential energy density</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">yscale</span><span class=\"p\">(</span><span class=\"s2\">&quot;log&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">ylim</span><span class=\"p\">()</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n\n<p>How did we know that <code>sol</code> owns the attributes <code>N</code>,<code>phi</code>, etc.? You can find out using <code>sol.value_names()</code>.\nTo print a full description of all available variables for \"pai\", you can use <code>paiGEF.print_ingredients()</code>. \nOtherwise, this information can also be found at <code>.models.pai</code>. \nIf you need a brief description of any variable <code>X</code>, use <code>X.get_description()</code>.</p>\n\n<blockquote>\n  <p><strong>A note on variables:</strong>\n  The variables encoded in a GEF model use a custom class called <code>Variable</code>. They work like a <code>numpy</code> array. \n  Additionally, constants are realized using the class <code>Constant</code>, and work like a <code>float</code>.\n  Dimensionful functions like the inflaton potential use the <code>Func</code> class, and can be used like a regular function.\n  These classes are defined to take care of unit conversions and are collectively attatched to a <code>BGSystem</code>. If you are curious, have a look at <code>.bgtypes</code>.</p>\n</blockquote>\n\n<p>We did not only get back a <code>sol</code> object, but also <code>spec</code>. This object contains the gauge-field mode functions $A_\\lambda(t,k)$.\nThe code computes these mode functions after having solved the dynamics of the background system ($H(t)$, $\\varphi(t)$ etc.),\nand uses them for estimating the convergence of the background solution. \nWe briefly discuss this algorithm in <a href=\"#algorithm\">the next section</a>.</p>\n\n<p>The object <code>spec</code> is an instance of the <code>GaugeSpec</code> class, which defines useful methods for handling time-dependent gauge-field spectra.\nFor details, see <code>.mbm.GaugeSpec</code>.</p>\n\n<blockquote>\n  <p><strong>A note on gauge-field spectra</strong>\n  If you are only interested in the background evolution and not in the gauge-field spectrum, set <code>nmodes=None</code> in <code>run()</code>.\n  However, it is advised to compute gauge-field spectra to ensure consistency between the background evolution and the spectra.</p>\n</blockquote>\n\n<p>Next, let us store our GEF and mode solutions in a file:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># some dummy paths for illustration</span>\n<span class=\"n\">gefpath</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;some_gef_file.dat&quot;</span>\n<span class=\"n\">mbmpath</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;some_mbm_file.dat&quot;</span>\n\n<span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">save_variables</span><span class=\"p\">(</span><span class=\"n\">gefpath</span><span class=\"p\">)</span>\n<span class=\"n\">spec</span><span class=\"o\">.</span><span class=\"n\">save_spec</span><span class=\"p\">(</span><span class=\"n\">mbmpath</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>The data can be restored from these files using</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">geff</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">GaugeSpec</span>\n\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">mod</span><span class=\"o\">.</span><span class=\"n\">load_GEFdata</span><span class=\"p\">(</span><span class=\"n\">gefpath</span><span class=\"p\">)</span>\n<span class=\"n\">spec</span> <span class=\"o\">=</span> <span class=\"n\">GaugeSpec</span><span class=\"o\">.</span><span class=\"n\">read_spec</span><span class=\"p\">(</span><span class=\"n\">mbmpath</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<blockquote>\n  <p><strong>A note on storage:</strong>\n  The <code>save_variables</code> method does not store information on constants or functions. So, to retrieve\n  the full information on our GEF run, we need to use an appropriately configured instance of\n  <code>paiGEF</code>. In the example above, this is achieved by reusing <code>mod</code>.</p>\n</blockquote>\n\n<h2 id=\"a-rich-palette\">A rich palette</h2>\n\n<p>Obtaining the inflationary dynamics is nice, but it is not all the GEFF can do. For example, let's use our results to compute the corresponding gravitational-wave spectrum:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">geff.tools</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">PowSpecT</span><span class=\"p\">,</span> <span class=\"n\">omega_gw</span>\n\n<span class=\"c1\"># Use sol to initialize the PowSpecT class</span>\n<span class=\"n\">pt_fai</span> <span class=\"o\">=</span> <span class=\"n\">PowSpecT</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Compute the vacuum and induced power spectrum for 100 momentum modes k using spec:</span>\n<span class=\"n\">ks</span><span class=\"p\">,</span> <span class=\"n\">pt_spec</span> <span class=\"o\">=</span> <span class=\"n\">pt_fai</span><span class=\"o\">.</span><span class=\"n\">compute_pt</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">spec</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># from the power spectrum, we can then deduce the gravitational-wave spectrum:</span>\n<span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">gwspec</span> <span class=\"o\">=</span> <span class=\"n\">omega_gw</span><span class=\"p\">(</span><span class=\"n\">ks</span><span class=\"p\">,</span> <span class=\"n\">pt_spec</span><span class=\"p\">[</span><span class=\"s2\">&quot;tot&quot;</span><span class=\"p\">],</span> <span class=\"n\">Nend</span><span class=\"o\">=</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">N</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">Hend</span><span class=\"o\">=</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">H</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n\n<p>We can just use  <code>sol</code> to extract the relevant information on the background solution.\nIt's that easy!</p>\n\n<p>To finish this first part of our tour, let us sample a second GEF flavor, \"fai_kh\":</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># initialize the model</span>\n<span class=\"n\">faiGEF</span> <span class=\"o\">=</span> <span class=\"n\">GEFModel</span><span class=\"p\">(</span><span class=\"s2\">&quot;fai_kh&quot;</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s2\">&quot;picture&quot;</span><span class=\"p\">:</span><span class=\"s2\">&quot;electric&quot;</span><span class=\"p\">})</span>\n\n<span class=\"c1\"># chose initial conditions</span>\n<span class=\"n\">mod</span> <span class=\"o\">=</span> <span class=\"n\">faiGEF</span><span class=\"p\">(</span><span class=\"n\">beta</span><span class=\"o\">=...</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># solve the ODEs as before</span>\n<span class=\"n\">sol</span><span class=\"p\">,</span> <span class=\"n\">spec</span><span class=\"p\">,</span> <span class=\"n\">info</span> <span class=\"o\">=</span> <span class=\"n\">mod</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"o\">...</span>\n<span class=\"o\">...</span>\n</code></pre>\n</div>\n\n<p>This model comes in three varieties (\"pictures\") corresponding to the effective treatment of fermions in the model.\nWe specified the particular variety py passing a <code>settings</code> dictionary upon creating the model.</p>\n\n<p>For more details on the available models, see <code>geff.models</code>.</p>\n\n<p><a name=\"algorithm\"></p>\n\n<h1 id=\"on-the-factory-floor\">On the factory floor</h1>\n\n<p>Next on the tour of the GEF factory, we visit the production line.\nThe following diagram sketches the basic algorithm behind the <code>run</code> method.</p>\n\n<pre class=\"mermaid-pre\"><div class=\"mermaid\">---\nconfig:\n    flowchart:\n        defaultRenderer: \"elk\"\n    theme: 'base'\n    themeVariables:\n        secondaryColor: '#CFCFC6'\n        tertiaryColor: '#FAFAFA'\n---\ngraph TB\n    subgraph A[\"`**GEFModel**`\"]\n        direction TB\n        St((initial data &lt;br&gt;from model))--&gt; GS\n        subgraph GS[\"`**GEFSolver**`\"]\n            direction LR\n            GS1[/initial data/] --&gt; GS2[solve background ODEs] --&gt; GS3[/background &lt;br&gt; dynamics/]\n        end\n        GS -.-&gt; MbM\n        subgraph MbM[\"`**ModeSolver**`\"]\n            direction LR\n            MbM1[/background &lt;br&gt; dynamics/] --&gt; MbM2[compute &lt;br&gt;mode functions] --&gt; MbM3[/spectrum/]\n        end\n        MbM -.-&gt; A2[compare &lt;br&gt;background dynamics &lt;br&gt;&amp; spectrum]\n        C[self-correction &lt;br&gt; using spectrum]\n        GS --&gt; A2\n        A2 -.-&gt; |disagreement| C -.-&gt;  GS\n    A2 --&gt; |agreement|Fin[finalize] --&gt; R1((background &lt;br&gt; dynamics))\n    Fin -.-&gt; R2((spectrum))\n    end\n</div></pre>\n\n<p>As we have seen in the <a href=\"#basics\">first section</a>, the <code>run</code> method is executed as part of a GEF Model.\nEach GEF Model consists of two components, the <code>GEFSolver</code> and the <code>ModeSolver</code>. The former determines the time-dependent inflationary background, \nthe latter computes the mode functions $A_\\lambda(t,k)$.\nThe two results can then be compared to eachother to assess the convergence of the background dynamics.\nIf the two disagree, the GEF will attempt to self-correct using $A_\\lambda(t,k)$.</p>\n\n<p>Note that, if you use <code>run(nmodes=None)</code>, the dotted lines in the diagram can be ignored; the background solution is immediately returned without\ncomputing the gauge-field spectrum.</p>\n\n<p>For more details on the <code>GEFSolver</code>, see <code>geff.solver</code>, while for the <code>ModeSolver</code> see <code>geff.mbm</code>.</p>\n\n<hr />\n\n<p><a name=\"model_creation\"></p>\n\n<h1 id=\"create-your-own-flavor\">Create your own flavor</h1>\n\n<p>Having explored the potential of the GEFF code, you may be inclined to create your own GEF flavor.\nTo help you in this process, we show how to implement an example toy model.</p>\n\n<blockquote>\n  <p><strong>Warning</strong>: Before jumping into this section, we advise that you first familiarize yourself with the GEF method.\n  Also, this tutorial works best, if you have a basic knowledge of the classes defined in <code>.bgtypes</code>.</p>\n</blockquote>\n\n<h2 id=\"the-first-step-is-the-hardest\">The first step is the hardest</h2>\n\n<p>First, we need to work out the mathematical formulation of our model.</p>\n\n<p>Let us consider the case of Abelian gauge-field production in de Sitter space ($H={\\rm const.}$) by a current of the type ${\\bf J} = 2 H \\xi {\\bf B}$, \nwhere $\\xi$ is a constant, which we refer to as instability parameter.The ODE tower for the gauge-field bilinears are then given by:</p>\n\n<p>$$\\frac{\\rm d}{{\\rm d} t} \\mathcal{F}_\\mathcal{E}^{(n)} + (4+n)\\frac{{\\rm d} \\ln k_\\mathrm{h}}{{\\rm d} t} \\mathcal{F}_\\mathcal{E}^{(n)}  + 2\\frac{k_\\mathrm{h}}{a}\\mathcal{F}_\\mathcal{G}^{(n+1)} - 4 H \\xi \\mathcal{F}_\\mathcal{G}^{(n)}=  S_{\\mathcal{E}}^{(n)}\\, , $$\n$$\\frac{{\\rm d}}{{\\rm d} t} \\mathcal{F}_\\mathcal{G}^{(n)} + (4+n)\\frac{{\\rm d} \\ln k_\\mathrm{h}}{{\\rm d} t} \\mathcal{F}_\\mathcal{G}^{(n)} - \\frac{k_\\mathrm{h}}{a}\\left(\\mathcal{F}_\\mathcal{E}^{(n+1)} - \\mathcal{F}_\\mathcal{B}^{(n+1)}\\right) - 2 H \\xi \\mathcal{F}_\\mathcal{B}^{(n)}= S_{\\mathcal{G}}^{(n)}\\, , $$\n$$\\frac{{\\rm d}}{{\\rm d} t} \\mathcal{F}_\\mathcal{B}^{(n)} + (4+n)\\frac{{\\rm d} \\ln k_\\mathrm{h}}{{\\rm d} t} \\mathcal{F}_\\mathcal{B}^{(n)} - 2\\frac{k_\\mathrm{h}}{a}\\mathcal{F}_\\mathcal{G}^{(n+1)}  =  S_{\\mathcal{B}}^{(n)}\\, .$$</p>\n\n<p>One can determine that a sensible regularization scale for this model is given by $k_{\\rm h}(t) = 2aH\\xi$. </p>\n\n<p>The boundary terms $S_\\mathcal{X}^{(n)}$ are a consequence of the time dependence of $k_{\\rm h}$. They are expressed in terms of Whittaker functions,\nbut the GEFF has a module that takes care of them. We will see this later.</p>\n\n<p>Once we have worked out the equations, we can turn to writing a new model file.</p>\n\n<h2 id=\"only-the-best-ingredients\">Only the best ingredients</h2>\n\n<p>The first thing we should state in our model file is the name of the new GEF flavor:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span>\n\n<span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;tutorial&quot;</span>\n</code></pre>\n</div>\n\n<blockquote>\n  <p><strong>A note on settings</strong>: Following the model's name, you can also define a <code>settings</code> dictionary.\n  This dictionary should contain some key&ndash;value pair defining its name and the default setting.\n  The <code>settings</code> should be accompanied by a function called <code>interpret_settings</code>. This method will be called on model creation,\n  so you can use it to define how user input settings are handled. See, e.g., <code>.models.SE_kh</code> for how this is done in practice.</p>\n</blockquote>\n\n<p>Next, we need to define define and categorize the variables which appear in our model. This is taken care of by the functions <code>define_var</code>, <code>define_const</code>,  and <code>define_func</code>.\nThe <code>.bgtypes</code> module also contains some pre-defined variables, which are often encountered in GEF models.</p>\n\n<p>There are three variables which every GEF model needs to define:</p>\n\n<ul>\n<li>$t$ - <em>cosmic time</em> : all ODE's are solved in terms of $t$ starting from $t=0$.</li>\n<li>$N$ - <em>$e$-folds</em> : needed by most internal methods. It should be defined such that $N(t=0)=0$.</li>\n<li>$H$ - <em>Hubble rate</em> : needed by most internal methods.</li>\n</ul>\n\n<p>Beyond these staples, some extra variables appear in our ODE's:</p>\n\n<ul>\n<li>$\\mathcal{F}_\\mathcal{X}^{(n)}$ - <em>the gauge-field bilinears</em></li>\n<li>$k_{\\rm h}$ - <em>the UV regulator</em></li>\n<li>$\\xi$ -  <em>the instability parameter</em></li>\n</ul>\n\n<p>To properly account for the gauge field, we also need to add in the following three variables:</p>\n\n<ul>\n<li>$\\mathcal{E}^{(0)} = \\langle {\\bf E}^2 \\rangle$ - <em>called <code>E</code> by the GEF</em></li>\n<li>$\\mathcal{B}^{(0)} = \\langle {\\bf B}^2 \\rangle$ - <em>called <code>B</code> by the GEF</em></li>\n<li>$\\mathcal{G}^{(0)} = -\\langle {\\bf E} \\cdot {\\bf B} \\rangle$ - <em>called <code>G</code> by the GEF</em></li>\n</ul>\n\n<blockquote>\n  <p><strong>Note on gauge field bilinears</strong> The time evolution of the variables $\\mathcal{F}_\\mathcal{X}^{(n)}$ will not be saved by the GEFF code,\n  since we are typically only interest in the quantities with $n=0$. The output <code>info</code> returned by the <code>run</code> method contains the full information on $\\mathcal{F}_\\mathcal{X}^{(n)}$,\n  but only the information on $n=0$ is passed to <code>sol</code> in the form of  <code>E</code>, <code>B</code> and <code>G</code>.</p>\n</blockquote>\n\n<p>All these variables need to be defined in our model file. This is done as follows:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">geff.bgtypes</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">define_const</span>\n\n<span class=\"c1\"># We make use of the fact that a lot of these variables are pre-defined:</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">geff.bgtypes</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">E</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">G</span><span class=\"p\">,</span> <span class=\"n\">kh</span><span class=\"p\">,</span> <span class=\"n\">GF</span>\n\n<span class=\"c1\"># We also need to define some new objects:</span>\n<span class=\"n\">H</span> <span class=\"o\">=</span> <span class=\"n\">define_const</span><span class=\"p\">(</span><span class=\"s2\">&quot;H&quot;</span><span class=\"p\">,</span> <span class=\"n\">qu_omega</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">qu_mu</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\"># Hubble rate (scales like inverse time)</span>\n<span class=\"n\">xi</span> <span class=\"o\">=</span> <span class=\"n\">define_const</span><span class=\"p\">(</span><span class=\"s2\">&quot;xi&quot;</span><span class=\"p\">,</span> <span class=\"n\">qu_omega</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">qu_mu</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\"># instability parameter</span>\n</code></pre>\n</div>\n\n<p>We use <code>define_const</code> to define the constants for our model: $H$ and $\\xi$.\nThe Hubble rate has mass dimension one, and scales with an inverse time-scale $\\omega$ as, $H = \\bar{H} \\omega$.\nIt does not scale like an amplitude $\\mu$. Hence, <code>qu_omega=1</code> and <code>qu_mu=0</code>.\nSimilarly, $\\xi$ is just a number, and we set <code>qu_omega=0</code> and <code>qu_mu=0</code>.\nThis information needs to be passed to properly allow for unit conversions in the code.\nMore information on units and scaling is given in <code>.bgtypes</code>.</p>\n\n<p>All the variables we have defined serve a specific purpose in our GEF model. To inform the GEFF of this, we need to classify each of them in one of these categories:</p>\n\n<ul>\n<li><strong>time</strong>: a time variable (needs to be <code>t</code>)</li>\n<li><strong>dynamical</strong>: variables whose time-evolution is determined from a differential equation.</li>\n<li><strong>gauge</strong>: the gauge-field variable <code>GF</code> representing $\\mathcal{F}_\\mathcal{X}^{(n)}$.</li>\n<li><strong>static</strong>: variables whose time-evolution is computed from other variables.</li>\n<li><strong>constant</strong>: constants of time.</li>\n<li><strong>function</strong>: functions of the above.</li>\n</ul>\n\n<p>In our case, this would look as follows:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">quantities</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n            <span class=\"s2\">&quot;time&quot;</span><span class=\"p\">:[</span><span class=\"n\">t</span><span class=\"p\">],</span> <span class=\"c1\"># this is mandatory!</span>\n            <span class=\"s2\">&quot;dynamical&quot;</span><span class=\"p\">:[</span><span class=\"n\">kh</span><span class=\"p\">],</span> <span class=\"c1\"># kh is best evolved from an ODE</span>\n            <span class=\"s2\">&quot;gauge&quot;</span><span class=\"p\">:[</span><span class=\"n\">GF</span><span class=\"p\">],</span> <span class=\"c1\"># state the obvious</span>\n            <span class=\"s2\">&quot;static&quot;</span><span class=\"p\">:[</span><span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">E</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">G</span><span class=\"p\">],</span> <span class=\"c1\"># directly computed from other variables</span>\n            <span class=\"s2\">&quot;constant&quot;</span><span class=\"p\">:[</span><span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">xi</span><span class=\"p\">],</span> <span class=\"c1\"># we assume de-Sitter space, and xi is a constant</span>\n            <span class=\"s2\">&quot;function&quot;</span><span class=\"p\">:[]</span>  <span class=\"c1\"># our model does not need any functions</span>\n            <span class=\"p\">}</span>\n</code></pre>\n</div>\n\n<h2 id=\"write-a-recipe\">Write a recipe</h2>\n\n<p>With the variables defined, an important step towards our GEF model is already taken. \nNext, let us set up the <code>GEFSolver</code>. (For more details, see <code>.solver.GEFSolver</code>.)</p>\n\n<p>Internally, the GEFF package uses <code>scipy.integrate.solve_ivp</code> to solve differential equations. \nThis requires that ODE's are formulated as $\\dot{\\vec{y}} = f(t, \\vec{y})$ with $\\vec{y}$ as a <code>numpy</code> array.\nHowever, the GEFF prefers the <code>BGSystem</code> class, which takes care of unit conversions.\nSo, we need to define how to translate between the two.</p>\n\n<p>First up, we define how to interpret user input to initialize the array $\\vec{y}$:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">initial_conditions</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"p\">,</span> <span class=\"n\">ntr</span><span class=\"p\">):</span>\n    <span class=\"n\">yini</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">ntr</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n    <span class=\"n\">yini</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">xi</span><span class=\"o\">*</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">H</span><span class=\"p\">)</span> <span class=\"c1\">#index 0 of yini is log(kh)</span>\n\n    <span class=\"c1\"># initialize all F_X^n as zero at indices [1:]</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">yini</span>\n</code></pre>\n</div>\n\n<p>Note how <code>sys</code> has attributes <code>xi</code> and <code>H</code>. These correspond to the variables we have defined in the previous step.</p>\n\n<p>Importantly, upon defining <code>initial_conditions</code>, we also make a choice; which entries in $\\vec{y}$ correspond to which dynamical variable.\nIn our simple toy model, there actually is no choice to be made: The GEFF package expects that the gauge-field variables are stored <em>after</em> all\ndynamical variables, as the number of the $\\mathcal{F}_\\mathcal{X}^{(n)}$'s will vary depending on $n_{\\rm tr}$.\nHence, $k_{\\rm h}$ necessarily goes first. However, we do have the choice of evolving $\\log k_{\\rm h}$ instead of $k_{\\rm h}$.</p>\n\n<p>Next, we write the recipe used to define our GEF ODE. The ODE evolution is computed in two steps:</p>\n\n<ol>\n<li><code>update_values</code>: Update <code>sys</code> according to $\\vec{y}(t)$.</li>\n<li><code>timestep</code>: Compute $\\dot{\\vec{y}}(t)$ from <code>sys</code>.</li>\n</ol>\n\n<p>To define <code>update_values</code>, we can use all the variables which we have previously declared (they are assumed to be in numerical units):</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">update_values</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">sys</span><span class=\"p\">):</span>\n    <span class=\"c1\"># evolution of spacetime</span>\n    <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">t</span>\n    <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">N</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">t</span><span class=\"o\">*</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">H</span> <span class=\"c1\">#perfect de Sitter</span>\n    <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">N</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># define how kh is computed from xi:</span>\n    <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">kh</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"c1\"># y[0] is log(kh)</span>\n\n    <span class=\"c1\"># use that y[1] = F_E^0, y[2] = F_B^0, y[3] = F_G^0</span>\n    <span class=\"n\">rescale</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">kh</span><span class=\"o\">/</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">4</span>\n    <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">E</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">rescale</span> <span class=\"o\">*</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">B</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">rescale</span> <span class=\"o\">*</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n    <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">rescale</span> <span class=\"o\">*</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]</span>\n\n    <span class=\"k\">return</span>\n</code></pre>\n</div>\n\n<p>For <code>timestep</code>, we can make use of some pre-defined functions in the <code>.utility</code> module.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">geff.utility.eom</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">gauge_field_ode</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">geff.utility.boundary</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">boundary_approx</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">geff.utility.general</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">heaviside</span>\n\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">timestep</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">sys</span><span class=\"p\">):</span>\n    <span class=\"n\">dydt</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros_like</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n\n    <span class=\"n\">dlnkhdt</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"c1\">#dlnkhdt derivative</span>\n    <span class=\"n\">dydt</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">dlnkhdt</span>\n\n    <span class=\"n\">xi</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">xi</span><span class=\"o\">.</span><span class=\"n\">value</span>\n\n    <span class=\"c1\"># compute boundary terms</span>\n    <span class=\"n\">W</span> <span class=\"o\">=</span> <span class=\"n\">boundary_approx</span><span class=\"p\">(</span><span class=\"n\">xi</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># reshape arrays to fit gauge_field_ode</span>\n    <span class=\"n\">Fcol</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">//</span><span class=\"mi\">3</span>\n    <span class=\"n\">F</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">Fcol</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># compute the gauge-field ODEs</span>\n    <span class=\"n\">dFdt</span> <span class=\"o\">=</span> <span class=\"n\">gauge_field_ode</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"p\">,</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">kh</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">H</span><span class=\"o\">*</span><span class=\"n\">xi</span><span class=\"p\">,</span> <span class=\"n\">W</span><span class=\"p\">,</span> <span class=\"n\">dlnkhdt</span><span class=\"p\">)</span>\n    <span class=\"c1\"># note that we can use &#39;a&#39;, &#39;kh&#39; etc.;</span>\n    <span class=\"c1\"># &#39;update_values&#39; is called before &#39;timestep&#39;</span>\n\n    <span class=\"n\">dydt</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"n\">dFdt</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">Fcol</span><span class=\"o\">*</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"c1\"># reshape to fit dydt</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">dydt</span>\n</code></pre>\n</div>\n\n<p>These are all the ingredients we need to formulate the GEF ODE's. We can combine them using the <code>.solver.GEFSolver</code> class factory:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">geff.solver</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">GEFSolver</span>\n\n<span class=\"n\">solver</span> <span class=\"o\">=</span> <span class=\"n\">GEFSolver</span><span class=\"p\">(</span><span class=\"n\">initial_conditions</span><span class=\"p\">,</span> <span class=\"n\">update_values</span><span class=\"p\">,</span> <span class=\"n\">timestep</span><span class=\"p\">,</span> <span class=\"n\">quantities</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<blockquote>\n  <p><strong>Note</strong>: This is just a basic <code>GEFSolver</code>. You can also define <code>Event</code> objects for a solver.\n  An <code>Event</code> will check for a certain condition while the ODEs are being solved, and can terminate the solver if the condition is met.\n  For example, you can define an <code>Event</code> to check if the end of inflation has been reached, or if some positive definite quantity has become negative.\n  A <code>GEFSolver</code> can be configured to check for any <code>Event</code> occurrences and react to them in user-specified ways.\n  For more details, see <code>geff.solver</code>.</p>\n</blockquote>\n\n<p>We also should define the <code>ModeSolver</code>. In this toy model, we can just use a pre-defined class. For more complex situations, use <code>.mbm.ModeSolver</code>.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">geff.mbm</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">BaseModeSolver</span>\n\n<span class=\"n\">MbM</span> <span class=\"o\">=</span> <span class=\"n\">BaseModeSolver</span>\n</code></pre>\n</div>\n\n<h2 id=\"the-finishing-touch\">The finishing touch</h2>\n\n<p>The last thing we need to do is define how our new GEF model is initialized.</p>\n\n<p>First, we need to declare, what input our GEF model expects from the user.\nThere are two constants, $H$ and $\\xi$, and the user should tell us their value:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">model_input</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">xi</span><span class=\"p\">,</span> <span class=\"n\">dxi</span><span class=\"p\">]</span>\n</code></pre>\n</div>\n\n<p>Our model does not require other input; $\\mathcal{F}_{\\mathcal{X}}^{(n)}$ is initially set to zero, and $k_h(0)$ is determined from $\\xi$ and $H$. </p>\n\n<p>The last step is to define the units of our GEF model based on the user input. This is achieved by the <code>define_units</code> function:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">define_units</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"p\">):</span>\n    <span class=\"c1\"># The characteristic inverse time scale is the constant Hubble rate in Planck units</span>\n    <span class=\"n\">freq</span> <span class=\"o\">=</span> <span class=\"n\">H</span>\n    <span class=\"c1\"># The charateristic energy scale is the Planck mass (in Planck units)</span>\n    <span class=\"n\">amp</span> <span class=\"o\">=</span> <span class=\"mf\">1.</span> \n    <span class=\"k\">return</span> <span class=\"n\">freq</span><span class=\"p\">,</span> <span class=\"n\">amp</span>\n</code></pre>\n</div>\n\n<p>The arguments of <code>define_units</code> necessarily needs to be a subset of <code>model_input</code>. In this case, we only need the Hubble rate, <code>H</code> to define our unit system:\nThe energy scale $\\mu$ is the Planck mass in Planck units, while the inverse time scale is the constant Hubble rate $H$.</p>\n\n<p>We are finally done! We can put everything we defined above in a file, which we call \"tutorial.py\", and we are good to go!</p>\n\n<p>If all went well, you can now use your own GEF flavor just like the pre-defined ones:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">geff</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">compile_model</span>\n<span class=\"c1\"># Here, we assume you have saved your model as &quot;tutorial.py&quot;</span>\n<span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">tutorial</span>\n\n<span class=\"n\">TutorialGEF</span> <span class=\"o\">=</span> <span class=\"n\">compile_model</span><span class=\"p\">(</span><span class=\"n\">tutorial</span><span class=\"p\">)</span>\n\n<span class=\"n\">H</span> <span class=\"o\">=</span> <span class=\"mf\">5e-6</span>\n<span class=\"n\">xi</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>\n\n<span class=\"n\">mod</span> <span class=\"o\">=</span> <span class=\"n\">TutorialGEF</span><span class=\"p\">(</span><span class=\"n\">H</span><span class=\"o\">=</span><span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">xi</span><span class=\"o\">=</span><span class=\"n\">xi</span><span class=\"p\">)</span>\n\n<span class=\"n\">sol</span><span class=\"p\">,</span> <span class=\"n\">spec</span><span class=\"p\">,</span> <span class=\"n\">info</span> <span class=\"o\">=</span> <span class=\"n\">mod</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n<span class=\"o\">...</span>\n</code></pre>\n</div>\n\n<script type=\"module\">\n  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';\n  import elkLayouts from 'https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0/dist/mermaid-layout-elk.esm.min.mjs';\n  mermaid.registerLayoutLoaders(elkLayouts);\n</script>\n"}, {"fullname": "geff._docs.docs_bgtypes", "modulename": "geff._docs.docs_bgtypes", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "geff._docs.docs_gef", "modulename": "geff._docs.docs_gef", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "geff._docs.docs_gw", "modulename": "geff._docs.docs_gw", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "geff._docs.docs_mbm", "modulename": "geff._docs.docs_mbm", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "geff._docs.docs_models", "modulename": "geff._docs.docs_models", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "geff._docs.docs_pt", "modulename": "geff._docs.docs_pt", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "geff._docs.docs_solver", "modulename": "geff._docs.docs_solver", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "geff.bgtypes", "modulename": "geff.bgtypes", "kind": "module", "doc": "<p>This module defines base classes used throughout the <code>GEFF</code> module.</p>\n\n<p>The main purpose of these classes is to address the following.\nMost quantities appearing in the GEF will scale according to an inverse-time scale, $\\omega$, and an energy scale, $\\mu$.\nFor example, a time derivative scales with inverse time, $\\partial_t \\sim \\omega$. \nConsequently, also a gauge field, $A_\\mu \\sim \\omega$, as it appears in covariant derivatives.\nOn the other hand, the amplitude of a scalar field scales with energy, $\\varphi \\sim \\mu$.\nIn typical inflationary contexts, $\\omega \\equiv H_0$, some constant Hubble rate, and $\\mu \\equiv M_{\\rm P}$, the Planck mass.</p>\n\n<p>For numerical applications, it is convenient to work with dimensionless quantities.\nFor example, it is useful to perform numerical computations using the dimensionless scalar amplitude $\\bar{\\varphi} = \\varphi/\\mu$, or the dimensionless gauge field, $\\bar{A}_\\mu = A_\\mu / \\omega$.\nUltimately, the quantities we are interested in are obviously $\\varphi$, $A_\\mu$, etc. \nTherefore, we need an easy way to switch between $\\bar{X}$ and $X$.</p>\n\n<p>Throughout the code, we refer to the dimensionless variable, $\\bar{X}$, as being in <strong>numerical units</strong>, while $X$ is in <strong>physical units</strong>. </p>\n\n<p>To facilitate switching between these two unit systems throughout the code, this module provides the classes <code>BGSystem</code>, <code>Variable</code>, <code>Constant</code>, and <code>Func</code>. \nThe latter three are collectively referred to as <code>Quantity</code> objects.\nEach <code>Quantity</code> object is defined by a scaling with $\\omega$ and $\\mu$. For example, the <code>Quantity</code> $X$ scales as $X = \\omega^a \\mu^b \\bar{X}$, where $\\bar{X}$ is the re-scaled quantity used for numerical computations.\nA <code>BGSystem</code> is a collection of <code>Quantity</code> objects, which defines a common unit system by setting the value of $\\omega$ and $\\mu$.</p>\n\n<p>The user may define variables that evolve with cosmic time using the <code>define_var</code> class factory, which creates subclasses of <code>Variable</code>. Examples of a <code>Variable</code> are the Hubble rate, scalar field amplitude etc.\nIn the same manner, the user can define constants of cosmic time using the <code>define_const</code> class factory, which creates subclasses of <code>Constant</code>. Examples of a <code>Constant</code> are, e.g., coupling strengths.\nSome quantities are functions of variables, for example, a scalar potential. These are defined by the factory <code>define_func</code>, which creates subclasses of <code>Func</code>.</p>\n\n<p>The following examples illustrates the basic use of these classes:</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<ol>\n<li>Defining a <code>BGSystem</code></li>\n</ol>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">GEFF.bgtypes</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">BGSystem</span><span class=\"p\">,</span> <span class=\"n\">define_var</span>\n\n<span class=\"c1\"># define two variables corresponding to physical time and Hubble rate.</span>\n<span class=\"n\">time</span> <span class=\"o\">=</span> <span class=\"n\">define_var</span><span class=\"p\">(</span><span class=\"s2\">&quot;t&quot;</span><span class=\"p\">,</span> <span class=\"n\">qu_omega</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">qu_mu</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">Hubble</span> <span class=\"o\">=</span> <span class=\"n\">define_var</span><span class=\"p\">(</span><span class=\"s2\">&quot;H&quot;</span><span class=\"p\">,</span> <span class=\"n\">qu_omega</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">qu_mu</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Create a BGSystem with &#39;time&#39; and &#39;Hubble&#39;</span>\n<span class=\"c1\"># We set the reference frequency to 1e-5*Mpl</span>\n<span class=\"c1\"># The reference energy is the Planck mass in Planck units (so 1)</span>\n<span class=\"n\">U</span> <span class=\"o\">=</span> <span class=\"n\">BGSystem</span><span class=\"p\">({</span><span class=\"n\">time</span><span class=\"p\">,</span> <span class=\"n\">Hubble</span><span class=\"p\">},</span> <span class=\"n\">omega</span><span class=\"o\">=</span><span class=\"mf\">1e-5</span><span class=\"p\">,</span> <span class=\"n\">mu</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># The BGSystem knows about the new variables time and Hubble</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">quantity_names</span><span class=\"p\">())</span> <span class=\"c1\"># prints [&quot;t&quot;, &quot;H&quot;]</span>\n\n<span class=\"c1\"># However, neither the constant nor the variable are instantiated </span>\n<span class=\"c1\"># (we did not specify their value)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">variable_names</span><span class=\"p\">())</span> <span class=\"c1\"># prints []  </span>\n\n<span class=\"c1\"># Instantiate the quantities t and H using the units defined by U:</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">initialise</span><span class=\"p\">(</span><span class=\"s2\">&quot;t&quot;</span><span class=\"p\">)(</span><span class=\"mf\">1e5</span><span class=\"p\">)</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">initialise</span><span class=\"p\">(</span><span class=\"s2\">&quot;H&quot;</span><span class=\"p\">)(</span><span class=\"mf\">1e-5</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">variable_names</span><span class=\"p\">())</span> <span class=\"c1\"># prints [&quot;t&quot;, &quot;H&quot;] </span>\n\n<span class=\"c1\"># The BGSystem now recognizes &quot;t&quot; and &quot;H&quot; as keys:</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;In Planck units, the Hubble rate at time </span><span class=\"si\">{</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"si\">:</span><span class=\"s2\">.1e</span><span class=\"si\">}</span><span class=\"s2\"> is </span><span class=\"si\">{</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"si\">:</span><span class=\"s2\">.1e</span><span class=\"si\">}</span><span class=\"s2\">.&quot;</span><span class=\"p\">)</span>\n<span class=\"c1\"># gives U.t=1e5, U.H=1e-5</span>\n\n<span class=\"c1\"># Convert everything to numerical units</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;In numerical units, the Hubble rate at time </span><span class=\"si\">{</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"si\">}</span><span class=\"s2\"> is </span><span class=\"si\">{</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">H</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"si\">:</span><span class=\"s2\">.1e</span><span class=\"si\">}</span><span class=\"s2\">.&quot;</span><span class=\"p\">)</span> \n<span class=\"c1\"># gives U.t=1, U.H=1</span>\n</code></pre>\n</div>\n\n<ol start=\"2\">\n<li>Adding a new <code>Variable</code> </li>\n</ol>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\">#Let us reset the units of U:</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n\n<span class=\"c1\"># add a new Val: the electric-field expectation value E^2</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">add_variable</span><span class=\"p\">(</span><span class=\"s2\">&quot;E0&quot;</span><span class=\"p\">,</span> <span class=\"n\">qu_omega</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">qu_mu</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\">#since A_mu scales like d / dx^mu </span>\n\n<span class=\"c1\"># initialise E0 with some value in Planck units:</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">initialise</span><span class=\"p\">(</span><span class=\"s2\">&quot;E0&quot;</span><span class=\"p\">)(</span> <span class=\"mf\">6e-10</span> <span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<ol start=\"3\">\n<li>Operations between <code>Variable</code>'s</li>\n</ol>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># We add a new Variable to U, the magnetic-field expectation value</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">add_variable</span><span class=\"p\">(</span><span class=\"s2\">&quot;B0&quot;</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">initialise</span><span class=\"p\">(</span><span class=\"s2\">&quot;B0&quot;</span><span class=\"p\">)(</span><span class=\"mf\">1e-10</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># We can safely add up E0 and B0 as they are in the same units:</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">E0</span> <span class=\"o\">+</span> <span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">B0</span><span class=\"p\">)</span> <span class=\"c1\">#gives 7e-10 = 6e-10 + 1e-10</span>\n\n<span class=\"c1\"># This behaviour is not exclusive to Variables,</span>\n<span class=\"c1\"># but also works for Constants:</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">add_constant</span><span class=\"p\">(</span><span class=\"s2\">&quot;BConst&quot;</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">initialise</span><span class=\"p\">(</span><span class=\"s2\">&quot;BConst&quot;</span><span class=\"p\">)(</span><span class=\"mf\">5e-11</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">E0</span> <span class=\"o\">+</span> <span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">BConst</span><span class=\"p\">)</span> <span class=\"c1\">#gives 6.5e-10 = 6e-10 + 5e-11</span>\n</code></pre>\n</div>\n\n<ol start=\"4\">\n<li>Changing the value of a <code>Variable</code></li>\n</ol>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># The value of a `Variable` can be passed directly</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">BConst</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"mf\">1e-3</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">BConst</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># if we change to numerical units,</span>\n<span class=\"c1\"># the argument which is passed is treated in numerical units</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">BConst</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">BConst</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<ol start=\"5\">\n<li>Adding a new <code>Func</code></li>\n</ol>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\">#first, return to physical units</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n\n<span class=\"c1\"># define a new Func: rhoE, the electric-field energy density</span>\n<span class=\"n\">rhoE</span> <span class=\"o\">=</span> <span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">add_function</span><span class=\"p\">(</span><span class=\"s2\">&quot;rhoE&quot;</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">E0</span><span class=\"p\">],</span> <span class=\"n\">qu_omega</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">qu_mu</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"c1\"># since 3 * M_pl^2 * H^2 = rho</span>\n<span class=\"c1\">#Note how E0 is passed for creation to indicate the scaling of the argument</span>\n\n<span class=\"c1\"># define rhoE as a function of E0:</span>\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span> <span class=\"k\">return</span> <span class=\"mf\">0.5</span><span class=\"o\">*</span><span class=\"n\">x</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">initialise</span><span class=\"p\">(</span><span class=\"s2\">&quot;rhoE&quot;</span><span class=\"p\">)(</span> <span class=\"n\">func</span> <span class=\"p\">)</span>\n<span class=\"c1\"># U.rhoE is now a Callable function with a single argument</span>\n</code></pre>\n</div>\n\n<ol start=\"6\">\n<li>Calling a <code>Func</code> with a <code>Val</code></li>\n</ol>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># Calling rhoE in physical units is straight forwards:</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span> <span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">rhoE</span><span class=\"p\">(</span> <span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">E0</span> <span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"c1\"># gives 3e-10 (in Planck units)</span>\n\n<span class=\"c1\"># compare this to a direct call to func:</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"mf\">6e-10</span><span class=\"p\">)</span> <span class=\"p\">)</span>  <span class=\"c1\"># gives 3e-10 (the result in Planck units)</span>\n\n<span class=\"c1\"># Switching E0 to numerical units, nothing changes since rhoE is in physical units:</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">E0</span><span class=\"o\">.</span><span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"kc\">False</span> <span class=\"c1\"># E0.value = 6e10</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span> <span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">rhoE</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">E0</span><span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"c1\"># gives 3e-10 (still in Planck units)</span>\n\n<span class=\"c1\"># Only switching U.rhoE to numerical units changes the result:</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">rhoE</span><span class=\"o\">.</span><span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span> <span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">rhoE</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">E0</span><span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"c1\"># gives 3. = 3e-10 / (U.omega*U.mu)**2 (now in numerical units)</span>\n\n<span class=\"c1\"># Again, this outcome does not depend on the units of E0:</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">E0</span><span class=\"o\">.</span><span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span> <span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">rhoE</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">E0</span><span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"c1\"># gives 3. = 3e-10 / (U.omega*U.mu)**2 (in numerical units)</span>\n</code></pre>\n</div>\n\n<ol start=\"7\">\n<li>Calling a <code>Func</code> with a <code>float</code></li>\n</ol>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># instead of calling rhoE by E0, we can call it by a float:</span>\n<span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"mf\">6e-10</span>\n\n<span class=\"c1\"># First the behavior if rhoE is in physical units:</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">rhoE</span><span class=\"o\">.</span><span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span> <span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">rhoE</span><span class=\"p\">(</span> <span class=\"n\">val</span> <span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"c1\"># gives 3e-10 (in Planck units)</span>\n\n<span class=\"c1\"># The behavior is different compared to a Val if rhoE is in numerical units:</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">rhoE</span><span class=\"o\">.</span><span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span> <span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">rhoE</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"c1\">#gives 3e-20 = 0.5* (6e-10*U.omega**4) / (U.omega*U.mu)**2</span>\n\n<span class=\"c1\"># Unlike a Val, the float does not track units</span>\n<span class=\"c1\"># Therefore, it is always assumed to be in the units of rhoE</span>\n<span class=\"c1\"># If you want to get the correct result, you would need to convert val by hand:</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span> <span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">rhoE</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"o\">/</span><span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">omega</span><span class=\"o\">**</span><span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"c1\"># gives 3., the expected result in numerical units.</span>\n\n<span class=\"c1\"># Overall, its safer to just keep everything in the same units:</span>\n<span class=\"n\">U</span><span class=\"o\">.</span><span class=\"n\">units</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n</code></pre>\n</div>\n"}, {"fullname": "geff.bgtypes.BGSystem", "modulename": "geff.bgtypes", "qualname": "BGSystem", "kind": "class", "doc": "<p>A collection of cosmological variables sharing a system of units.</p>\n\n<p>Instances of this class define two base unit systems,\n<em>physical units</em> and <em>numerical units</em>, by setting an energy scale, <code>mu</code>, and an inverse time scale, <code>omega</code>. </p>\n\n<p>The cosmological variables (time, Hubble rate, etc.) are represented by <code>Quantity</code> objects.\nThese objects are stored in <code>quantities</code>, and can can be initialise using <code>initialise</code>.\nInstances of these objects can be collectively converted between units by setting <code>units</code>. </p>\n\n<p>This class is the fundamental building block of the <code>GEFF</code> code.</p>\n"}, {"fullname": "geff.bgtypes.BGSystem.__init__", "modulename": "geff.bgtypes", "qualname": "BGSystem.__init__", "kind": "function", "doc": "<p>Create a new BGSystem in physical units.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>quantity_set</strong> (set of Quantity):\nused to define <code>quantities</code></li>\n<li><strong>omega</strong> (float):\nthe characteristic frequency scale</li>\n<li><strong>mu</strong> (float):\nthe characteristic energy scale</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">quantity_set</span><span class=\"p\">:</span> <span class=\"nb\">set</span>, </span><span class=\"param\"><span class=\"n\">omega</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">mu</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span>)</span>"}, {"fullname": "geff.bgtypes.BGSystem.quantities", "modulename": "geff.bgtypes", "qualname": "BGSystem.quantities", "kind": "variable", "doc": "<p>A dictionary of all <code>Quantity</code> objects for this BGSystem</p>\n", "annotation": ": dict"}, {"fullname": "geff.bgtypes.BGSystem.omega", "modulename": "geff.bgtypes", "qualname": "BGSystem.omega", "kind": "variable", "doc": "<p>A frequency scale (typically the Hubble rate at some reference time)</p>\n", "annotation": ": float"}, {"fullname": "geff.bgtypes.BGSystem.mu", "modulename": "geff.bgtypes", "qualname": "BGSystem.mu", "kind": "variable", "doc": "<p>An energy scale (typically the Planck mass)</p>\n", "annotation": ": float"}, {"fullname": "geff.bgtypes.BGSystem.units", "modulename": "geff.bgtypes", "qualname": "BGSystem.units", "kind": "variable", "doc": "<p>Indicates the current units of the BGSystem. <code>True</code>:physical units, <code>False</code>:numerical units</p>\n", "annotation": ": bool"}, {"fullname": "geff.bgtypes.BGSystem.from_system", "modulename": "geff.bgtypes", "qualname": "BGSystem.from_system", "kind": "function", "doc": "<p>Initialize a new <code>BGSystem</code> from an existing instance.</p>\n\n<p>The new instance is created with the same quantities, reference frequency and amplitude as the original.\nIf specified, the <code>Quantity</code> instances are also copied to the new BGSystem</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sys</strong> (BGSystem):\nthe original instance used as a template</li>\n<li><strong>copy</strong> (Boolean):\n<code>True</code> if <code>Quantity</code> instances are also copied</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>newinstance</strong> (BGSystem):\nthe new instance</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">sys</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span>,</span><span class=\"param\">\t<span class=\"n\">copy</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.quantity_set", "modulename": "geff.bgtypes", "qualname": "BGSystem.quantity_set", "kind": "function", "doc": "<p>Get a set of all <code>Quantity</code> objects attributed to this BGSystem.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>set</strong> (set):\na set of objects.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">set</span><span class=\"p\">[</span><span class=\"nb\">object</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.quantity_names", "modulename": "geff.bgtypes", "qualname": "BGSystem.quantity_names", "kind": "function", "doc": "<p>Get a list of names for all <code>Quantity</code> objects attributed to this BGSystem.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>names</strong> (list of str):\nthe list of names.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.initialise", "modulename": "geff.bgtypes", "qualname": "BGSystem.initialise", "kind": "function", "doc": "<p>Instantiate a <code>Quantity</code> object from <code>quantities</code>.</p>\n\n<p>The method creates a function <code>init</code> which can be called by\nan arithmetic type / <code>Callable</code> to instantiate a <code>Val</code> / <code>Func</code>.\nCalling <code>init</code> adds and instance of the <code>Quantity</code> as a new attribute to the BGSystem,\nwith the attribute name corresponding to the object's <code>name</code> attribute.   </p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>quantity</strong> (str):\nthe name of the object which is to be instantiated.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>init</strong> (Callable):\na function used to initialize the <code>Quantity</code> object</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">quantity</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Callable</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.variable_list", "modulename": "geff.bgtypes", "qualname": "BGSystem.variable_list", "kind": "function", "doc": "<p>Get a list of all <code>Variable</code> instances attributed to this BGSystem.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>vals</strong> (list of Variable):\nthe list of <code>Variable</code> instances.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">Variable</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.variable_names", "modulename": "geff.bgtypes", "qualname": "BGSystem.variable_names", "kind": "function", "doc": "<p>Get a list of names for all <code>Variable</code> instances attributed to this BGSystem.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>names</strong> (list of str):\nthe list of names.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.constant_list", "modulename": "geff.bgtypes", "qualname": "BGSystem.constant_list", "kind": "function", "doc": "<p>Get a list of all <code>Constant</code> instances attributed to this BGSystem.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>vals</strong> (list of Val):\nthe list of <code>Constant</code> instances.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">Constant</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.constant_names", "modulename": "geff.bgtypes", "qualname": "BGSystem.constant_names", "kind": "function", "doc": "<p>Get a list of names for all <code>Constant</code> instances attributed to this BGSystem.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>names</strong> (list of str):\nthe list of names.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.function_list", "modulename": "geff.bgtypes", "qualname": "BGSystem.function_list", "kind": "function", "doc": "<p>Get a list of all <code>Func</code> instances attributed to this BGSystem.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>funcs</strong> (list of Func):\nthe list of <code>Func</code> instances.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">Func</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.function_names", "modulename": "geff.bgtypes", "qualname": "BGSystem.function_names", "kind": "function", "doc": "<p>Get a list of names for all <code>Func</code> instances attributed to this BGSystem.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>names</strong> (list of str):\nthe list of names.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.remove", "modulename": "geff.bgtypes", "qualname": "BGSystem.remove", "kind": "function", "doc": "<p>Remove a <code>Quantity</code> object and its instance from the BGSystem.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name</strong> (str):\nthe name of the object</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.add_variable", "modulename": "geff.bgtypes", "qualname": "BGSystem.add_variable", "kind": "function", "doc": "<p>Define a new <code>Variable</code> object and add it to <code>quantities</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name</strong> (str):\nthe name of the new object.</li>\n<li><strong>qu_omega</strong> (int):\nthe 'u_omega' parameter of the new object.</li>\n<li><strong>qu_mu</strong> (int):\nthe 'u_mu' parameter of the new object.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">qu_omega</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">qu_mu</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.add_constant", "modulename": "geff.bgtypes", "qualname": "BGSystem.add_constant", "kind": "function", "doc": "<p>Define a new <code>Constant</code> object and add it to <code>quantities</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name</strong> (str):\nthe name of the new object.</li>\n<li><strong>qu_omega</strong> (int):\nthe 'u_omega' parameter of the new object.</li>\n<li><strong>qu_mu</strong> (int):\nthe 'u_mu' parameter of the new object.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">qu_omega</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">qu_mu</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.add_function", "modulename": "geff.bgtypes", "qualname": "BGSystem.add_function", "kind": "function", "doc": "<p>Define a new <code>Func</code> object and add it to <code>quantities</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name</strong> (str):\nthe name of the new object.</li>\n<li><strong>args</strong> (list of BGVal):\nthe 'args' parameter of the new object.</li>\n<li><strong>qu_omega</strong> (int):\nthe 'u_omega' parameter of the new object.</li>\n<li><strong>qu_mu</strong> (int):\nthe 'u_mu' parameter of the new object.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">args</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">Val</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">qu_omega</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">qu_mu</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.save_variables", "modulename": "geff.bgtypes", "qualname": "BGSystem.save_variables", "kind": "function", "doc": "<p>Save the data in the current GEF instance in an output file.</p>\n\n<p>Note, data is always stored in numerical units.\nThe save will not store constants or functions, only variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\nPath to store data in.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: if the GEF object has no data to store.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.BGSystem.load_variables", "modulename": "geff.bgtypes", "qualname": "BGSystem.load_variables", "kind": "function", "doc": "<p>Load data and store its results in the BGSystem.</p>\n\n<p>Note, data is always loaded assuming numerical units.\nData is only loaded for variables, not for functions or constants.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (None or str):\nPath to load data from</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>FileNotFoundError</strong>: if no file is found at <code>path</code>.</li>\n<li><strong>AttributeError</strong>: if the file contains a column labeled by a key which does not match any BGSystem variable.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.Quantity", "modulename": "geff.bgtypes", "qualname": "Quantity", "kind": "class", "doc": "<p>An object representing a cosmological quantity. </p>\n\n<p>A cosmological quantity has a characteristic scaling with respect to a frequency scale (e.g., the Hubble rate at some reference time), and energy scale (e.g., the Planck mass).</p>\n\n<p>Typical such objects are:</p>\n\n<ul>\n<li>cosmic time $t = \\bar{t}/\\omega$</li>\n<li>frequency $f = \\omega \\bar{f}$</li>\n<li>scalar-field vev $\\varphi = \\mu \\bar{\\varphi}$</li>\n<li>scalar potential $ V(\\varphi) = \\omega^2 \\mu^2 \\bar{V}(\\bar{\\varphi} \\mu) $ </li>\n<li>gauge fields $A_\\mu =  \\omega\\bar{A}_\\mu $ <em>(i.e., scales like a time derivative)</em></li>\n</ul>\n\n<p><code>Quantity</code> objects are initialized as part of a <code>BGSystem</code>, which defines $\\omega$ and $\\mu$.</p>\n\n<p>This class is a parent of <code>Val</code> and <code>Func</code>.</p>\n"}, {"fullname": "geff.bgtypes.Quantity.__init__", "modulename": "geff.bgtypes", "qualname": "Quantity.__init__", "kind": "function", "doc": "<p>Create a new Quantity as part of a BGSystem</p>\n\n<p>The units of the new object matches those of the BGSystem</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sys</strong> (BGSystem):\nthe BGSystem to which the object belongs</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sys</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span>)</span>"}, {"fullname": "geff.bgtypes.Quantity.name", "modulename": "geff.bgtypes", "qualname": "Quantity.name", "kind": "variable", "doc": "<p>The objects name</p>\n", "annotation": ": ClassVar[str]", "default_value": "&#x27;&#x27;"}, {"fullname": "geff.bgtypes.Quantity.description", "modulename": "geff.bgtypes", "qualname": "Quantity.description", "kind": "variable", "doc": "<p>A brief description of the object</p>\n", "annotation": ": ClassVar[str]", "default_value": "&#x27;&#x27;"}, {"fullname": "geff.bgtypes.Quantity.u_omega", "modulename": "geff.bgtypes", "qualname": "Quantity.u_omega", "kind": "variable", "doc": "<p>Indicates how the object scales with frequency.</p>\n", "annotation": ": ClassVar[int]", "default_value": "0"}, {"fullname": "geff.bgtypes.Quantity.u_mu", "modulename": "geff.bgtypes", "qualname": "Quantity.u_mu", "kind": "variable", "doc": "<p>Indicates how the object scales with energy.</p>\n", "annotation": ": ClassVar[int]", "default_value": "0"}, {"fullname": "geff.bgtypes.Quantity.units", "modulename": "geff.bgtypes", "qualname": "Quantity.units", "kind": "variable", "doc": "<p>Indicates the current units of the Quantity. <code>True</code>:physical units, <code>False</code>:numerical units</p>\n", "annotation": ": bool"}, {"fullname": "geff.bgtypes.Quantity.conversion", "modulename": "geff.bgtypes", "qualname": "Quantity.conversion", "kind": "variable", "doc": "<p>A conversion factor between numerical and physical units.</p>\n", "annotation": ": float"}, {"fullname": "geff.bgtypes.Quantity.get_description", "modulename": "geff.bgtypes", "qualname": "Quantity.get_description", "kind": "function", "doc": "<p>Return a string describing the object.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.Val", "modulename": "geff.bgtypes", "qualname": "Val", "kind": "class", "doc": "<p>A <code>Quantity</code> subclass used as basis for defining real-valued variables and constants.</p>\n\n<p>In addition to the basic structure defined by <code>Quantity</code>, this class can be used like an arithmetic type.\nIt defines basic arithmetic operations on its instances as operations on their underlying <code>value</code> attribute.</p>\n\n<p>As a subclass of <code>Quantity</code> it inherits all its attributes and methods, ensuring \n that <code>value</code> is changed according to <code>units</code> by using <code>conversion</code>.</p>\n\n<p>The class serves as a parent for <code>Variable</code> and <code>Constant</code>.</p>\n", "bases": "Quantity"}, {"fullname": "geff.bgtypes.Val.__init__", "modulename": "geff.bgtypes", "qualname": "Val.__init__", "kind": "function", "doc": "<p>Create a new instance using a BGSystem.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>value</strong> (NDArray):\nthe underlying array of the instance</li>\n<li><strong>sys</strong> (BGSystem):\nthe BGSystem to which the instance belongs</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">sys</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span>)</span>"}, {"fullname": "geff.bgtypes.Val.value", "modulename": "geff.bgtypes", "qualname": "Val.value", "kind": "variable", "doc": "<p>The objects value in its respective units.</p>\n", "annotation": ": float"}, {"fullname": "geff.bgtypes.Func", "modulename": "geff.bgtypes", "qualname": "Func", "kind": "class", "doc": "<p>A <code>Quantity</code> subclass representing real functions of variables like the inflaton potential.</p>\n\n<p>An instance of this class can be used as a function,\nevaluating the underlying method, <code>basefunc</code> depending on the state of <code>units</code>.</p>\n\n<p>In physical units, the call returns the result of <code>basefunc</code>.\nIn numerical units, the call instead returns <code>basefunc(*args)/conversion</code>.<br />\nIf called by a <code>Val</code> object, the argument is also converted according to the units of the <code>Val</code> instance\n(generically, identical to the ones of the <code>Func</code> instance).\nIf instead called by a regular arithmetic data type (e.g., <code>float</code>),\n  it is assumed that the argument is in the same unit system as the <code>Func</code> instance.</p>\n\n<p>A typical object is the scalar potential, $V(\\varphi) = \\omega^2 \\mu^2 \\bar{V}(\\bar{\\varphi} \\mu) $</p>\n\n<p>To define a custom <code>Func</code> object, use the class factory <code>define_func</code>.</p>\n", "bases": "Quantity"}, {"fullname": "geff.bgtypes.Func.__init__", "modulename": "geff.bgtypes", "qualname": "Func.__init__", "kind": "function", "doc": "<p>Create a new instance using a <code>Callable</code> and a BGSystem</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>func</strong> (NDArray):\nthe underlying function <code>f(*args)</code> of the instance</li>\n<li><strong>sys</strong> (BGSystem):\nthe BGSystem to which the instance belongs</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>TypeError</strong>: if the number of arguments of <code>func</code> do not match <code>args</code></li>\n<li><strong>ValueError</strong>: if the return of<code>func</code> can't be converted to <code>dtype</code></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>, </span><span class=\"param\"><span class=\"n\">sys</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span>)</span>"}, {"fullname": "geff.bgtypes.Func.args", "modulename": "geff.bgtypes", "qualname": "Func.args", "kind": "variable", "doc": "<p>Indicates the argument signature for the class.</p>\n", "annotation": ": ClassVar[list[geff.bgtypes.Val]]", "default_value": "[]"}, {"fullname": "geff.bgtypes.Func.dtype", "modulename": "geff.bgtypes", "qualname": "Func.dtype", "kind": "variable", "doc": "<p>The data type returned by <code>__call__</code>.</p>\n", "annotation": ": ClassVar[numpy.floating]", "default_value": "&lt;class &#x27;numpy.float64&#x27;&gt;"}, {"fullname": "geff.bgtypes.Func.basefunc", "modulename": "geff.bgtypes", "qualname": "Func.basefunc", "kind": "variable", "doc": "<p>The underlying function which defines the <code>__call__</code> method.</p>\n", "annotation": ": Callable"}, {"fullname": "geff.bgtypes.Func.get_arg_conversions", "modulename": "geff.bgtypes", "qualname": "Func.get_arg_conversions", "kind": "function", "doc": "<p>Get a list of conversion factors for each argument of <code>basefunc</code>.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>arg_conversions</strong> (list of float):\na list of conversion factors</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.Variable", "modulename": "geff.bgtypes", "qualname": "Variable", "kind": "class", "doc": "<p>A <code>Val</code> subclass representing real-valued variables evolving with cosmic time.</p>\n\n<p>Instances of this class can be used like a <code>Val</code> with <code>value</code> as a 1-D Numpy-Array.\n Indexed returns the associated index of <code>value</code>.</p>\n", "bases": "Val"}, {"fullname": "geff.bgtypes.Variable.__init__", "modulename": "geff.bgtypes", "qualname": "Variable.__init__", "kind": "function", "doc": "<p>Create a new instance using a numpy array and a BGSystem</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>value</strong> (NDArray):\nthe underlying array of the instance</li>\n<li><strong>sys</strong> (BGSystem):\nthe BGSystem to which the instance belongs</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">sys</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span>)</span>"}, {"fullname": "geff.bgtypes.Variable.dtype", "modulename": "geff.bgtypes", "qualname": "Variable.dtype", "kind": "variable", "doc": "<p>The data type of <code>value</code>.</p>\n", "annotation": ": ClassVar[numpy.floating]", "default_value": "&lt;class &#x27;numpy.float64&#x27;&gt;"}, {"fullname": "geff.bgtypes.Variable.value", "modulename": "geff.bgtypes", "qualname": "Variable.value", "kind": "variable", "doc": "<p>The objects value in its respective units.</p>\n", "annotation": ": numpy.ndarray"}, {"fullname": "geff.bgtypes.Constant", "modulename": "geff.bgtypes", "qualname": "Constant", "kind": "class", "doc": "<p>A <code>Val</code> subclass representing a constant of cosmic time.</p>\n\n<p>Instances of this class can be used like a float for mathematical operations as defined by <code>Val</code>.</p>\n", "bases": "Val"}, {"fullname": "geff.bgtypes.Constant.__init__", "modulename": "geff.bgtypes", "qualname": "Constant.__init__", "kind": "function", "doc": "<p>Create a new instance using a float and a BGSystem</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>value</strong> (NDArray):\nthe underlying array of the instance</li>\n<li><strong>sys</strong> (BGSystem):\nthe BGSystem to which the instance belongs</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>TypeError</strong>: if value cannot be converted to a float</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">sys</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span>)</span>"}, {"fullname": "geff.bgtypes.GaugeField", "modulename": "geff.bgtypes", "qualname": "GaugeField", "kind": "class", "doc": "<p>A low level class defining some basic properties of gauge-field bilinear towers.</p>\n\n<p>A gauge-field bilinear tower is defined as a collection of the following three objects,</p>\n\n<p>$$ \\mathcal{F}_\\mathcal{E}^{(n)} = \\frac{a^4}{k_{{\\rm UV}}^{n+4}}\\langle {\\bf E} \\cdot \\operatorname{rot}^n {\\bf E}\\rangle = \\int\\limits_{0}^{k_{{\\rm UV}}(t)}\\frac{{\\rm d} k}{k} \\frac{a^2 k^{n+3}}{2 \\pi^2 k_{{\\rm UV}}^{n+4}}  \\sum_{\\lambda}\\lambda^n |\\dot{A}_\\lambda(t,k)|^2\\, ,$$\n$$ \\mathcal{F}_\\mathcal{G}^{(n)} = -\\frac{a^4}{2 k_{{\\rm UV}}^{n+4}}\\langle {\\bf E} \\cdot \\operatorname{rot}^n {\\bf B} + {\\bf B} \\cdot \\operatorname{rot}^n {\\bf E}\\rangle = \\int\\limits_{0}^{k_{{\\rm UV}}(t)} \\frac{{\\rm d} k}{k} \\frac{a k^{n+4}}{2 \\pi^2 k_{{\\rm UV}}^{n+4}}\\sum_{\\lambda}\\lambda^{n+1} \\operatorname{Re}[\\dot{A}_\\lambda(t,k)A_\\lambda^*(t,k)] \\, ,$$\n$$ \\mathcal{F}_\\mathcal{B}^{(n)} = \\frac{a^4}{k_{{\\rm UV}}^{n+4}}\\langle {\\bf E} \\cdot \\operatorname{rot}^n {\\bf E}\\rangle = \\int\\limits_{0}^{k_{{\\rm UV}}(t)}\\frac{{\\rm d} k}{k} \\frac{k^{n+5}}{2 \\pi^{2}k_{{\\rm UV}}^{n+4}} \\sum_{\\lambda}\\lambda^n |A_\\lambda(t,k)|^2 \\, ,$$</p>\n\n<p>here $k_{\\rm UV}$ is a UV cutoff scale, ${\\bf E}$ and ${\\bf B}$ are electric and magnetic field operators,\n  and $A_\\lambda(t,k)$ is a gauge-field mode function. The integer $n$ varies between $0$ and a maximum value, $n_{\\rm tr}$.</p>\n\n<p>The <code>GaugeField</code> class collects important information about the collection $\\mathcal{F}_\\mathcal{X}^{(n)}$.\nThe <code>GEFF</code> code needs to know, which <code>Variable</code> sets the UV cutoff scale, and\nwhich <code>Variable</code>s correspond to the zero-order quantities, $\\langle {\\bf E}^2\\rangle$, $\\langle {\\bf B}^2\\rangle$, and $-\\langle {\\bf E} \\cdot {\\bf B}\\rangle$.</p>\n\n<p>Note that a <code>GaugeField</code> is never part of a <code>BGSystem</code>, as the number of variables depends on $n_{\\rm tr}$, which is not fixed a priori.\nIn fact, terms with $n>1$ are often only auxiliary and not used by the <code>GEFF</code> after the differential equations have been solved.\nHowever, the quantities $\\mathcal{F}_\\mathcal{X}^{(n)}$ are defined to be unitless, so they do not need to be converted between numerical and physical units.</p>\n\n<p>A custom <code>GaugeField</code> can be defined using <code>BGGauge</code>.</p>\n"}, {"fullname": "geff.bgtypes.GaugeField.name", "modulename": "geff.bgtypes", "qualname": "GaugeField.name", "kind": "variable", "doc": "<p>The name of the class.</p>\n", "annotation": ": ClassVar[str]", "default_value": "&#x27;&#x27;"}, {"fullname": "geff.bgtypes.GaugeField.zeros", "modulename": "geff.bgtypes", "qualname": "GaugeField.zeros", "kind": "variable", "doc": "<p>A list of the associated 0$^{\\rm th}$ order quantities.</p>\n", "annotation": ": ClassVar[list[geff.bgtypes.Variable]]", "default_value": "[]"}, {"fullname": "geff.bgtypes.GaugeField.cutoff", "modulename": "geff.bgtypes", "qualname": "GaugeField.cutoff", "kind": "variable", "doc": "<p>The associated UV cutoff scale.</p>\n", "annotation": ": geff.bgtypes.Variable", "default_value": "None"}, {"fullname": "geff.bgtypes.GaugeField.get_description", "modulename": "geff.bgtypes", "qualname": "GaugeField.get_description", "kind": "function", "doc": "<p>Return a string describing the object.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.define_var", "modulename": "geff.bgtypes", "qualname": "define_var", "kind": "function", "doc": "<p>Creates a subclass of <code>Variable</code> with custom name, and scaling.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>qname</strong> (str):\nthe <code>name</code> attribute of the subclass</li>\n<li><strong>qu_omega</strong> (int):\nthe <code>u_omega</code> attribute of the subclass</li>\n<li><strong>qu_mu</strong> (int):\nthe <code>u_mu</code> attribute of the subclass</li>\n<li><strong>qdescription</strong> (str):\na brief description of the subclass</li>\n<li><strong>qdtype</strong> (Numpy Data Type):\nthe <code>dtype</code> attribute of the subclass</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>CustomVar</strong> (class):\nthe custom subclass</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>TypeError</strong>: if the data type is not a subtype of <code>numpy.floating</code></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">qname</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">qu_omega</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">qu_mu</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">qdescription</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\tqdtype: numpy.dtype = &lt;class &#x27;numpy.float64&#x27;&gt;</span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.define_const", "modulename": "geff.bgtypes", "qualname": "define_const", "kind": "function", "doc": "<p>Creates a subclass of <code>Constant</code> with custom name, and scaling.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>qname</strong> (str):\nthe <code>name</code> attribute of the subclass</li>\n<li><strong>qu_omega</strong> (int):\nthe <code>u_omega</code> attribute of the subclass</li>\n<li><strong>qu_mu</strong> (int):\nthe <code>u_mu</code> attribute of the subclass</li>\n<li><strong>qdescription</strong> (str):\na brief description of the subclass</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>CustomConst</strong> (class):\nthe custom subclass</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">qname</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">qu_omega</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">qu_mu</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">qdescription</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.define_func", "modulename": "geff.bgtypes", "qualname": "define_func", "kind": "function", "doc": "<p>Creates a subclass of <code>Func</code> with custom name, scaling, and argument signature.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>qname</strong> (str):\nthe <code>name</code> attribute of the subclass</li>\n<li><strong>qu_omega</strong> (int):\nthe <code>u_omega</code> attribute of the subclass</li>\n<li><strong>qu_mu</strong> (int):\nthe <code>u_mu</code> attribute of the subclass</li>\n<li><strong>qdtype</strong> (Numpy Data Type):\nthe <code>dtype</code> attribute of the subclass</li>\n<li><strong>qdescription</strong> (str):\na brief description of the subclass</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>CustomFunc</strong> (class):\nthe custom subclass</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>TypeError</strong>: if the data type is not a subtype of <code>numpy.floating</code></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">qname</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">func_args</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">Val</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">qu_omega</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">qu_mu</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">qdescription</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\tqdtype: numpy.dtype = &lt;class &#x27;numpy.float64&#x27;&gt;</span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.bgtypes.define_gauge", "modulename": "geff.bgtypes", "qualname": "define_gauge", "kind": "function", "doc": "<p>A class factory creating custom  <code>GaugeField</code> classes with new name, zero variables, and cutoff scale.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>qname</strong> (str):\nthe <code>name</code> attribute of the subclass</li>\n<li><strong>qzeros</strong> (list of Variable):\nthe <code>zeros</code> attribute of the new subclass</li>\n<li><strong>qcutoff</strong> (Variable):\nthe <code>cutoff</code> attribute of the new subclass</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>CustomGaugeField</strong> (class):\nthe custom subclass</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">qname</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">qzeros</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">Variable</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">qcutoff</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">Variable</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.gef", "modulename": "geff.gef", "kind": "module", "doc": "<p>This module defines the <code>BaseGEF</code> class and its class factory <code>compile_model</code>.</p>\n"}, {"fullname": "geff.gef.BaseGEF", "modulename": "geff.gef", "qualname": "BaseGEF", "kind": "class", "doc": "<p>This class defines the basic properties of a GEF model.</p>\n\n<p>Each GEF model contains a <code>GEFSolver</code> and a <code>ModeSolver</code> that are used to solve GEF equations with the <code>run</code> method.</p>\n\n<p>Instances of a GEF model can also be used to load data using <code>load_GEFdata</code>.\n Loading data this way creates a <code>BGSystem</code> which also knows the appropriate units, constants and functions for this model.</p>\n\n<p>The <code>BaseGEF</code> is a compiled version of <code>.models.pai</code>. To compile other models, use the class factory <code>compile_model</code>.</p>\n"}, {"fullname": "geff.gef.BaseGEF.__init__", "modulename": "geff.gef", "qualname": "BaseGEF.__init__", "kind": "function", "doc": "<p>Initialize the GEF from user-specified initial data, constants and functions.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kwargs</strong>: To access a list of kwargs for this model use <code>print_input</code>.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>KeyError</strong>: if a necessary input is missing.</li>\n<li><strong>TypeError</strong>: if the input is of the wrong type.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "geff.gef.BaseGEF.GEFSolver", "modulename": "geff.gef", "qualname": "BaseGEF.GEFSolver", "kind": "class", "doc": "<p>The solver used to solve the GEF equations in <code>run</code>.</p>\n", "bases": "geff.solver.BaseGEFSolver"}, {"fullname": "geff.gef.BaseGEF.ModeSolver", "modulename": "geff.gef", "qualname": "BaseGEF.ModeSolver", "kind": "class", "doc": "<p>The mode solver used for mode-by-mode cross checks.</p>\n", "bases": "geff.mbm.BaseModeSolver"}, {"fullname": "geff.gef.BaseGEF.define_units", "modulename": "geff.gef", "qualname": "BaseGEF.define_units", "kind": "function", "doc": "<p>Define how initial data is used to set the reference frequency, $\\omega$ and energy scale, $\\mu$.</p>\n\n<ul>\n<li>energy scale: $M_{\\rm P}$ in Planck units</li>\n<li>frequency scale: initial Hubble rate, $H_0$ (in Planck units)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">phi</span>, </span><span class=\"param\"><span class=\"n\">dphi</span>, </span><span class=\"param\"><span class=\"n\">V</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.gef.BaseGEF.print_input", "modulename": "geff.gef", "qualname": "BaseGEF.print_input", "kind": "function", "doc": "<p>Print the input required to initialize the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.gef.BaseGEF.pring_ingredients", "modulename": "geff.gef", "qualname": "BaseGEF.pring_ingredients", "kind": "function", "doc": "<p>Print a list of known variables, functions and constants for this model</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.gef.BaseGEF.run", "modulename": "geff.gef", "qualname": "BaseGEF.run", "kind": "function", "doc": "<p>Solve the ODE's of the GEF using <code>GEFSolver</code>. Cross check the solution using <code>ModeSolver</code>.</p>\n\n<p>The <code>GEFSolver</code> is initialized using the initial conditions defined by the class.\nIf the solver returns a successful solution, <code>ModeSolver.compute_spectrum</code> computes a gauge field spectrum\n to perform a mode-by-mode cross check (unless <code>nmodes=None</code>).\nIf the mode-by-mode cross check is a success, the solution is stored in the underlying <code>BGSystem</code> of the class.\nOtherwise, the <code>GEFSolver</code> tries to self correct using the gauge field spectrum. This is attempted for <code>mbm_attempts</code> or until successful.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ntr</strong> (int):\ninitial truncation number <code>GEFSolver.ntr</code></li>\n<li><strong>tend</strong> (float):\ninitial target time for <code>GEFSolver.tend</code></li>\n<li><strong>nmodes</strong> (int or None):\nthe number of modes computed by <code>ModeSolver</code>. If None, no cross-check is performed.</li>\n<li><strong>mbm_attempts</strong> (int):\nnumber of mode-by-mode self correction attempts</li>\n<li><strong>resume_mbm</strong> (bool):\nif <code>True</code> use <code>ModeSolver.update_spectrum</code> in case successive mode-by-mode comparisons are needed.</li>\n<li><strong>err_tol</strong> (float):\npassed to <code>mbm_crosscheck</code>.</li>\n<li><strong>err_thr</strong> (float):\npassed to <code>mbm_crosscheck</code>.</li>\n<li><strong>binning</strong> (int):\npassed to <code>mbm_crosscheck</code>.</li>\n<li><strong>integrator</strong> (str):\nintegrator for <code>mbm_crosscheck</code> ('simpson' is advised)</li>\n<li><strong>print_stats</strong> (bool):\nif <code>True</code>, a summary report is printed for the returned solution.</li>\n<li><strong>solver_kwargs</strong>: the <code>settings</code> of <code>GEFSolver</code> (see <code>GEFSolver.settings</code>)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>vals</strong> (BGSystem):\ncontains the background evolution obtained from <code>GEFSolver</code></li>\n<li><strong>spec</strong> (GaugeSpec or None):\nthe result of <code>ModeSolver.compute_spectrum</code></li>\n<li><strong>sol</strong>: the full result of <code>GEFSolver.compute_GEF_solution</code></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>RuntimeError</strong>: if no successful solution was obtained.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">ntr</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">150</span>,</span><span class=\"param\">\t<span class=\"n\">tend</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">120</span>,</span><span class=\"param\">\t<span class=\"n\">nmodes</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">500</span>,</span><span class=\"param\">\t<span class=\"n\">mbm_attempts</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">resume_mbm</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">err_tol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">err_thr</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.025</span>,</span><span class=\"param\">\t<span class=\"n\">binning</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">integrator</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;simpson&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">print_stats</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">solver_kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.gef.BaseGEF.mbm_crosscheck", "modulename": "geff.gef", "qualname": "BaseGEF.mbm_crosscheck", "kind": "function", "doc": "<p>Estimate the error of a GEF solution using <code>.mbm.GaugeSpec.estimate_GEF_error</code>.</p>\n\n<p>If either the RMS error or the final error exceeds <code>err_tol</code>, the solution is rejected.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vals</strong> (BGSystem):\ncontains the GEF solution.</li>\n<li><strong>err_tol</strong> (float):\nthe tolerance on the RMS and final error.</li>\n<li><strong>err_thr</strong> (float):\npassed to <code>estimate_GEF_error</code>.</li>\n<li><strong>binning</strong> (int):\npassed to <code>estimate_GEF_error</code>.</li>\n<li><strong>integratorkwargs:</strong>: passed to kwargs of <code>estimate_GEF_error</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>agreement</strong> (bool):\nindicates if the solution is accepted or rejected.</li>\n<li><strong>reinit_slice</strong> (SpecSlice):\nthe spectrum with which the GEF solver is re-initialized.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spec</span>,</span><span class=\"param\">\t<span class=\"n\">vals</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span>,</span><span class=\"param\">\t<span class=\"n\">err_tol</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">err_thr</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">binning</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">integrator_kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.gef.BaseGEF.load_GEFdata", "modulename": "geff.gef", "qualname": "BaseGEF.load_GEFdata", "kind": "function", "doc": "<p>Load data and return a BGSystem with the results.</p>\n\n<p>Note, data is always loaded assuming numerical units.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (None or str):\nPath to load data from</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>FileNotFoundError</strong>: if no file is found at <code>path</code>.</li>\n<li><strong>AttributeError</strong>: if the file contains a column labeled by a key which does not match any GEF-value name.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.gef.compile_model", "modulename": "geff.gef", "qualname": "compile_model", "kind": "function", "doc": "<p>Define a custom subclass of BaseGEF adapted to a new GEF model.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>modelname</strong> (str):\nThe name of the GEF model or a full dotted import path (e.g., \"path.to.module\").</li>\n<li><strong>settings</strong> (dict):\na dictionary of settings used by the model</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>CustomGEF</strong>: a custom subclass of BaseGEF</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">modelname</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">settings</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.gef.ModelError", "modulename": "geff.gef", "qualname": "ModelError", "kind": "class", "doc": "<p>Exception for errors when compiling a GEF model.</p>\n", "bases": "builtins.Exception"}, {"fullname": "geff.mbm", "modulename": "geff.mbm", "kind": "module", "doc": "<p>This module is used to compute and analyse spectra of gauge-field modes.</p>\n\n<p>Throughout this module, any gauge-field mode functions are represented by dimensionless variables</p>\n\n<p>$$\\sqrt{2k} A_\\lambda(t,k), \\quad \\sqrt{\\frac{2}{k}}\\, a(t)\\dot{A}_\\lambda(k, t), \\quad \\lambda = \\pm 1$$</p>\n\n<p>where $A_\\lambda(t,k)$ are the mode functions of helicity $\\lambda$ and momentum $k$ for a canonically quantized Abelian gauge-field $A_\\mu(t, {\\bf x})$ in Coulomb &amp; Weyl gauge.\nThe momentum variables $k$ are always returned in numerical units, i.e., $\\bar{k} = k/\\omega$.</p>\n\n<p>The class <code>BaseModeSolver</code> is designed to solve the second order mode equation</p>\n\n<p>$$\\ddot{A}_\\lambda(t,k) + P_\\lambda(t,k)\\dot{A}_\\lambda(t,k) + Q_\\lambda(t,k)A_\\lambda(t,k) = 0 \\, .$$</p>\n\n<p>The base class in particular is set to solve the mode equation of pure axion inflation,\n$$P_\\lambda(t,k) = H \\, \\qquad Q_\\lambda(t,k) = \\left(\\frac{k}{a}\\right)^2  - 2\\lambda \\left(\\frac{k}{a}\\right) \\xi H \\, ,$$\nwith Hubble rate $H$, scale factor $a$ and instability parameter $\\xi$.</p>\n\n<p>To create a mode solver with custom values for $P(t,k)$ and $Q(t,k)$, use the class factory <code>ModeSolver</code>.</p>\n\n<p>The module also contains a class <code>GaugeSpec</code> designed for directly working on the spectrum of modes $A_\\lambda(t,k)$.\nIn particular, it is used to integrate the spectrum to obtain the quantities</p>\n\n<p>$$ \\mathcal{F}_\\mathcal{E}^{(n)}(t) = \\int\\limits_{0}^{k_{{\\rm UV}}(t)}\\frac{{\\rm d} k}{k} \\frac{a^2 k^{n+3}}{2 \\pi^2 k_{{\\rm UV}}^{n+4}}  \\sum_{\\lambda}\\lambda^n |\\dot{A}_\\lambda(t,k)|^2\\,,$$\n$$ \\mathcal{F}_\\mathcal{G}^{(n)}(t) = \\int\\limits_{0}^{k_{{\\rm UV}}(t)}\\frac{{\\rm d} k}{k} \\frac{a k^{n+4}}{2 \\pi^2 k_{{\\rm UV}}^{n+4}}\\sum_{\\lambda}\\lambda^{n+1} \\operatorname{Re}[\\dot{A}_\\lambda(t,k)A_\\lambda^*(t,k)]\\,,$$\n$$ \\mathcal{F}_\\mathcal{B}^{(n)}(t) = \\int\\limits_{0}^{k_{{\\rm UV}}(t)}\\frac{{\\rm d} k}{k} \\frac{k^{n+5}}{2 \\pi^{2}k_{{\\rm UV}}^{n+4}} \\sum_{\\lambda}\\lambda^n |A_\\lambda(t,k)|^2\\,,$$</p>\n\n<p>which may be used to estimate the error of a GEF solution.</p>\n"}, {"fullname": "geff.mbm.GaugeSpec", "modulename": "geff.mbm", "qualname": "GaugeSpec", "kind": "class", "doc": "<p>A class representing a spectrum of gauge-field modes as a function of time.</p>\n\n<p>This class inherits from <code>dict</code> and needs the following keys:<br />\n't', 'N', 'k', 'Ap', 'dAp', 'Am', 'dAm'</p>\n\n<p>All quantities are represented in numerical units (see <code>GEFF.bgtypes.BGSystem</code>).</p>\n\n<p>The spectrum can be evaluated at certain times $t$ or for certain momenta $k$ by using <code>tslice</code> and <code>kslice</code>\nFurthermore, the spectrum contained in the object can be integrated to compute gauge-field expectation values.\n The result can be used to estimate the error of a GEF run.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>t</strong> (NDArray):\nthe cosmic time coordinates $t$ of the spectrum</li>\n<li><strong>N</strong> (NDArray):\nthe $e$-folds as a function of cosmic time, $N(t)$</li>\n<li><strong>k</strong> (NDarray):\nthe momenta $k$ at which the spectrum is evaluated</li>\n<li><strong>Ap, Am</strong> (NDarray):\nthe mode functions, $\\sqrt{2 k} A_\\pm(k, t)$</li>\n<li><strong>dAp, dAm</strong> (NDarray):\nthe mode-function derivatives, $\\sqrt{2/k} \\, e^{N(t)}\\dot{A}_\\pm(k, t)$</li>\n</ul>\n", "bases": "builtins.dict"}, {"fullname": "geff.mbm.GaugeSpec.__init__", "modulename": "geff.mbm", "qualname": "GaugeSpec.__init__", "kind": "function", "doc": "<p>Initialise the spectrum from a dictionary.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>in_dict</strong> (dict):\ndictionary with keys <code>'t'</code>, <code>'N'</code>, <code>'k'</code>, <code>'Ap'</code>, <code>'dAp'</code>, <code>'Am'</code>, <code>'dAm'</code></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>KeyError</strong>: if one of the necessary keys is missing.</li>\n<li><strong>ValueError</strong>: if <code>len(in_dict['t']) != len(in_dict['N'])</code> or if\n<code>in_dict['X']).shape != (len(in_dict['k']),len(in_dict['t']))</code> for <code>'X'</code> in <code>['Ap', 'dAp', 'Am', 'dAm']</code>.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">in_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span>)</span>"}, {"fullname": "geff.mbm.GaugeSpec.read_spec", "modulename": "geff.mbm", "qualname": "GaugeSpec.read_spec", "kind": "function", "doc": "<p>Initialise the class from a file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\npath to the data</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spec</strong> (GaugeSpec):\nthe imported spectrum</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.GaugeSpec.save_spec", "modulename": "geff.mbm", "qualname": "GaugeSpec.save_spec", "kind": "function", "doc": "<p>Store the spectrum in a file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>path</strong> (str):\npath to the data</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.GaugeSpec.get_dim", "modulename": "geff.mbm", "qualname": "GaugeSpec.get_dim", "kind": "function", "doc": "<p>Get the number of time coordinates and momenta stored in the spectrum.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dict</strong>: a dictionary encoding the spectrum's shape</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.GaugeSpec.tslice", "modulename": "geff.mbm", "qualname": "GaugeSpec.tslice", "kind": "function", "doc": "<p>Evaluate the spectrum at time <code>self['t'][ind]</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ind</strong> (int):\nthe temporal index</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spec_slice</strong> (SpecSlice):\nthe spectrum at time <code>self['t'][ind]</code></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ind</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.GaugeSpec.kslice", "modulename": "geff.mbm", "qualname": "GaugeSpec.kslice", "kind": "function", "doc": "<p>Obtain the time evolution for the momentum <code>self['k'][ind]</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ind</strong> (int):\nthe momentum index.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spec_slice</strong> (dict):\na dictionary with keys like <code>self</code></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ind</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.GaugeSpec.integrate", "modulename": "geff.mbm", "qualname": "GaugeSpec.integrate", "kind": "function", "doc": "<p>Compute the three integrals $\\mathcal{F}_\\mathcal{X}^{(n)}(t)$ for $\\mathcal{X} = \\mathcal{E}, \\mathcal{B},\\mathcal{G}$ for fixed $n$ and each time $t$ in the spectrum.</p>\n\n<p>If the time coordinates stored in <code>BG</code> do not match those stored in the spectrum, $k_{\\rm UV}(t)$ is evaluated using interpolation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>BG</strong> (BGSystem):\na system containing the UV cut-off, $k_{\\rm UV}(t)$</li>\n<li><strong>n</strong> (int):\nthe integer $n$</li>\n<li><strong>cutoff</strong> (str):\nthe name under which the UV-cutoff is stored in <code>BG</code></li>\n<li><strong>**IntegratorKwargs</strong> (kwargs):\npassed to <code>SpecSlice.integrate_slice</code></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>FMbM</strong> (NDArray):\n$\\mathcal{F}_\\mathcal{E}^{(n)}(t)$, $\\mathcal{F}_\\mathcal{B}^{(n)}(t)$, $\\mathcal{F}_\\mathcal{B}^{(n)}(t)$ stored in a shape (N, 3, 2).\nThe first index corresponds to time $t$, the second index to $\\mathcal{X}$, the third index is the integral result (at 0) and its error (at 1).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">BG</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span>,</span><span class=\"param\">\t<span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">cutoff</span><span class=\"o\">=</span><span class=\"s1\">&#39;kh&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">IntegratorKwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.GaugeSpec.estimate_GEF_error", "modulename": "geff.mbm", "qualname": "GaugeSpec.estimate_GEF_error", "kind": "function", "doc": "<p>Estimate the relative deviation between a GEF solution and the mode spectrum by computing</p>\n\n<p>$$\\varepsilon_\\mathcal{X} = \\left|1 - \\frac{\\big(\\mathcal{F}_\\mathcal{X}^{(0)}\\big)_{\\rm MbM}}{\\big(\\mathcal{F}_\\mathcal{X}^{(0)}\\big)_{\\rm GEF}}\\right|$$</p>\n\n<p>for $\\mathcal{X} = \\mathcal{E},\\,\\mathcal{B},\\,\\mathcal{G}$. Here, $\\big(\\mathcal{F}_\\mathcal{X}^{(0)}\\big)_{\\rm MbM}$ are the integrals computed by <code>integrate</code>, \n$\\big(\\mathcal{F}_\\mathcal{X}^{(0)}\\big)_{\\rm GEF}$ refer to the same quantity in <code>BG</code>.\nIf the time coordinate of <code>BG</code> does not align with the spectrum, its values are interpolated.</p>\n\n<p>Because $k_{\\rm UV}(t)$ increases monotonically, the spectrum contains only few relevant modes $k &lt; k_{\\rm UV}(t)$ at early times.\nThis poses a problem for the numerical integration of $\\big(\\mathcal{F}_\\mathcal{X}^{(0)}\\big)_{\\rm MbM}$.\nTo avoid claiming a disagreement between $\\big(\\mathcal{F}_\\mathcal{X}^{(0)}\\big)_{\\rm MbM}$ and $\\big(\\mathcal{F}_\\mathcal{X}^{(0)}\\big)_{\\rm GEF}$ due to this effect,\nerrors with $\\varepsilon_\\mathcal{X} &gt; \\varepsilon_{\\rm thr}$ are discarded until the first time when $\\varepsilon_\\mathcal{X} &lt; \\varepsilon_{\\rm thr}$.</p>\n\n<p>As the integration result fluctuates significantly for few momenta $k &lt; k_{\\rm UV}(t)$ when using <code>simpson</code>,\nthe errors can be binned by setting <code>binning</code>. The reported error is the average over a bin of width $(t_{i}, t_{i+\\Delta})$ with $\\Delta$ set by <code>binning</code>.\nThis binned error is then associated to the time $(t_{i} + t_{i+\\Delta})/2$. For <code>quad</code>, <code>binning</code> can also be set to <code>None</code>.\nFor details on the integration methods <code>simpson</code> and <code>quad</code>, see <code>SpecSlice.integrate_slice</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>BG</strong> (BGSystem):\nthe system where $\\big(\\mathcal{F}_\\mathcal{X}^{(0)}\\big)_{\\rm GEF}$ are stored</li>\n<li><strong>references</strong> (list of str):\nthe names where $(k_{\\rm UV}/a)^4 \\big(\\mathcal{F}_\\mathcal{X}^{(0)}\\big)_{\\rm GEF}$ are stored in <code>BG</code></li>\n<li><strong>cutoff</strong> (str):\nthe name where the UV-cutoff, $k_{\\rm UV}$, is stored in <code>BG</code></li>\n<li><strong>err_thr</strong> (float):\nthe error threshold $\\varepsilon_{\\rm thr}$</li>\n<li><strong>binning</strong> (int or None):\nthe bin size $\\Delta$ (no binning if <code>None</code>)</li>\n<li><strong>verbose</strong> (bool):\nif <code>True</code>, print a summary of the errors</li>\n<li><strong>**IntegratorKwargs</strong> (kwargs):\npassed to <code>SpecSlice.integrate_slice</code></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>errs</strong> (list of NDArray):\na list of the binned errors with entries $[\\varepsilon_\\mathcal{E},\\varepsilon_\\mathcal{B}, \\varepsilon_\\mathcal{G}]$</li>\n<li><strong>terr</strong> (NDArray):\nthe time coordinates corresponding to <code>errs</code></li>\n<li><strong>og_errs</strong> (list of NDArray):\nthe same as <code>errs</code> but without binning</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">BG</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span>,</span><span class=\"param\">\t<span class=\"n\">references</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;E&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;B&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;G&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">cutoff</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;kh&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">err_thr</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.025</span>,</span><span class=\"param\">\t<span class=\"n\">binning</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">IntegratorKwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">list</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.GaugeSpec.merge_spectra", "modulename": "geff.mbm", "qualname": "GaugeSpec.merge_spectra", "kind": "function", "doc": "<p>Combine two spectra with the same momenta $k$ but unequal times $t$.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spec</strong> (GaugeSpec):\nthe second spectrum</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AssertionError</strong>: if the momenta $k$ do not match up.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spec</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">mbm</span><span class=\"o\">.</span><span class=\"n\">GaugeSpec</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.GaugeSpec.add_momenta", "modulename": "geff.mbm", "qualname": "GaugeSpec.add_momenta", "kind": "function", "doc": "<p>Combine two spectra with the same times $t$ but unequal momenta $k$.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spec</strong> (GaugeSpec):\nthe second spectrum</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AssertionError</strong>: if the times $t$ do not match up.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">spec</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">mbm</span><span class=\"o\">.</span><span class=\"n\">GaugeSpec</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.GaugeSpec.remove_momenta", "modulename": "geff.mbm", "qualname": "GaugeSpec.remove_momenta", "kind": "function", "doc": "<p>Remove the spectrum at momentum <code>self[\"k\"][ind]</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>ind</strong> (int):\nthe index at which to remove the spectrum entry</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ind</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.SpecSlice", "modulename": "geff.mbm", "qualname": "SpecSlice", "kind": "class", "doc": "<p>A class representing a spectrum of gauge-field modes at a time $t$.</p>\n\n<p>Instances of this class are created by <code>GaugeSpec.tslice</code>. The main purpose of this class is to integrate the spectrum at time $t$ using <code>integrate_slice</code>.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>t</strong> (NDArray):\nthe cosmic time coordinates $t$ of the spectrum</li>\n<li><strong>N</strong> (NDArray):\nthe $e$-folds as a function of cosmic time, $N(t)$</li>\n<li><strong>k</strong> (NDarray):\nthe momenta $k$ at which the spectrum is evaluated</li>\n<li><strong>Ap, Am</strong> (NDarray):\nthe mode functions, $\\sqrt{2 k} A_\\pm(k, t)$</li>\n<li><strong>dAp, dAm</strong> (NDarray):\nthe mode-function derivatives, $\\sqrt{2/k} \\, e^{N(t)}\\dot{A}_\\pm(k, t)$</li>\n</ul>\n", "bases": "builtins.dict"}, {"fullname": "geff.mbm.SpecSlice.integrate_slice", "modulename": "geff.mbm", "qualname": "SpecSlice.integrate_slice", "kind": "function", "doc": "<p>Compute the three integrals $\\mathcal{F}_\\mathcal{X}^{(n)}(t)$ for $\\mathcal{X} = \\mathcal{E}, \\mathcal{B},\\mathcal{G}$ for a fixed time $t$ and index $n$.</p>\n\n<p>The integrals can either be computed directly using <code>simpson</code> or <code>quad</code> from <code>scipy.interpolate</code>. When using <code>quad</code> the data for $\\sqrt{2 k} A_\\pm(k, t)$, $\\sqrt{2/k} \\, e^{N(t)}\\dot{A}_\\pm(k, t)$\n  are interpolated to obtain smooth functions. To avoid this, it is recommended to use <code>simpson</code>.</p>\n\n<p>When using <code>simpson</code>, the integral is only computed if $m &gt; m_{\\rm thr}$ momenta $k_i$ satisfy $k &lt; k_{\\rm UV}$. Otherwise, the integral is set to zero.</p>\n\n<p>When using <code>quad</code>, the absolute and relative tolerances of the integrator are set by <code>epsabs</code> and <code>epsrel</code>. The interpolation method is defined by <code>interpolator</code>.\nCurrently, only <code>CubicSpline</code> and <code>PchipInterpolator</code> from <code>scipy.interpolate</code> are supported. The later is preferred as interpolating the oscillatory mode functions can be subject to \"overshooting\".\nSee <a href=\"https://docs.scipy.org/doc/scipy/tutorial/interpolate/1D.html#tutorial-interpolate-1dsection\">scipy's tutorial for 1-D interpolation</a> for more details.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n</strong> (int):\nthe integer $n$ in $\\mathcal{F}_\\mathcal{X}^{(n)}(t)$ for $\\mathcal{X} = \\mathcal{E}, \\mathcal{B},\\mathcal{G}$</li>\n<li><strong>integrator</strong> (str):\nset the integration method to <code>simpson</code> or <code>quad</code></li>\n<li><strong>modethr</strong> (int):\nset $m_{\\rm thr}$ when using <code>simpson</code></li>\n<li><strong>epsabs</strong> (float):\nthe absolute tolerance of <code>quad</code></li>\n<li><strong>epsrel</strong> (float):\nthe relative tolerance of <code>quad</code></li>\n<li><strong>interpolator</strong>: the interpolator used to get smooth functions for <code>quad</code></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>FMbM</strong> (NDArray):\ncontains [$\\mathcal{F}_\\mathcal{E}^{(n)}(t)$, $\\mathcal{F}_\\mathcal{B}^{(n)}(t)$, $\\mathcal{F}_\\mathcal{B}^{(n)}(t)$] and the error estimated by <code>quad</code>.\n When using <code>simpson</code> the error is a dummy output. The shape of the result is (3, 2) with the second index indicating the integral (at 0), or the error (at 1).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">integrator</span><span class=\"o\">=</span><span class=\"s1\">&#39;simpson&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">modethr</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">epsabs</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-20</span>,</span><span class=\"param\">\t<span class=\"n\">epsrel</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0001</span>,</span><span class=\"param\">\tinterpolator=&lt;class &#x27;scipy.interpolate._cubic.PchipInterpolator&#x27;&gt;</span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.BaseModeSolver", "modulename": "geff.mbm", "qualname": "BaseModeSolver", "kind": "class", "doc": "<p>A class used to compute gauge-field modes evolving on a time-dependent background.</p>\n\n<p>This class is used to evolve the gauge-field modes $A_\\pm(t,k)$ as defined by <code>mode_equation</code>.\n To do so, the evolution of the time-dependent background is obtained from a GEF solution.</p>\n\n<p>The modes are initialized deep inside the Bunch&ndash;Davies vacuum as given by <code>initialise_in_bd</code>. \nNumerically, the initialization time is implicitly defined by the condition $k = 10^{5/2} k_{\\rm UV}(t_{\\rm ini})$, with $k_{\\rm UV}(t)$ obtained from the GEF solution.\nAt times $t &lt; t_{\\rm ini}$ the mode is assumed to be in Bunch&ndash;Davies.</p>\n\n<p>The mode equations are solved with an explicit Runge&ndash;Kutta of order 5(4), which is implemented in <code>scipy.integrate.solve_ivp</code>.</p>\n\n<p>For creating a custom subclass of <code>BaseModeSolver</code> with user-specified  mode equation and initial conditions, you can use the class factory <code>ModeSolver</code>.</p>\n"}, {"fullname": "geff.mbm.BaseModeSolver.__init__", "modulename": "geff.mbm", "qualname": "BaseModeSolver.__init__", "kind": "function", "doc": "<p>Import the evolution of the background dynamics to configure the solver.</p>\n\n<p>All values in the BGSystem are treated in numerical units.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sys</strong> (BGSystem):\ndescribes the background evolution</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>KeyError:</strong>: if <code>sys</code> is missing a <code>Val</code> or <code>Func</code> object from <code>necessary_keys</code></li>\n<li><strong>ValueError:</strong>: if the keys in <code>necessary_keys</code> are not <code>Val</code> or <code>Func</code> objects.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sys</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span>)</span>"}, {"fullname": "geff.mbm.BaseModeSolver.cutoff", "modulename": "geff.mbm", "qualname": "BaseModeSolver.cutoff", "kind": "variable", "doc": "<p>The name of $k_{\\rm UV}(t)$ in the GEF solution.</p>\n", "annotation": ": ClassVar[str]", "default_value": "&#x27;kh&#x27;"}, {"fullname": "geff.mbm.BaseModeSolver.atol", "modulename": "geff.mbm", "qualname": "BaseModeSolver.atol", "kind": "variable", "doc": "<p>The default absolute tolerance used in <code>scipy.integrate.solve_ivp</code></p>\n", "annotation": ": ClassVar[float]", "default_value": "0.001"}, {"fullname": "geff.mbm.BaseModeSolver.necessary_keys", "modulename": "geff.mbm", "qualname": "BaseModeSolver.necessary_keys", "kind": "variable", "doc": "<p>The class expects these attributes in the <code>.bgtypes.BGSystem</code> passed on initialisation.</p>\n", "annotation": ": ClassVar[set]", "default_value": "[&#x27;t&#x27;, &#x27;N&#x27;, &#x27;a&#x27;, &#x27;H&#x27;, &#x27;xi&#x27;, &#x27;kh&#x27;]"}, {"fullname": "geff.mbm.BaseModeSolver.mode_equation", "modulename": "geff.mbm", "qualname": "BaseModeSolver.mode_equation", "kind": "function", "doc": "<p>Mode equation for pure axion inflation:</p>\n\n<p>$$\\ddot{A}_\\lambda(t,k) + H \\dot{A}_\\lambda(t,k) + \\left[\\left(\\frac{k}{a}\\right)^2  - 2\\lambda \\left(\\frac{k}{a}\\right) \\xi H \\right]A_\\lambda(t,k) = 0 \\, .$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ncosmic time $t$</li>\n<li><strong>y</strong> (NDArray):\n$\\sqrt{2k} A_\\lambda(t_{\\rm init},k)$ and $a\\sqrt{2/k} \\dot{A}_\\lambda(t_{\\rm init},k)$</li>\n<li><strong>k</strong> (float):\ncomoving momentum $k$</li>\n<li><strong>a</strong> (Callable):\nscale factor as function of time, $a(t)$</li>\n<li><strong>xi</strong> (Callable):\ninstability parameter as function of time, $\\xi(t)$</li>\n<li><strong>H</strong> (Callable):\nHubble rate as function of time, $H(t)$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dydt</strong> (array):\nan array of time derivatives of y</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">xi</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.BaseModeSolver.initialise_in_bd", "modulename": "geff.mbm", "qualname": "BaseModeSolver.initialise_in_bd", "kind": "function", "doc": "<p>Returns gauge-field modes in Bunch&ndash;Davies vacuum:</p>\n\n<p>$$A_\\lambda(k,t) \\sim \\frac{1}{\\sqrt{2k}}exp{(-i \\eta(t) k)}\\, , \\qquad -\\eta(t) k \\gg 1 \\, .$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime of initialisation $t_{\\rm init}$</li>\n<li><strong>k</strong> (float):\ncomoving momentum $k$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>y</strong> (NDArray):\n$\\sqrt{2k} A_\\lambda(t_{\\rm init},k)$ and $a\\sqrt{2/k} \\dot{A}_\\lambda(t_{\\rm init},k)$ in Bunch&ndash;Davies</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.BaseModeSolver.compute_spectrum", "modulename": "geff.mbm", "qualname": "BaseModeSolver.compute_spectrum", "kind": "function", "doc": "<p>Evolve a gauge-field spectrum from Bunch-Davies initial conditions.</p>\n\n<p>Evolve the mode functions $A_\\lambda(t,k)$ and its derivative in time for $n$ modes between $k_{\\rm UV}(t_{\\rm min})$ and $k_{\\rm UV}(t_{\\rm max})$.\nThe $n$ evolved modes are more densly spaced when $\\log k_{\\rm UV}(t)$ increases more slowly to ensure a higher density of modes\ncrossing the horizon when backreaction effects are relevant.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>nvals</strong> (int):\nThe number of modes $n$</li>\n<li><strong>t_interval</strong> (tuple or None):\nset $t_{\\rm min}$ and $t_{\\rm max}$. If None, $t_{\\rm min}$ is given by $10^4 k_{\\rm UV}(t_{min}) = k_{\\rm UV}(0)$ and $t_{\\rm max} = \\max t$.</li>\n<li><strong>**SolverKwargs</strong> (kwargs):\ntolerance parameters<code>atol</code> and <code>rtol</code> passed to <code>solve_ivp</code> (default: <code>atol=self.atol</code>, <code>rtol=1e-5</code>)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spec</strong> (GaugeSpec):\nthe gauge-field spectrum</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">nvals</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">t_interval</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">SolverKwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">mbm</span><span class=\"o\">.</span><span class=\"n\">GaugeSpec</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.BaseModeSolver.update_spectrum", "modulename": "geff.mbm", "qualname": "BaseModeSolver.update_spectrum", "kind": "function", "doc": "<p>Update an existing gauge-field spectrum starting from $t_{\\rm start}$</p>\n\n<p>Starting from the modes stored in <code>GaugeSpec</code>, the function re-evaluates the evolution starting from $t_{\\rm start}$.\nAdditional gauge-field modes are evolved starting from Bunch&ndash;Davies to account for new modes crossing the horizon\n  at times beyond the original range covered by the input spectrum.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>spec</strong> (GaugeSpec):\nthe spectrum which is to be updated</li>\n<li><strong>tstart</strong> (float):\nthe starting time $t_{\\rm start}$</li>\n<li><strong>**SolverKwargs</strong> (kwargs):\nas in <code>compute_spectrum</code></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>spec</strong> (GaugeSpec):\nthe updated gauge-field spectrum</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">spec</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">mbm</span><span class=\"o\">.</span><span class=\"n\">GaugeSpec</span>,</span><span class=\"param\">\t<span class=\"n\">tstart</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">SolverKwargs</span></span><span class=\"return-annotation\">) -> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">mbm</span><span class=\"o\">.</span><span class=\"n\">GaugeSpec</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.mbm.ModeSolver", "modulename": "geff.mbm", "qualname": "ModeSolver", "kind": "function", "doc": "<p>Create a subclass of <code>BaseModeSolver</code> with custom mode equation and initial conditions.</p>\n\n<p>In case your GEF model does not follow the pre-defined gauge-field mode equation <code>BaseModeSolver.mode_equation</code>,\nor initial conditions, <code>BaseModeSolver.initialise_in_bd</code> this method  defines a new subclass with\n these methods replaced by <code>new_mode_eq</code> and <code>new_bd_init</code>.</p>\n\n<p>The method <code>new_mode_eq</code> needs to obey the following rules:</p>\n\n<ol>\n<li>The call signature is <code>f(t,y,k,**kwargs)</code></li>\n<li>The arguments <code>t</code> / <code>k</code> expect floats representing time / momentum</li>\n<li>The argument <code>y</code> expects a <code>numpy.ndarrray</code> of shape (8,) with indices\n<ul>\n<li>0 &amp; 2 / 4 &amp; 6: real &amp; imaginary part of $\\sqrt{2k} A_\\lambda(t,k)$ for $\\lambda = 1 \\, / -1$</li>\n<li>1 &amp; 3 / 5 &amp; 7: real &amp; imaginary part of $\\sqrt{2/k}\\, a \\dot{A}_\\lambda(t,k)$ for $\\lambda = 1 \\, / -1$</li>\n</ul></li>\n<li>The kwargs are functions of the argument <code>t</code>.</li>\n<li>The return is the time derivative of <code>y</code></li>\n</ol>\n\n<p>The method <code>new_bd_init</code> needs to obey the following rules:</p>\n\n<ol>\n<li>The call signature is <code>f(t,k,**kwargs)</code></li>\n<li>The arguments <code>t</code> / <code>k</code> expect floats representing time / momentum</li>\n<li>The kwargs are functions of the argument <code>t</code>.</li>\n<li>The return is a <code>numpy.ndarrray</code> of shape (8,)  with indices\n<ul>\n<li>0 &amp; 2 / 4 &amp; 6: real &amp; imaginary part of $\\sqrt{2k} A_\\lambda(t_{\\rm init},k)$ for $\\lambda = 1 \\, / -1$</li>\n<li>1 &amp; 3 / 5 &amp; 7: real &amp; imaginary part of $\\sqrt{2/k}\\, a \\dot{A}_\\lambda(t_{\\rm init},k)$ for $\\lambda = 1 \\, / -1$</li>\n</ul></li>\n</ol>\n\n<p>The lists <code>ode_keys</code> and <code>init_keys</code> are handled as follows:</p>\n\n<ul>\n<li><code>ode_keys</code> and <code>init_keys</code> need to contain the keys associated to the respective kwargs of <code>new_mode_eq</code> and <code>new_bd_init</code>.</li>\n<li>These keys correspond to names of <code>GEFF.bgtypes.Val</code> objects belonging to a <code>GEFF.bgtypes.BGSystem</code> passed to the class upon initialisation.\nThe respective <code>Val</code> objects are interpolated to obtain functions of time. \nThese functions are then passed to to the corresponding keyword arguments of <code>new_mode_eq</code>  and <code>new_bd_init</code>.</li>\n<li><code>ode_keys</code> and <code>init_keys</code> are added to <code>BaseModeSolver.necessary_keys</code> of the new subclass.</li>\n</ul>\n\n<p>The <code>BaseModeSolver.cutoff</code> and <code>BaseModeSolver.atol</code> attributes can also be adjusted.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>new_mode_eq</strong> (Callable):\na new mode equation</li>\n<li><strong>ode_keys</strong> (list of str):\nthe non-standard keywords of <code>new_mode_eq</code></li>\n<li><strong>new_bd_init</strong> (Callable):\na new mode bd initial condition</li>\n<li><strong>init_keys</strong> (list of str):\nthe non-standard keywords of <code>new_bd_init</code></li>\n<li><strong>new_cutoff</strong> (str):\nthe new <code>cutoff</code> attribute of the subclass</li>\n<li><strong>default_atol</strong> (float):\nthe default absolute tolerance used by the subclass</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>NewModeSolver</strong>: the newly defined subclass of <code>BaseModeSolver</code></li>\n</ul>\n\n<h6 id=\"example\">Example</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>    <span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">numpy</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">np</span>\n    <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">GEFF.bgtypes</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">BGSystem</span><span class=\"p\">,</span> <span class=\"n\">define_var</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">kh</span>\n\n    <span class=\"c1\"># Define a new mode equation:</span>\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">custom_mode_eq</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">Y</span><span class=\"p\">):</span>\n        <span class=\"c1\">#create a return array of the right shape</span>\n        <span class=\"n\">dydt</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones_like</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n\n        <span class=\"c1\">#compute real-part time derivatives for positive modes</span>\n        <span class=\"n\">dydt</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">k</span> <span class=\"o\">/</span> <span class=\"n\">a</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">y</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"c1\"># a is a function of t.</span>\n        <span class=\"n\">dydt</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"n\">Y</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"c1\"># X and Y are functions of t.</span>\n\n        <span class=\"c1\">#compute imag-part time derivatives for positive modes</span>\n        <span class=\"o\">...</span>\n\n        <span class=\"c1\">#compute real-part time derivatives for negative modes</span>\n        <span class=\"o\">...</span>\n        <span class=\"o\">...</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">dydt</span>\n\n    <span class=\"c1\"># Define a new initial condition for the modes:</span>\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">custom_bd_init</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">):</span>\n        <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">alpha</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"o\">...</span><span class=\"p\">])</span> <span class=\"c1\"># alpha is a function of t.</span>\n        <span class=\"k\">return</span> <span class=\"n\">y</span>\n\n    <span class=\"c1\"># the kwargs of custom_mode_eq are &#39;a&#39;, &#39;X&#39; and &#39;Y&#39;:</span>\n    <span class=\"n\">custom_ode_keys</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;X&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Y&#39;</span><span class=\"p\">]</span>\n\n    <span class=\"c1\"># the kwarg of custom_bd_init is &#39;alpha&#39;:</span>\n    <span class=\"n\">custom_init_keys</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;alpha&#39;</span><span class=\"p\">]</span>\n\n    <span class=\"c1\"># Define the custom mode solver using the class factory:</span>\n    <span class=\"n\">CustomModeSolver</span> <span class=\"o\">=</span> <span class=\"n\">ModeSolver</span><span class=\"p\">(</span><span class=\"n\">custom_mode_eq</span><span class=\"p\">,</span> <span class=\"n\">custom_ode_keys</span><span class=\"p\">,</span>\n                                     <span class=\"n\">custom_bd_init</span><span class=\"p\">,</span> <span class=\"n\">custom_init_keys</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># To initialise CustomModeSolver we need a BGSystem. </span>\n    <span class=\"c1\"># Its Variables need to have the right names however:</span>\n    <span class=\"c1\"># The default: &#39;t&#39;, &#39;N&#39;, &#39;kh&#39; were loaded from GEFF.bgtypes</span>\n\n    <span class=\"c1\"># Because of custom_mode_eq we also need &#39;a&#39;, &#39;X&#39;, &#39;Y&#39;</span>\n    <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">define_var</span><span class=\"p\">(</span><span class=\"s2\">&quot;a&quot;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">define_var</span><span class=\"p\">(</span><span class=\"s2\">&quot;X&quot;</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">Y</span> <span class=\"o\">=</span> <span class=\"n\">define_var</span><span class=\"p\">(</span><span class=\"s2\">&quot;Y&quot;</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># For custom_bd_init we need &#39;alpha&#39;</span>\n    <span class=\"n\">alpha</span> <span class=\"o\">=</span> <span class=\"n\">define_var</span><span class=\"p\">(</span><span class=\"s2\">&quot;alpha&quot;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># When in doubt, consult necessary_keys:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">CustomModeSolver</span><span class=\"o\">.</span><span class=\"n\">necessary_keys</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># We create the BGSystem and initialise all its values:</span>\n    <span class=\"n\">sys</span> <span class=\"o\">=</span> <span class=\"n\">BGSystem</span><span class=\"p\">({</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">kh</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">Y</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"p\">},</span> <span class=\"mf\">1e-6</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">initialise</span><span class=\"p\">(</span><span class=\"s2\">&quot;t&quot;</span><span class=\"p\">)(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n    <span class=\"o\">...</span>\n\n    <span class=\"c1\"># The values in sys can now be used to initialise CustomModeSolver</span>\n    <span class=\"n\">MbM</span> <span class=\"o\">=</span> <span class=\"n\">CustomModeSolver</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Let&#39;s compute a spectrum using the new setup:</span>\n    <span class=\"n\">spec</span> <span class=\"o\">=</span> <span class=\"n\">MbM</span><span class=\"o\">.</span><span class=\"n\">compute_spectrum</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n    <span class=\"o\">...</span>\n   \n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">new_mode_eq</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">ode_keys</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">new_bd_init</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">init_keys</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">new_cutoff</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;kh&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">default_atol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.001</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models", "modulename": "geff.models", "kind": "module", "doc": "<p>This module contains pre-defined GEF models.</p>\n\n<p>Currently, the following models are implemented:</p>\n\n<ol>\n<li><strong>'classic'</strong>: pure axion inflation</li>\n<li><strong>'SE noscale'</strong>: fermionic axion inflation (without accounting for fermion $k$-dependence)</li>\n<li><strong>'SE-kh'</strong>: fermionic axion inflation (accounting for fermion $k$-dependence using $k_h$)</li>\n</ol>\n\n<p>Execute these models by calling <code>GEFF.gef.GEF</code> with its name and settings.</p>\n"}, {"fullname": "geff.models.load_model", "modulename": "geff.models", "qualname": "load_model", "kind": "function", "doc": "<p>Import and execute a module defining a GEF model.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (str):\nThe name of the GEF model or a full dotted import path (e.g., \"path.to.module\").</li>\n<li><strong>user_settings</strong> (dict):\nA dictionary containing updated settings for the module.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ModuleType</strong>: The configured module.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">user_settings</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"p\">{}</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_basic", "modulename": "geff.models.fai_basic", "kind": "module", "doc": "<p>Module defining the GEF model \"SE no-scale\" corresponding to fermionic axion inflation without a heuristic scale dependence.</p>\n\n<p>For more details on this model, see e.g., <a href=\"https://arxiv.org/abs/2109.01651\">2109.01651</a>.</p>\n\n<hr />\n\n<p>The model knows the following variables:</p>\n\n<ul>\n<li>time variable: <code>t</code> - <em>cosmic time</em>, $t$ </li>\n<li>dynamical variables:\n<ul>\n<li><code>N</code> - <em>$e$-folds</em>,  $N$</li>\n<li><code>phi</code>, <code>dphi</code> - <em>inflaton amplitude, $\\varphi$, and velocity, $\\dot{\\varphi}$</em> </li>\n<li><code>kh</code> -  <em>the instability scale, $k_{\\rm h}$</em></li>\n<li><code>delta</code> - <em>cumulative electric damping, $\\Delta$</em></li>\n<li><code>rhoChi</code> - <em>fermion energy density, $\\rho_{\\chi}$</em></li>\n</ul></li>\n<li>static variables:\n<ul>\n<li><code>a</code> - <em>scale factor, $a$</em> </li>\n<li><code>H</code> - <em>Hubble rate, $H$</em> </li>\n<li><code>ddphi</code> - <em>inflaton acceleration, $\\ddot{\\varphi}$</em></li>\n<li><code>E</code>, <code>B</code>, <code>G</code> - <em>gauge-field expectation values, $\\langle {\\bf E}^2 \\rangle$, $\\langle {\\bf B}^2 \\rangle$, -$\\langle {\\bf E} \\cdot {\\bf B} \\rangle$</em></li>\n<li><code>xi</code> - <em>instability parameter, $\\xi$</em> </li>\n<li><code>sigmaE</code>, <code>sigmaB</code> - <em>electric and magnetic conductivities, $\\sigma_{\\rm E}$, $\\sigma_{\\rm B}$</em></li>\n<li><code>xieff</code> - <em>effective instability parameter, $\\xi_{\\rm eff}$</em></li>\n<li><code>s</code> - <em>electric damping parameter, $s = \\sigma_{\\rm E}/(2H)$</em></li>\n</ul></li>\n<li>constants: \n<ul>\n<li><code>beta</code> - <em>coupling strength, $\\beta$</em></li>\n</ul></li>\n<li>functions: \n<ul>\n<li><code>V</code>,<code>dV</code> - <em>inflaton potential, $V(\\varphi)$, and its derivative, $V_{,\\varphi}(\\varphi)$</em></li>\n</ul></li>\n<li>gauge field: \n<ul>\n<li><code>GF</code> - <em>tower of gauge bilinears, $\\mathcal{F}_{\\mathcal X}^{(n)}$</em></li>\n</ul></li>\n</ul>\n\n<p>The model expects the following input:</p>\n\n<ul>\n<li><code>phi</code>, <code>dphi</code> - <em>initial data on the inflaton, $\\varphi$, $\\dot\\varphi$</em></li>\n<li><code>rhoChi</code> - <em>initial data on the fermion energy density, $\\rho_{\\chi}$</em></li>\n<li><code>beta</code> - <em>coupling strength, $\\beta$</em></li>\n<li><code>V</code>, <code>dV</code> - <em>potential shape, $V(\\varphi)$, $V_{,\\varphi}(\\varphi)$</em></li>\n</ul>\n\n<p>The model tracks the following events:</p>\n\n<ul>\n<li>end of inflation - terminate solver when $\\ddot{a} &lt; 0$</li>\n<li>negative norms - return an error when $\\langle {\\bf E}^2 \\rangle$ or  $\\langle {\\bf B}^2 \\rangle$ are negative</li>\n</ul>\n"}, {"fullname": "geff.models.fai_basic.name", "modulename": "geff.models.fai_basic", "qualname": "name", "kind": "variable", "doc": "<p>The models name.</p>\n", "default_value": "&#x27;FAI basic&#x27;"}, {"fullname": "geff.models.fai_basic.settings", "modulename": "geff.models.fai_basic", "qualname": "settings", "kind": "variable", "doc": "<p>The model settings.</p>\n\n<p>Possible settings are \"mixed\", \"electric\", \"magnetic\".</p>\n\n<p>Determines if conductivities are computed assuming collinear E&amp;M fields \n(\"electric\", \"magnetic\") or not (\"mixed\").</p>\n", "default_value": "{&#x27;picture&#x27;: &#x27;mixed&#x27;}"}, {"fullname": "geff.models.fai_basic.define_units", "modulename": "geff.models.fai_basic", "qualname": "define_units", "kind": "function", "doc": "<p>Define how initial data is used to set the reference frequency, $\\omega$ and energy scale, $\\mu$.</p>\n\n<ul>\n<li>energy scale: $M_{\\rm P}$ in Planck units</li>\n<li>frequency scale: initial Hubble rate, $H_0$ (in Planck units)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">phi</span>, </span><span class=\"param\"><span class=\"n\">dphi</span>, </span><span class=\"param\"><span class=\"n\">V</span>, </span><span class=\"param\"><span class=\"n\">rhoChi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_basic.initial_conditions", "modulename": "geff.models.fai_basic", "qualname": "initial_conditions", "kind": "function", "doc": "<p>Define how to create an array of initial data to solve the ODE's.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vals</strong> (BGSystem):\ncontains initial data</li>\n<li><strong>ntr</strong> (int):\ntruncation number</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>yini</strong> (NDArray):\ninitial data in an array</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sys</span>, </span><span class=\"param\"><span class=\"n\">ntr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_basic.update_values", "modulename": "geff.models.fai_basic", "qualname": "update_values", "kind": "function", "doc": "<p>Compute static variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime</li>\n<li><strong>y</strong> (float):\narray of data</li>\n<li><strong>vals</strong> (BGSystem):\nsystem of data storing static variables</li>\n<li><strong>atol, rtol</strong> (float):\nprecisions (used for heaviside functions)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">sys</span>, </span><span class=\"param\"><span class=\"n\">atol</span><span class=\"o\">=</span><span class=\"mf\">1e-20</span>, </span><span class=\"param\"><span class=\"n\">rtol</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_basic.compute_timestep", "modulename": "geff.models.fai_basic", "qualname": "compute_timestep", "kind": "function", "doc": "<p>Compute time derivatives for dynamical variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime</li>\n<li><strong>y</strong> (float):\narray of data</li>\n<li><strong>vals</strong> (BGSystem):\nsystem of data storing static variables</li>\n<li><strong>atol, rtol</strong> (float):\nprecisions (used for heaviside functions)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dydt</strong> (NDArray):\ntime derivative of y</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">sys</span>, </span><span class=\"param\"><span class=\"n\">atol</span><span class=\"o\">=</span><span class=\"mf\">1e-20</span>, </span><span class=\"param\"><span class=\"n\">rtol</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_basic.condition_EndOfInflation", "modulename": "geff.models.fai_basic", "qualname": "condition_EndOfInflation", "kind": "function", "doc": "<p>Determine the end of inflation using $\\ddot{a} = 0$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime</li>\n<li><strong>y</strong> (float):\narray of data</li>\n<li><strong>vals</strong> (BGSystem):\nsystem of data storing static variables</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">sys</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_basic.consequence_EndOfInflation", "modulename": "geff.models.fai_basic", "qualname": "consequence_EndOfInflation", "kind": "function", "doc": "<p>Define how the solver response to a (non)-occurrence of the end of inflation.</p>\n\n<p>If the event occurs, the solultion is accepted. Else, increase $t_{\\rm end}$ and continue solving.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vals</strong> (BGSystem):\nsolution to an ODE</li>\n<li><strong>occurrence</strong> (bool):\nif the event has occurred during the ODE solution</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sys</span>, </span><span class=\"param\"><span class=\"n\">occurance</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_basic.EndOfInflation", "modulename": "geff.models.fai_basic", "qualname": "EndOfInflation", "kind": "variable", "doc": "<p>Defines the 'End of inflation' event.</p>\n", "default_value": "&lt;geff.solver.TerminalEvent object&gt;"}, {"fullname": "geff.models.fai_basic.NegativeNorms", "modulename": "geff.models.fai_basic", "qualname": "NegativeNorms", "kind": "variable", "doc": "<p>Defines the 'Negative norms' event.</p>\n", "annotation": ": geff.solver.ErrorEvent", "default_value": "&lt;geff.solver.ErrorEvent object&gt;"}, {"fullname": "geff.models.fai_basic.solver", "modulename": "geff.models.fai_basic", "qualname": "solver", "kind": "variable", "doc": "<p>The solver used by the GEF model.</p>\n", "default_value": "&lt;class &#x27;geff.solver.GEFSolver&#x27;&gt;"}, {"fullname": "geff.models.fai_basic.MbM", "modulename": "geff.models.fai_basic", "qualname": "MbM", "kind": "variable", "doc": "<p>The mode solver used by the GEF model.</p>\n", "default_value": "&lt;class &#x27;geff.mbm.ModeSolver&#x27;&gt;"}, {"fullname": "geff.models.fai_kh", "modulename": "geff.models.fai_kh", "kind": "module", "doc": "<p>Defines the GEF model \"SE-kh\" corresponding to fermionic axion inflation with a heuristic scale dependence model through the instability scale $k_{\\rm h}$.</p>\n\n<p>For more details on this model, see e.g., <a href=\"https://arxiv.org/abs/2408.16538\">2408.16538</a>.</p>\n\n<hr />\n\n<p>The model knows the following variables:</p>\n\n<ul>\n<li>time variable: <code>t</code> - <em>cosmic time</em>, $t$ </li>\n<li>dynamical variables:\n<ul>\n<li><code>N</code> - <em>$e$-folds</em>,  $N$</li>\n<li><code>phi</code>, <code>dphi</code> - <em>inflaton amplitude, $\\varphi$, and velocity, $\\dot{\\varphi}$</em> </li>\n<li><code>kh</code> -  <em>the instability scale, $k_{\\rm h}$</em></li>\n<li><code>rhoChi</code> - <em>fermion energy density, $\\rho_{\\chi}$</em></li>\n</ul></li>\n<li>static variables:\n<ul>\n<li><code>a</code> - <em>scale factor, $a$</em> </li>\n<li><code>H</code> - <em>Hubble rate, $H$</em> </li>\n<li><code>ddphi</code> - <em>inflaton acceleration, $\\ddot{\\varphi}$</em></li>\n<li><code>E</code>, <code>B</code>, <code>G</code> - <em>gauge-field expectation values, $\\langle {\\bf E}^2 \\rangle$, $\\langle {\\bf B}^2 \\rangle$, -$\\langle {\\bf E} \\cdot {\\bf B} \\rangle$</em></li>\n<li><code>xi</code> - <em>instability parameter, $\\xi$</em> </li>\n<li><code>sigmaE</code>, <code>sigmaB</code> - <em>electric and magnetic conductivities, $\\sigma_{\\rm E}$, $\\sigma_{\\rm B}$</em></li>\n<li><code>xieff</code> - <em>effective instability parameter, $\\xi_{\\rm eff}$</em></li>\n<li><code>kS</code> - <em>fermion momentum scale, $k_{\\rm S}$</em></li>\n</ul></li>\n<li>constants: \n<ul>\n<li><code>beta</code> - <em>coupling strength, $\\beta$</em></li>\n</ul></li>\n<li>functions: \n<ul>\n<li><code>V</code>,<code>dV</code> - <em>inflaton potential, $V(\\varphi)$, and its derivative, $V_{,\\varphi}(\\varphi)$</em></li>\n</ul></li>\n<li>gauge field: \n<ul>\n<li><code>GF</code> - <em>tower of gauge bilinears, $\\mathcal{F}_{\\mathcal X}^{(n)}$</em></li>\n</ul></li>\n</ul>\n\n<p>The model expects the following input:</p>\n\n<ul>\n<li><code>phi</code>, <code>dphi</code> - <em>initial data on the inflaton, $\\varphi$, $\\dot\\varphi$</em></li>\n<li><code>rhoChi</code> - <em>initial data on the fermion energy density, $\\rho_{\\chi}$</em></li>\n<li><code>beta</code> - <em>coupling strength, $\\beta$</em></li>\n<li><code>V</code>, <code>dV</code> - <em>potential shape, $V(\\varphi)$, $V_{,\\varphi}(\\varphi)$</em></li>\n</ul>\n\n<p>The model tracks the following events:</p>\n\n<ul>\n<li>end of inflation - terminate solver when $\\ddot{a} &lt; 0$</li>\n<li>negative norms - return an error when $\\langle {\\bf E}^2 \\rangle$ or  $\\langle {\\bf B}^2 \\rangle$ are negative</li>\n</ul>\n"}, {"fullname": "geff.models.fai_kh.name", "modulename": "geff.models.fai_kh", "qualname": "name", "kind": "variable", "doc": "<p>The models name.</p>\n", "default_value": "&#x27;FAI kh&#x27;"}, {"fullname": "geff.models.fai_kh.settings", "modulename": "geff.models.fai_kh", "qualname": "settings", "kind": "variable", "doc": "<p>The model settings.</p>\n\n<p>Possible settings are \"mixed\", \"electric\", \"magnetic\".</p>\n\n<p>Determines if conductivities are computed assuming collinear E&amp;M fields \n(\"electric\", \"magnetic\") or not (\"mixed\").</p>\n", "default_value": "{&#x27;picture&#x27;: &#x27;mixed&#x27;}"}, {"fullname": "geff.models.fai_kh.define_units", "modulename": "geff.models.fai_kh", "qualname": "define_units", "kind": "function", "doc": "<p>Define how initial data is used to set the reference frequency, $\\omega$ and energy scale, $\\mu$.</p>\n\n<ul>\n<li>energy scale: $M_{\\rm P}$ in Planck units</li>\n<li>frequency scale: initial Hubble rate, $H_0$ (in Planck units)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">phi</span>, </span><span class=\"param\"><span class=\"n\">dphi</span>, </span><span class=\"param\"><span class=\"n\">V</span>, </span><span class=\"param\"><span class=\"n\">rhoChi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_kh.initial_conditions", "modulename": "geff.models.fai_kh", "qualname": "initial_conditions", "kind": "function", "doc": "<p>Define how to create an array of initial data to solve the ODE's.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vals</strong> (BGSystem):\ncontains initial data</li>\n<li><strong>ntr</strong> (int):\ntruncation number</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>yini</strong> (NDArray):\ninitial data in an array</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sys</span>, </span><span class=\"param\"><span class=\"n\">ntr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_kh.update_values", "modulename": "geff.models.fai_kh", "qualname": "update_values", "kind": "function", "doc": "<p>Compute static variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime</li>\n<li><strong>y</strong> (float):\narray of data</li>\n<li><strong>vals</strong> (BGSystem):\nsystem of data storing static variables</li>\n<li><strong>atol, rtol</strong> (float):\nprecisions (used for heaviside functions)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">sys</span>, </span><span class=\"param\"><span class=\"n\">atol</span><span class=\"o\">=</span><span class=\"mf\">1e-20</span>, </span><span class=\"param\"><span class=\"n\">rtol</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_kh.compute_timestep", "modulename": "geff.models.fai_kh", "qualname": "compute_timestep", "kind": "function", "doc": "<p>Compute time derivatives for dynamical variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime</li>\n<li><strong>y</strong> (float):\narray of data</li>\n<li><strong>vals</strong> (BGSystem):\nsystem of data storing static variables</li>\n<li><strong>atol, rtol</strong> (float):\nprecisions (used for heaviside functions)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dydt</strong> (NDArray):\ntime derivative of y</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">sys</span>, </span><span class=\"param\"><span class=\"n\">atol</span><span class=\"o\">=</span><span class=\"mf\">1e-20</span>, </span><span class=\"param\"><span class=\"n\">rtol</span><span class=\"o\">=</span><span class=\"mf\">1e-06</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_kh.condition_EndOfInflation", "modulename": "geff.models.fai_kh", "qualname": "condition_EndOfInflation", "kind": "function", "doc": "<p>Determine the end of inflation using $\\ddot{a} = 0$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime</li>\n<li><strong>y</strong> (float):\narray of data</li>\n<li><strong>vals</strong> (BGSystem):\nsystem of data storing static variables</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">sys</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_kh.consequence_EndOfInflation", "modulename": "geff.models.fai_kh", "qualname": "consequence_EndOfInflation", "kind": "function", "doc": "<p>Define how the solver response to a (non)-occurrence of the end of inflation.</p>\n\n<p>If the event occurs, the solultion is accepted. Else, increase $t_{\\rm end}$ and continue solving.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vals</strong> (BGSystem):\nsolution to an ODE</li>\n<li><strong>occurrence</strong> (bool):\nif the event has occurred during the ODE solution</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sys</span>, </span><span class=\"param\"><span class=\"n\">occurance</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.fai_kh.EndOfInflation", "modulename": "geff.models.fai_kh", "qualname": "EndOfInflation", "kind": "variable", "doc": "<p>Defines the 'End of inflation' event.</p>\n", "default_value": "&lt;geff.solver.TerminalEvent object&gt;"}, {"fullname": "geff.models.fai_kh.NegativeNorms", "modulename": "geff.models.fai_kh", "qualname": "NegativeNorms", "kind": "variable", "doc": "<p>Defines the 'Negative norms' event.</p>\n", "annotation": ": geff.solver.ErrorEvent", "default_value": "&lt;geff.solver.ErrorEvent object&gt;"}, {"fullname": "geff.models.fai_kh.solver", "modulename": "geff.models.fai_kh", "qualname": "solver", "kind": "variable", "doc": "<p>The solver used by the GEF model.</p>\n", "default_value": "&lt;class &#x27;geff.solver.GEFSolver&#x27;&gt;"}, {"fullname": "geff.models.fai_kh.MbM", "modulename": "geff.models.fai_kh", "qualname": "MbM", "kind": "variable", "doc": "<p>The mode solver used by the GEF model.</p>\n", "default_value": "&lt;class &#x27;geff.mbm.ModeSolver&#x27;&gt;"}, {"fullname": "geff.models.pai", "modulename": "geff.models.pai", "kind": "module", "doc": "<p>Defines the GEF model \"classic\" corresponding to pure axion inflation.</p>\n\n<p>For more details on this model, see e.g., <a href=\"https://arxiv.org/abs/2109.01651\">arXiv:2109.01651</a>.</p>\n\n<hr />\n\n<p>The model knows the following variables:</p>\n\n<ul>\n<li>time variable: <code>t</code> - <em>cosmic time</em>, $t$ </li>\n<li>dynamical variables:\n<ul>\n<li><code>N</code> - <em>$e$-folds</em>,  $N$</li>\n<li><code>phi</code>, <code>dphi</code> - <em>inflaton amplitude, $\\varphi$, and velocity, $\\dot{\\varphi}$</em> </li>\n<li><code>kh</code> -  <em>the instability scale, $k_{\\rm h}$</em></li>\n</ul></li>\n<li>static variables:\n<ul>\n<li><code>a</code> - <em>scale factor, $a$</em> </li>\n<li><code>H</code> - <em>Hubble rate, $H$</em> </li>\n<li><code>ddphi</code> - <em>inflaton acceleration, $\\ddot{\\varphi}$</em></li>\n<li><code>E</code>, <code>B</code>, <code>G</code> - <em>gauge-field expectation values, $\\langle {\\bf E}^2 \\rangle$, $\\langle {\\bf B}^2 \\rangle$, -$\\langle {\\bf E} \\cdot {\\bf B} \\rangle$</em></li>\n<li><code>xi</code> - <em>instability parameter, $\\xi$</em> </li>\n</ul></li>\n<li>constants: \n<ul>\n<li><code>beta</code> - <em>coupling strength, $\\beta$</em></li>\n</ul></li>\n<li>functions: \n<ul>\n<li><code>V</code>,<code>dV</code> - <em>inflaton potential, $V(\\varphi)$, and its derivative, $V_{,\\varphi}(\\varphi)$</em></li>\n</ul></li>\n<li>gauge field: \n<ul>\n<li><code>GF</code> - <em>tower of gauge bilinears, $\\mathcal{F}_{\\mathcal X}^{(n)}$</em></li>\n</ul></li>\n</ul>\n\n<p>The model expects the following input:</p>\n\n<ul>\n<li><code>phi</code>, <code>dphi</code> - <em>initial data on the inflaton, $\\varphi$, $\\dot\\varphi$</em></li>\n<li><code>rhoChi</code> - <em>initial data on the fermion energy density, $\\rho_{\\chi}$</em></li>\n<li><code>beta</code> - <em>coupling strength, $\\beta$</em></li>\n<li><code>V</code>, <code>dV</code> - <em>potential shape, $V(\\varphi)$, $V_{,\\varphi}(\\varphi)$</em></li>\n</ul>\n\n<p>The model tracks the following events:</p>\n\n<ul>\n<li>end of inflation - terminate solver when $\\ddot{a} &lt; 0$</li>\n<li>negative norms - return an error when $\\langle {\\bf E}^2 \\rangle$ or  $\\langle {\\bf B}^2 \\rangle$ are negative</li>\n</ul>\n"}, {"fullname": "geff.models.pai.name", "modulename": "geff.models.pai", "qualname": "name", "kind": "variable", "doc": "<p>The models name.</p>\n", "annotation": ": str", "default_value": "&#x27;PAI&#x27;"}, {"fullname": "geff.models.pai.define_units", "modulename": "geff.models.pai", "qualname": "define_units", "kind": "function", "doc": "<p>Define how initial data is used to set the reference frequency, $\\omega$ and energy scale, $\\mu$.</p>\n\n<ul>\n<li>energy scale: $M_{\\rm P}$ in Planck units</li>\n<li>frequency scale: initial Hubble rate, $H_0$ (in Planck units)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">phi</span>, </span><span class=\"param\"><span class=\"n\">dphi</span>, </span><span class=\"param\"><span class=\"n\">V</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.pai.initial_conditions", "modulename": "geff.models.pai", "qualname": "initial_conditions", "kind": "function", "doc": "<p>Define how to create an array of initial data to solve the ODE's.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vals</strong> (BGSystem):\ncontains initial data</li>\n<li><strong>ntr</strong> (int):\ntruncation number</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>yini</strong> (NDArray):\ninitial data in an array</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sys</span>, </span><span class=\"param\"><span class=\"n\">ntr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.pai.update_values", "modulename": "geff.models.pai", "qualname": "update_values", "kind": "function", "doc": "<p>Compute static variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime</li>\n<li><strong>y</strong> (float):\narray of data</li>\n<li><strong>vals</strong> (BGSystem):\nsystem of data storing static variables</li>\n<li><strong>atol, rtol</strong> (float):\nprecisions (used for heaviside functions)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">sys</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.pai.compute_timestep", "modulename": "geff.models.pai", "qualname": "compute_timestep", "kind": "function", "doc": "<p>Compute time derivatives for dynamical variables.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime</li>\n<li><strong>y</strong> (float):\narray of data</li>\n<li><strong>vals</strong> (BGSystem):\nsystem of data storing static variables</li>\n<li><strong>atol, rtol</strong> (float):\nprecisions (used for heaviside functions)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dydt</strong> (NDArray):\ntime derivative of y</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">sys</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.pai.condition_EndOfInflation", "modulename": "geff.models.pai", "qualname": "condition_EndOfInflation", "kind": "function", "doc": "<p>Determine the end of inflation using $\\ddot{a} = 0$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime</li>\n<li><strong>y</strong> (float):\narray of data</li>\n<li><strong>vals</strong> (BGSystem):\nsystem of data storing static variables</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">sys</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.pai.consequence_EndOfInflation", "modulename": "geff.models.pai", "qualname": "consequence_EndOfInflation", "kind": "function", "doc": "<p>Define how the solver response to a (non)-occurrence of the end of inflation.</p>\n\n<p>If the event occurs, the solultion is accepted. Else, increase $t_{\\rm end}$ and continue solving.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vals</strong> (BGSystem):\nsolution to an ODE</li>\n<li><strong>occurrence</strong> (bool):\nif the event has occurred during the ODE solution</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sys</span>, </span><span class=\"param\"><span class=\"n\">occurrence</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.models.pai.EndOfInflation", "modulename": "geff.models.pai", "qualname": "EndOfInflation", "kind": "variable", "doc": "<p>Defines the 'End of inflation' event.</p>\n", "annotation": ": geff.solver.TerminalEvent", "default_value": "&lt;geff.solver.TerminalEvent object&gt;"}, {"fullname": "geff.models.pai.NegativeNorms", "modulename": "geff.models.pai", "qualname": "NegativeNorms", "kind": "variable", "doc": "<p>Defines the 'Negative norms' event.</p>\n", "annotation": ": geff.solver.ErrorEvent", "default_value": "&lt;geff.solver.ErrorEvent object&gt;"}, {"fullname": "geff.models.pai.solver", "modulename": "geff.models.pai", "qualname": "solver", "kind": "variable", "doc": "<p>The solver used by the GEF model.</p>\n", "default_value": "&lt;class &#x27;geff.solver.GEFSolver&#x27;&gt;"}, {"fullname": "geff.models.pai.MbM", "modulename": "geff.models.pai", "qualname": "MbM", "kind": "variable", "doc": "<p>The mode solver used by the GEF model.</p>\n", "default_value": "&lt;class &#x27;geff.mbm.ModeSolver&#x27;&gt;"}, {"fullname": "geff.solver", "modulename": "geff.solver", "kind": "module", "doc": "<p>This module defines the main class for an ODE solver used by GEF models.</p>\n\n<p>The <code>BaseGEFSolver</code> is the the primary class supplied by this module. It defines an algorithm by which the equations of motion for a GEF model are solved.\nThis makes use of the <code>geff.bgtypes.BGSystem</code> module to simplify conversions between numerical and physical units.</p>\n\n<p>While the <code>BaseGEFSolver</code>is solving the ODE's it can track one or multiple <code>Event</code> objects. These events correspond to certain conditions, for example, the end of inflation.\nOccurrences of these events can be designed to influence the solver. For example, an 'end of inflation' <code>Event</code> may check if\n the solver has reached the end of inflation, and terminate it if it has.</p>\n\n<p>The <code>BaseGEFSolver</code> class can be used to configure customized solvers using the class factory <code>GEFSolver</code> to adapt it to a specific GEF model.</p>\n"}, {"fullname": "geff.solver.BaseGEFSolver", "modulename": "geff.solver", "qualname": "BaseGEFSolver", "kind": "class", "doc": "<p>A class used to solve the equations of motion defined by a GEF model.</p>\n\n<p>The main purpose of the class is to provide the <code>compute_GEF_solution</code> method to <code>run</code>. \nInternally, the method uses <code>solve_eom</code>, which wraps <code>scipy.integrate.solve_ivp</code>.</p>\n\n<p>All specifications on the GEF model are encoded in the attributes <code>known_variables</code> and <code>known_events</code>, as well as\nthe methods <code>vals_to_yini</code>, <code>update_vals</code> and <code>timestep</code>. \nFor illustration, purposes, these methods are configured such that the GEFSolver solves the\nEoMs for de Sitter expansion:\n$$\\frac{{\\rm d} \\log a}{{\\rm d} t} = H_0$$</p>\n\n<p>In practice, the class factory <code>GEFSolver</code> creates a subclass of <code>BaseGEFSolver</code> adapted to the EoMs of other models.</p>\n"}, {"fullname": "geff.solver.BaseGEFSolver.__init__", "modulename": "geff.solver", "qualname": "BaseGEFSolver.__init__", "kind": "function", "doc": "<p>Pass initial data to the solver.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>init_sys</strong> (BGSystem):\ninitial data used by the solver</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">init_sys</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span>)</span>"}, {"fullname": "geff.solver.BaseGEFSolver.known_variables", "modulename": "geff.solver", "qualname": "BaseGEFSolver.known_variables", "kind": "variable", "doc": "<p>Classifies variables used by the solver according to:</p>\n\n<ul>\n<li>'time': the name of the time parameter of the ODE's (should be \"t\") </li>\n<li>'dynamical': variables evolved by the EoM (not 'gauge')</li>\n<li>'gauge': tower of gauge-field expectation values evolved by the EoM</li>\n<li>'static': variables computed from 'dynamical' and 'gauge'</li>\n<li>'constant': constant variables</li>\n<li>'function': functions of the above variables.</li>\n</ul>\n", "annotation": ": ClassVar[dict]", "default_value": "{&#x27;time&#x27;: [&lt;class &#x27;geff.bgtypes.Val_t&#x27;&gt;], &#x27;dynamical&#x27;: [&lt;class &#x27;geff.bgtypes.Val_N&#x27;&gt;], &#x27;static&#x27;: [&lt;class &#x27;geff.bgtypes.Val_a&#x27;&gt;], &#x27;constant&#x27;: [&lt;class &#x27;geff.bgtypes.Val_H&#x27;&gt;], &#x27;function&#x27;: [], &#x27;gauge&#x27;: []}"}, {"fullname": "geff.solver.BaseGEFSolver.known_events", "modulename": "geff.solver", "qualname": "BaseGEFSolver.known_events", "kind": "variable", "doc": "<p>The <code>Event</code> objects which are tracked by the solver.</p>\n", "annotation": ": ClassVar[dict]", "default_value": "{}"}, {"fullname": "geff.solver.BaseGEFSolver.init_vals", "modulename": "geff.solver", "qualname": "BaseGEFSolver.init_vals", "kind": "variable", "doc": "<p>Initial data for the EoM's defined at $t_0 = 0$.</p>\n", "annotation": ": geff.bgtypes.BGSystem"}, {"fullname": "geff.solver.BaseGEFSolver.settings", "modulename": "geff.solver", "qualname": "BaseGEFSolver.settings", "kind": "variable", "doc": "<p>A dictionary of internal settings used by the class:</p>\n\n<ul>\n<li>atol: absolute tolerance used by <code>solve_ivp</code> (default: 1e-20)</li>\n<li>rtol: relative tolerance used by <code>solve_ivp</code> (default: 1e-6)</li>\n<li>solvermethod: method used by <code>solve_ivp</code> (default: 'RK45')</li>\n<li>attempts: attempts made by <code>compute_GEF_solution</code> (default: 5)</li>\n<li>ntrstep: <code>ntr</code> increment used in <code>compute_GEF_solution</code> (default: 10)</li>\n</ul>\n", "annotation": ": dict"}, {"fullname": "geff.solver.BaseGEFSolver.ntr", "modulename": "geff.solver", "qualname": "BaseGEFSolver.ntr", "kind": "variable", "doc": "<p>Truncation number $n_{\\rm tr}$, for truncated towers of ODE's.</p>\n", "annotation": ": int"}, {"fullname": "geff.solver.BaseGEFSolver.tend", "modulename": "geff.solver", "qualname": "BaseGEFSolver.tend", "kind": "variable", "doc": "<p>The time $t_{\\rm end}$ up to which the EoMs are solved.</p>\n", "annotation": ": float"}, {"fullname": "geff.solver.BaseGEFSolver.toggle_event", "modulename": "geff.solver", "qualname": "BaseGEFSolver.toggle_event", "kind": "function", "doc": "<p>Disable or enable an <code>Event</code> for the solver.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>event_name</strong> (str):\nthe name of the target</li>\n<li><strong>toggle</strong> (bool):\nif the event should be active or inactive</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">event_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">toggle</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.BaseGEFSolver.compute_GEF_solution", "modulename": "geff.solver", "qualname": "BaseGEFSolver.compute_GEF_solution", "kind": "function", "doc": "<p>An algorithm to solve the GEF equations.</p>\n\n<p>The solver attempts to solve the EoMs several times using <code>solve_eom</code>. \nIf this returns a <code>TruncationError</code>, <code>ntr</code> is increased by <code>settings['ntrstep']</code>.\nAfterwards, <code>solve_eom</code> is called again until it returns a result.\nThis is done for <code>settings['attempts']</code> times or until <code>ntr=200</code> is reached.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>sol</strong>: a bunch object returned by <code>solve_ivp</code> containing the solution</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>RuntimeError</strong>: if no solution was obtained after the maximum number of attempts.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.BaseGEFSolver.vals_to_yini", "modulename": "geff.solver", "qualname": "BaseGEFSolver.vals_to_yini", "kind": "function", "doc": "<p>Create an array of initial data from a BGSystem.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>vals</strong> (BGSystem):\na unit system with initial data</li>\n<li><strong>ntr</strong> (int):\ntruncation number (relevant for dynamical gauge-fields)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>yini</strong> (NDarray):\nan array of initial data</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vals</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span>, </span><span class=\"param\"><span class=\"n\">ntr</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.BaseGEFSolver.set_initial_conditions_to_default", "modulename": "geff.solver", "qualname": "BaseGEFSolver.set_initial_conditions_to_default", "kind": "function", "doc": "<p>Configure the solver to use initial data from <code>init_vals</code> using <code>vals_to_yini</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.BaseGEFSolver.set_initial_conditions_to_MbM", "modulename": "geff.solver", "qualname": "BaseGEFSolver.set_initial_conditions_to_MbM", "kind": "function", "doc": "<p>Configure the solver to initialise data from a mode-by-mode solution.</p>\n\n<p>Used for mode-by-mode self correction. \nGauge-bilinears, $F_{\\mathcal X}^{(n>1)}$ are re-initialized using <code>.mbm.SpecSlice.integrate_slice</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sol</strong>: a bunch object returned by <code>solve_ivp</code> containing the solution</li>\n<li><strong>reinit_spec</strong> (SpecSlice):\nspectrum at time of reinitialization</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">sol</span>, </span><span class=\"param\"><span class=\"n\">reinit_spec</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">mbm</span><span class=\"o\">.</span><span class=\"n\">SpecSlice</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.BaseGEFSolver.update_vals", "modulename": "geff.solver", "qualname": "BaseGEFSolver.update_vals", "kind": "function", "doc": "<p>Translate an array of data at time t into a <code>BGSystem</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime coordinate</li>\n<li><strong>y</strong> (NDArray:):\narray of data at time t</li>\n<li><strong>vals</strong> (BGSystem):\nthe target system</li>\n<li><strong>atol</strong> (float):\nabsolute tolerance parameters (if needed)</li>\n<li><strong>rtol</strong> (float):\nrelative tolerance parameters (if needed)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">vals</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.BaseGEFSolver.timestep", "modulename": "geff.solver", "qualname": "BaseGEFSolver.timestep", "kind": "function", "doc": "<p>Compute time derivatives for data at time t using a <code>BGSystem</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\na time coordinate</li>\n<li><strong>y</strong> (NDArray:):\nan array of data at time t</li>\n<li><strong>vals</strong> (BGSystem):\nthe system used to compute the derivative</li>\n<li><strong>atol</strong> (float):\nabsolute tolerance parameters (if needed)</li>\n<li><strong>rtol</strong> (float):\nrelative tolerance parameters (if needed)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dydt</strong> (NDArray):\nthe time derivative of y</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">vals</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.BaseGEFSolver.ode", "modulename": "geff.solver", "qualname": "BaseGEFSolver.ode", "kind": "function", "doc": "<p>subsequently call <code>update_vals</code> and <code>timestep</code> to formulate an ODE for <code>solve_ivp</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\na time coordinate</li>\n<li><strong>y</strong> (NDArray:):\nan array of data at time t</li>\n<li><strong>vals</strong> (BGSystem):\nthe system passed to <code>update_vals</code> and <code>timestep</code> and</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dydt</strong> (NDArray):\nthe time derivative of y</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">vals</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.BaseGEFSolver.solve_eom", "modulename": "geff.solver", "qualname": "BaseGEFSolver.solve_eom", "kind": "function", "doc": "<p>Attempt to solve the GEF EoM's using <code>scipy.integrate.solve_ivp</code>.</p>\n\n<p>The solver attempts to obtain a GEF solution. This solution is then checked for any <code>ErrorEvent</code> occurrences.\nIn this case, the solver marks the solution as unsuccessful and returns it for further processing.\nIf no <code>ErrorEvent</code> occurrences are found, the other <code>TerminalEvent</code> occurrences are analyzed.\nThese decide if the solution is returned, repeated, or if the solver should continue to solve.\nIf there are no active <code>TerminalEvent</code> instances, the solution is returned after reaching <code>settings['tend']</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t0</strong> (float):\ntime of initialization</li>\n<li><strong>yini</strong> (NDArray):\ninitial data at t0</li>\n<li><strong>vals</strong> (BGSystem):\nevolved alongside yini</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>sol</strong>: a bunch object returned by <code>solve_ivp</code> containing the solution</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>TruncationError</strong> ():\nif an internal error occurred while solving the ODE.</li>\n<li><strong>RuntimeError:</strong>: if no 'finish' or 'error' command is obtained from an <code>Event</code> and <code>settings['tend']</code> is also not reached.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">t0</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">yini</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">vals</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.BaseGEFSolver.parse_arr_to_sys", "modulename": "geff.solver", "qualname": "BaseGEFSolver.parse_arr_to_sys", "kind": "function", "doc": "<p>Translate a GEF solution array to a BGSystem.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (NDArray):\narray of time coordinates</li>\n<li><strong>y</strong> (NDArray):\narray of variables at time t</li>\n<li><strong>vals</strong> (BGSystem):\nthe target system</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">vals</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.BaseGEFSolver.update_settings", "modulename": "geff.solver", "qualname": "BaseGEFSolver.update_settings", "kind": "function", "doc": "<p>Update the <code>settings</code> of the class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">new_settings</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.GEFSolver", "modulename": "geff.solver", "qualname": "GEFSolver", "kind": "function", "doc": "<p>Create a subclass of <code>BaseGEFSolver</code> with custom equation of motions and initial conditions.</p>\n\n<p>The subclass is adjusted to the specific EoMs of a new GEF model by defining new methods for <code>BaseGEFSolver.vals_to_yini</code>, <code>BaseGEFSolver.update_vals</code> and <code>BaseGEFSolver.timestep</code> via <code>new_init</code>, <code>new_update_val</code> and <code>new_timestep</code>.\nInformation about the classificiation of variables is encoded in <code>new_variables</code> which overwrites <code>BaseGEFSolver.known_variables</code>.</p>\n\n<p>The <code>new_init</code> needs to obey the following rules:</p>\n\n<ol>\n<li>The call signature and output matches <code>vals_to_yini</code>.</li>\n<li>The return array <code>yini</code> has a shape: $n_{\\rm dynam.} + 3(n_{\\rm tr}+1) \\times n_{\\rm gauge}$.</li>\n<li>All dynamical variables are reflected in the first $n_{\\rm dynam.}$-indices of <code>yini</code>.</li>\n<li>All gauge variables are reflected in the last $3(n_{\\rm tr}+1) \\times n_{\\rm gauge}$-indices of <code>yini</code>.</li>\n</ol>\n\n<p>Above, $n_{\\rm dynam.}$ and $n_{\\rm gauge}$ are, respectively, the number of dynamical and gauge-field variables.</p>\n\n<p>The <code>new_update_vals</code> needs to obey the following rules:</p>\n\n<ol>\n<li>The call signature and output matches <code>update_vals</code>.</li>\n<li>It updates every static variable using values in <code>y</code> and <code>t</code>.</li>\n</ol>\n\n<p>The <code>new_timestep</code> needs to obey the following rules:</p>\n\n<ol>\n<li>The call signature and output matches <code>timestep</code>.</li>\n<li>It computes derivatives <code>dydt</code> for every dynamical or gauge varibale.</li>\n<li>Static variables from <code>new_update_vals</code> can be re-used, as it is called before <code>new_timestep</code>.</li>\n<li>The indices in <code>dydt</code> need to match those of <code>yini</code> returned by <code>new_init</code>.</li>\n</ol>\n\n<p>All these functions assume that <code>vals</code> is in numerical units throughout the computation.</p>\n\n<p>In addition, a new list of <code>Event</code> objects can be passed to the subclass using <code>new_events</code></p>\n\n<p>For an example on how to define a new solver, see <code>GEFF.models.classic</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>new_init</strong> (Callable):\noverwrites <code>BaseGEFSolver.vals_to_yini</code></li>\n<li><strong>new_update_vals</strong> (Callable):\noverwrites <code>BaseGEFSolver.update_vals</code></li>\n<li><strong>new_timestep</strong> (Callable):\noverwrites <code>BaseGEFSolver.timestep</code></li>\n<li><strong>new_events</strong> (list of Event):\noverwrites <code>BaseGEFSolver.known_events</code></li>\n<li><strong>new_variables</strong> (dict):\noverwrites <code>BaseGEFSolver.known_variables</code></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>GEFSolver</strong>: a subclass of BaseGEFSolver</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">new_init</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">new_update_vals</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">new_timestep</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">new_variables</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">new_events</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">solver</span><span class=\"o\">.</span><span class=\"n\">Event</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.Event", "modulename": "geff.solver", "qualname": "Event", "kind": "class", "doc": "<p>An event which is tracked while solving the GEF equations.</p>\n\n<p>The class defines a function $f(t, y)$ which is used by <code>scipy.integrate.solve_ivp</code> to track occurrences of $f(t, y(t))=0$.\nThe event can be <code>terminal</code> causing the solver to stop upon an event occurrence.\nThe event only triggers if the event condition changes sign according to:</p>\n\n<ul>\n<li>positive zero crossing: <code>direction=1</code></li>\n<li>negative derivative, <code>direction=-1</code> </li>\n<li>arbitrary zero crossing <code>direction=0</code></li>\n</ul>\n\n<p>The zeros are recorded and returned as part of the solvers output.</p>\n\n<p>The function $f$ is encoded in the method <code>event_func</code> which is defined upon initialization.</p>\n\n<p>Within subclasses of <code>BaseGEFSolver</code> class, three subclasses of <code>Event</code> are used:</p>\n\n<ol>\n<li><code>TerminalEvent</code></li>\n<li><code>ErrorEvent</code></li>\n<li><code>ObserverEvent</code></li>\n</ol>\n"}, {"fullname": "geff.solver.Event.__init__", "modulename": "geff.solver", "qualname": "Event.__init__", "kind": "function", "doc": "<p>Initialise the event as <code>active</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name</strong> (str):\nsets the <code>name</code> attribute</li>\n<li><strong>eventtype</strong> (str):\nsets the <code>type</code> attribute</li>\n<li><strong>func</strong> (Callable):\nsets the <code>event_func</code> attribute</li>\n<li><strong>terminal</strong> (boolean):\ndefines if the event occurrence is terminal or not</li>\n<li><strong>direction</strong> (int):\ndefines the direction for which event occurrences are tracked</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">eventtype</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">terminal</span><span class=\"p\">:</span> <span class=\"nb\">bool</span>,</span><span class=\"param\">\t<span class=\"n\">direction</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "geff.solver.Event.name", "modulename": "geff.solver", "qualname": "Event.name", "kind": "variable", "doc": "<p>The name of the event.</p>\n", "annotation": ": str"}, {"fullname": "geff.solver.Event.type", "modulename": "geff.solver", "qualname": "Event.type", "kind": "variable", "doc": "<p>The event type 'terminal', 'error', or 'observer'.</p>\n", "annotation": ": str"}, {"fullname": "geff.solver.Event.active", "modulename": "geff.solver", "qualname": "Event.active", "kind": "variable", "doc": "<p>The events state, <code>False</code> implies the <code>Event</code> is disregarded by the solver.</p>\n", "annotation": ": bool"}, {"fullname": "geff.solver.Event.event_func", "modulename": "geff.solver", "qualname": "Event.event_func", "kind": "function", "doc": "<p>The event tracked by <code>Event</code></p>\n\n<p>This method is overwritten by the <code>func</code> input upon class initialisation.\nThe signature and return of <code>func</code>needs to match this method</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime</li>\n<li><strong>y</strong> (np.ndarray):\nthe solution array</li>\n<li><strong>sys</strong> (BGSystem):\nthe system which is evolved alongside y</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>condition</strong> (float):\ncondition=0 is an event occurrence</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">sys</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.TerminalEvent", "modulename": "geff.solver", "qualname": "TerminalEvent", "kind": "class", "doc": "<p>An <code>Event</code> subclass whose occurrence terminates the solver.</p>\n\n<p>When the solver has terminated (due to an event or otherwise) it checks for <code>TerminalEvent</code> occurrences.\n This calls the <code>event_consequence</code> method, which returns instructions to <code>BaseGEFSolver</code>. \n These instructions may be different depending on an event occurrence or a non-occurrence.</p>\n", "bases": "Event"}, {"fullname": "geff.solver.TerminalEvent.__init__", "modulename": "geff.solver", "qualname": "TerminalEvent.__init__", "kind": "function", "doc": "<p>Initialise the parent class and overwrite the <code>event_consequence</code> method.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>name</strong> (str):\nsets the <code>name</code> attribute</li>\n<li><strong>func</strong> (Callable):\nsets the <code>event_func</code> attribute</li>\n<li><strong>direction</strong> (int):\npassed as <code>direction</code> to the parent class</li>\n<li><strong>consequence</strong> (Callable):\noverwrites the <code>event_consequence</code> method</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>, </span><span class=\"param\"><span class=\"n\">direction</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">consequence</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span>)</span>"}, {"fullname": "geff.solver.TerminalEvent.event_consequence", "modulename": "geff.solver", "qualname": "TerminalEvent.event_consequence", "kind": "function", "doc": "<p>Inform the solver how to handle a (non-)occurrence of the event.</p>\n\n<p>This method is overwritten by the <code>consequence</code> input upon class initialisation.</p>\n\n<p>The methods returns are treated as an instruction to the solver:</p>\n\n<ul>\n<li><code>primary</code>: this informs the solver what to do with its ODE solution:\n<ul>\n<li>'finish': the solver returns its solution marked as successful.</li>\n<li>'proceed': the solver continues solving from the termination time onwards.</li>\n<li>'repeat': the solver recomputes the solution.</li>\n</ul></li>\n<li><code>secondary</code>: this informs the solver if any of its settings need to be changed. \nAllowed attributes are 'timestep', 'tend', 'atol', 'rtol'. See <code>BaseGEFSolver</code> for more details.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>sys</strong> (BGSystem):\na system containing the solution of the solver</li>\n<li><strong>occurrence</strong> (bool):\nindicates if the event occurred during the solution or not</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>primary</strong> (str):\neither 'finish', 'proceed' or 'repeat'</li>\n<li><strong>secondary</strong> (dict):\nthe affected settings as keys and their new value as an item</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sys</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span>, </span><span class=\"param\"><span class=\"n\">occurrence</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.solver.ErrorEvent", "modulename": "geff.solver", "qualname": "ErrorEvent", "kind": "class", "doc": "<p>An <code>Event</code> subclass whose occurrence indicates undesired behavior of the solution.</p>\n\n<p>When the solver terminates with an <code>ErrorEvent</code>, <code>BaseGEFSolver.solve_eom</code> returns the solution as unsuccessful.</p>\n", "bases": "Event"}, {"fullname": "geff.solver.ErrorEvent.__init__", "modulename": "geff.solver", "qualname": "ErrorEvent.__init__", "kind": "function", "doc": "<p>Initialise the parent class.</p>\n\n<p>The additional parameter <code>message</code> is printed on an event occurrence</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>, </span><span class=\"param\"><span class=\"n\">direction</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "geff.solver.ObserverEvent", "modulename": "geff.solver", "qualname": "ObserverEvent", "kind": "class", "doc": "<p>An <code>Event</code> which does not terminate the solve, but only records its occurences.</p>\n", "bases": "Event"}, {"fullname": "geff.solver.ObserverEvent.__init__", "modulename": "geff.solver", "qualname": "ObserverEvent.__init__", "kind": "function", "doc": "<p>Initialise the parent class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>, </span><span class=\"param\"><span class=\"n\">direction</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "geff.solver.TruncationError", "modulename": "geff.solver", "qualname": "TruncationError", "kind": "class", "doc": "<p>Exception indicating that a GEF solution was unsuccessful.</p>\n", "bases": "builtins.Exception"}, {"fullname": "geff.solver.ODECompilationError", "modulename": "geff.solver", "qualname": "ODECompilationError", "kind": "class", "doc": "<p>Exception indicating that an error occured while testing the ODE of a model.</p>\n", "bases": "builtins.Exception"}, {"fullname": "geff.tools", "modulename": "geff.tools", "kind": "module", "doc": "<p>This module contains tools to compute physical observables from a GEF result.</p>\n\n<p>Currently, the following tools are available:</p>\n\n<ol>\n<li>Compute the tensor power spectrum using <code>geff.tools.pt</code>.</li>\n<li>Compute and analyze the gravitational wave spectrum using <code>geff.tools.gw</code>.</li>\n</ol>\n"}, {"fullname": "geff.tools.gw", "modulename": "geff.tools.gw", "kind": "module", "doc": "<p>This module is intended to compute a gravitational-wave spectrum from a tensor power spectrum.</p>\n\n<p>The gravitational-wave spectrum, $h^2\\Omega_{\\rm GW}$ is computed using <code>omega_gw</code>, which evaluates the formula</p>\n\n<p>$$\\Omega_{\\rm GW}(f) \\equiv  \\frac{1}{3 H_0^2 M_{\\rm P}^2}\\frac{{\\rm d} \\rho_{\\rm GW} (f)}{{\\rm d} \\ln{f}} = \n                                \\frac{\\pi^2}{3 H_0^2} f^2 |\\mathcal{T}_{\\rm GW}(f)|^2 \\mathcal{P}_T(k_f), k_f) \n                                \\, , \\quad k_f = 2 \\pi a_0 f \\, ,$$</p>\n\n<p>where  $\\mathcal{P}_T(k)$ is the tensor power spectrum with momentum $k$ at the end of inflation, and $H_0$ is the Hubble rate today.\nThe transfer function $|\\mathcal{T}_{\\rm GW}(f)|^2$ is given by</p>\n\n<p>$$|\\mathcal{T}_{\\rm GW}(f)|^2 \\simeq \\frac{H_0^2\\Omega_r}{8 \\pi^2 f^2} \\frac{g_{*}(T_f)}{g_{*}(T_0)} \n                                        \\left(\\frac{g_{*,S}(T_0)}{g_{*,S}(T_f)}\\right)^{4/3}\n                                        \\left(1 + \\frac{9}{16}\\left(\\frac{f_{\\rm eq}}{\\sqrt{2} f} \\right)^2\\right)\n                                        |\\mathcal{T}_{\\rm reh}(f)|^2 \\,.$$</p>\n\n<p>It accounts for the evolution of $\\Omega_{\\rm GW}(f)$ from the end of inflation until today.\nHere, $T_f$ is the temperature corresponding to the frequency $f$.\nFor $g_{*}$, $g_{*,S}$, $f_{\\rm eq}$, $\\Omega_r$, and $T_0$, we use the corresponding functions in <code>geff.utility.cosmo</code>.\nThe term $|\\mathcal{T}_{\\rm reh}(f)|^2$ accounts for the transition through reheating. For instantaneous reheating, $|\\mathcal{T}_{\\rm reh}(f)|^2 = 1$.\nOtherwise, we assume that reheating proceeds via coherent oscillations of the inflaton field, such that</p>\n\n<p>$$\n|\\mathcal{T}_{\\rm reh}(f)|^2 = \\frac{ \\theta(f_{\\rm end} - f)}{1 - 0.22 \\left(\\frac{f}{f_{\\rm reh}}\\right)^{1.5} + 0.65 \\left(\\frac{f}{f_{\\rm reh}}\\right)^{2}} \\, ,\n$$</p>\n\n<p>as given in <a href=\"https://arxiv.org/abs/1407.4785\">arXiv:1407.4785</a> and <a href=\"https://arxiv.org/abs/2011.03323\">arXiv:2011.03323</a>. \nHere, $f_{\\rm reh}$ and $f_{\\rm end}$ are, respectively, the frequencies at the end of reheating, and inflation.</p>\n\n<p>The frequency $f$ can be computed from a comoving momentum $k$ using <code>k_to_f</code>, which evaluates</p>\n\n<p>$$\nf = \\frac{k_f}{2 \\pi a_0} =\\frac{k_f}{2 \\pi a_{\\rm end}} e^{-N_{reh}} \\left( \\frac{g_{*,S}(T_0)}{g_{*,S}(T_{{\\rm reh}})}\\right)^{1/3} \\frac{T_0}{T_{{\\rm reh}}} \\, .\n$$</p>\n\n<p>where</p>\n\n<p>$$\nN_{\\rm reh} = \\frac{1}{3(1 + w_{\\rm reh})} \\ln \\left(\\frac{90 M_{\\rm P} H_{\\rm end}^2}{\\pi^2 g_*(T_{\\rm reh}) T_{\\rm reh}^4} \\right) \\, .\n$$\nand $T_{\\rm reh}$ is the temperature of the SM plasma at the end of reheating.</p>\n"}, {"fullname": "geff.tools.gw.omega_gw", "modulename": "geff.tools.gw", "qualname": "omega_gw", "kind": "function", "doc": "<p>Compute $h^2 \\Omega_{\\rm GW}(f)$ from a tensor power spectrum.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>k</strong> (NDarray):\nmomenta in Planck units</li>\n<li><strong>PT</strong> (NDarray):\nthe tensor power spectrum at the end of inflation as a function of momentum</li>\n<li><strong>Nend</strong> (float):\nthe number of e-folds at the end of inflation</li>\n<li><strong>Hend</strong> (float):\nthe Hubble rate at the end of inflation (in Planck units)</li>\n<li><strong>Trh</strong> (None or float):\nthe reheating temperature in GeV. If None, instantaneous reheating is assumed.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>f</strong> (NDarray):\nfrequencies today (in Hz)</li>\n<li><strong>h2OmegaGw</strong> (NDarray):\nthe gravitational-wave spectrum as a function of frequency today</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">PT</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">Nend</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">Hend</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">Trh</span><span class=\"p\">:</span> <span class=\"kc\">None</span> <span class=\"o\">|</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.tools.gw.k_to_f", "modulename": "geff.tools.gw", "qualname": "k_to_f", "kind": "function", "doc": "<p>Compute frequency today from momentum at the end of inflation</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>k</strong> (NDarray):\nmomenta in Planck units</li>\n<li><strong>Nend</strong> (float):\nthe number of e-folds at the end of inflation</li>\n<li><strong>Hend</strong> (float):\nthe Hubble rate at the end of inflation</li>\n<li><strong>Trh</strong> (None or float):\nthe reheating temperature in GeV. If None, instantaneous reheating is assumed.</li>\n</ul>\n\n<h6 id=\"return\">Return</h6>\n\n<p>f : NDarray\n    frequencies today (in Hz)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">Nend</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">Hend</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">Trh</span><span class=\"p\">:</span> <span class=\"kc\">None</span> <span class=\"o\">|</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">_typing</span><span class=\"o\">.</span><span class=\"n\">_array_like</span><span class=\"o\">.</span><span class=\"n\">_Buffer</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">_typing</span><span class=\"o\">.</span><span class=\"n\">_array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">_typing</span><span class=\"o\">.</span><span class=\"n\">_nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">_typing</span><span class=\"o\">.</span><span class=\"n\">_array_like</span><span class=\"o\">.</span><span class=\"n\">_SupportsArray</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]]],</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">complex</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">_typing</span><span class=\"o\">.</span><span class=\"n\">_nested_sequence</span><span class=\"o\">.</span><span class=\"n\">_NestedSequence</span><span class=\"p\">[</span><span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"nb\">int</span> <span class=\"o\">|</span> <span class=\"nb\">float</span> <span class=\"o\">|</span> <span class=\"nb\">complex</span> <span class=\"o\">|</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"nb\">bytes</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.tools.pt", "modulename": "geff.tools.pt", "kind": "module", "doc": "<p>This module is designed to compute the tensor power spectrum from a GEF result.</p>\n\n<p>The polarized tensor power spectrum at time $t$ with momentum $k$ is given by\n$$\\mathcal{P}_{T}(t, k) = \\mathcal{P}_{T}^{\\mathrm{vac}}(t, k) + \\frac{1}{2}\\sum_{\\lambda=\\pm 1} \\mathcal{P}_{T,\\lambda}^{\\mathrm{ind}}(t, k)\\, ,$$\nwhere $\\lambda$ labels the helicity of tensor modes.</p>\n\n<p>The vacuum contribution is given by\n$$\\mathcal{P}_{T,\\lambda}^{\\mathrm{vac}}(t, k) = \\frac{4 k^3}{\\pi^2 M_{\\rm P}^2} |u_0(t, k)|^2\\, ,$$\nwhile the induced contribution is\n$$\\mathcal{P}_{T,\\lambda}^{\\mathrm{ind}}(t, k) = \\frac{k^3}{2 \\pi^2 M_{\\rm P}^4} \\int \\frac{{\\rm d}^3 {\\bf p}}{(2 \\pi)^3} \\sum_{\\alpha,\\beta = \\pm1} \n        \\left(1 +  \\lambda \\alpha \\frac{{\\bf k} \\cdot {\\bf p}}{k p} \\right)^2 \\left(1 +  \\lambda \\beta \\frac{k^2 - {\\bf k} \\cdot {\\bf p}}{kq}  \\right)^2 $$\n$$ \\qquad \\qquad \\qquad \\times \\left|\\int_{-\\infty}^\\infty {\\rm d} s \\frac{G_k(t, s)}{a^3(s)} \n    \\left[A'_\\alpha(s, p)A'_\\beta(s, q) + \\alpha \\beta\\, p q\\, A_\\alpha(s, p) A_\\alpha(s, q) \\right] \\right|^2 \\, ,\n$$\nwith momentum $q = |{\\bf p} + {\\bf q}|$ and scale-factor $a$.</p>\n\n<p>The vacuum modes $u_0(t,k)$ obey the mode equation\n$$\\mathcal{D}_k {u_0} = \\ddot{u}_0 + 3 H \\dot{u}_0 + \\frac{k^2}{a^2} {u_0} = 0$$\nwith the retarded Green function $G_k(t',t)$ defined for the operator $\\mathcal{D}_k$.</p>\n\n<p>The gauge-field mode functions $A_\\lambda(t,k)$ are defined as in the <code>geff.mode_by_mode</code> module.</p>\n\n<p>For details on the numerical computation, see the Appendix B of <a href=\"https://arxiv.org/abs/2508.00798\">2508.00798</a>.</p>\n"}, {"fullname": "geff.tools.pt.PowSpecT", "modulename": "geff.tools.pt", "qualname": "PowSpecT", "kind": "class", "doc": "<p>A class used to compute the tensor power spectrum including vacuum and gauge-field induced contributions.</p>\n\n<p>These main method of this module is <code>compute_pt</code>, which computes both the vacuum and gauge-field induced contribution\n  to the tensor power spectrum, $\\mathcal{P}_{T,\\lambda}^{\\mathrm{vac}}$ and $\\mathcal{P}_{T,\\lambda}^{\\mathrm{ind}}$.</p>\n\n<p>Results are internally computed using numerical units, but are returned in physical units.</p>\n"}, {"fullname": "geff.tools.pt.PowSpecT.__init__", "modulename": "geff.tools.pt", "qualname": "PowSpecT.__init__", "kind": "function", "doc": "<p>Initialise the class from a GEF solution.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>insys</strong> (BGSystem):\nthe GEF solution.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">insys</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">bgtypes</span><span class=\"o\">.</span><span class=\"n\">BGSystem</span></span>)</span>"}, {"fullname": "geff.tools.pt.PowSpecT.compute_pt", "modulename": "geff.tools.pt", "qualname": "PowSpecT.compute_pt", "kind": "function", "doc": "<p>Compute the full tensor power spectrum.</p>\n\n<p>The method lodes data on gauge modes $A_\\lambda(t,k)$ from a file indicated by <code>mbm_file</code>.\nThe power spectrum is evaluated fpr <code>nmodes</code> log-spaced momenta $k \\in [10^{4}a(0)H(0), 10 a(t_{\\rm max}) H(t_{\\rm max})]$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>nmodes</strong> (NDArray):\nthe number of momenta</li>\n<li><strong>ModePath</strong> (str):\npath to a file containing gauge-field mode functions</li>\n<li><strong>FastGW</strong> (bool):\nIf <code>True</code>, only the expected dominant contributions to $\\mathcal{P}_{T,\\lambda}^{\\mathrm{ind}}$ are computed</li>\n<li><strong>atols</strong> (list):\nabsolute tolerance for <code>compute_homogeneous</code> (index 0) and <code>compute_green</code> (index 1)</li>\n<li><strong>rtols</strong> (list):\nrelative tolerance for <code>compute_homogeneous</code> (index 0) and <code>compute_green</code> (index 1)</li>\n<li><strong>momgrid</strong> (int):\npassed to <code>compute_ptind</code></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ks</strong> (NDArray):\nthe momenta $k$</li>\n<li><strong>PT</strong> (dict):\na dictionary containing all contributions to the tensor power spectrum and its total.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">nmodes</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">spec</span><span class=\"p\">:</span> <span class=\"n\">geff</span><span class=\"o\">.</span><span class=\"n\">mbm</span><span class=\"o\">.</span><span class=\"n\">GaugeSpec</span>,</span><span class=\"param\">\t<span class=\"n\">FastGW</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">atols</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.001</span><span class=\"p\">,</span> <span class=\"mf\">1e-20</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">rtols</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.0001</span><span class=\"p\">,</span> <span class=\"mf\">0.0001</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">momgrid</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.tools.pt.PowSpecT.compute_homogeneous", "modulename": "geff.tools.pt", "qualname": "PowSpecT.compute_homogeneous", "kind": "function", "doc": "<p>Compute the evolution of a vacuum mode starting from Bunch&ndash;Davies vacuum.</p>\n\n<p>For a mode $u_0(t,k)$ with momentum $k$, initialise in Bunch&ndash;Davies when $k = 10^{5/2} a(t_{\\rm vac})H(t_{\\rm vac})$.\nIts evolution is obtained by solving <code>tensor_mode_eq</code> using <code>scipy.integrate.solve_ivp</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>k</strong> (float):\nthe momentum $k$.</li>\n<li><strong>tvac</strong> (float):\nthe initial time, $t_{\\rm init}$</li>\n<li><strong>teval</strong> (NDArray or None):\ntime coordinates $t$ of $u_0(t,k)$ (<code>None</code>: same as class input <code>sys</code>)</li>\n<li><strong>atol</strong> (float):\nthe absolute tolerance for <code>solve_ivp</code></li>\n<li><strong>rtol</strong> (float):\nthe relative tolerance for <code>solve_ivp</code></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>u</strong> (NDArray):\nthe vacuum tensor modes, $\\sqrt{2k}u(t, k)$</li>\n<li><strong>duk</strong> (NDArray):\nthe derivative of the vacuum tensor modes, $a\\sqrt{2/k}\\dot{u}(t, k)$</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">tvac</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">teval</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">atol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.001</span>,</span><span class=\"param\">\t<span class=\"n\">rtol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0001</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.tools.pt.PowSpecT.tensor_mode_eq", "modulename": "geff.tools.pt", "qualname": "PowSpecT.tensor_mode_eq", "kind": "function", "doc": "<p>Mode equation for vacuum tensor modes.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>y</strong> (NDArray):\nthe vacuum tensor mode and its derivatives.\n$a \\sqrt{2k} u_0(t,k)$ and $ a^2\\sqrt{2/k} \\dot{u}_0(t, k)$</li>\n<li><strong>k</strong> (float):\ncomoving momentum $k$</li>\n<li><strong>H</strong> (float):\nHubble rate, $H(t)$</li>\n<li><strong>a</strong> (float):\nscale factor, $a(t)$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dydt</strong> (NDArray):\nan array of time derivatives of y</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.tools.pt.PowSpecT.compute_green", "modulename": "geff.tools.pt", "qualname": "PowSpecT.compute_green", "kind": "function", "doc": "<p>Compute the evolution of the Green function $G_k(t',t)$ for fixed $t'$.</p>\n\n<p>The evolution is obtained by solving <code>green_ode</code> from $t=t'$ backwards until $t_{\\rm vac}$, defined through $k = 10^{5/2} a(t_{\\rm end})H(t_{\\rm vac})$.\nFrom $t_{\\rm end}$ onwards, the Green function is instead computed from the mode $u_0(t, k)$. The method uses <code>scipy.integrate.solve_ivp</code>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>k</strong> (float):\nthe momentum $k$.</li>\n<li><strong>uk</strong> (NDArray):\nthe mode function $u_0(t,k)$</li>\n<li><strong>tvac</strong> (float):\nthe final time, $t_{\\rm vac}$</li>\n<li><strong>teval</strong> (NDArray or None):\ntime coordinates $t$ of $G_k(t',t)$ (<code>None</code>: same as class input <code>sys</code>)</li>\n<li><strong>ind</strong> (int):\nindex of teval corresponding to $t'$</li>\n<li><strong>atol</strong> (float):\nthe absolute tolerance for <code>solve_ivp</code></li>\n<li><strong>rtol</strong> (float):\nthe relative tolerance for <code>solve_ivp</code></li>\n</ul>\n\n<h6 id=\"return\">Return</h6>\n\n<p>GreenN : NDArray\n    the Green function $-k G_k(t', t)$</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">uk</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">tvac</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">teval</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ind</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">atol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-30</span>,</span><span class=\"param\">\t<span class=\"n\">rtol</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0001</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.tools.pt.PowSpecT.green_ode", "modulename": "geff.tools.pt", "qualname": "PowSpecT.green_ode", "kind": "function", "doc": "<p>Evolve the re-scaled Green function for tensor modes in time.</p>\n\n<p>The re-scaled Green function is\n$$B_{t'}^k(t) = 2 k a(t)^2 \\operatorname{Im} \\left[ u_0^*(t', k) \\, u_0(t,k) \\right] = k G_k(t', t) \\,.$$</p>\n\n<p>whose ODE is coupled to </p>\n\n<p>$$C_{t'}^k(t) = 2 a(t)^3 \\operatorname{Im} \\left[ u_0^*(t', k) \\, {\\dot{u}_0}(t,k) \\right] \\,.$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>y</strong> (NDArray):\nthe functions B and C</li>\n<li><strong>k</strong> (float):\ncomoving momentum $k$</li>\n<li><strong>H</strong> (float):\nHubble rate, $H(t)$</li>\n<li><strong>a</strong> (float):\nscale factor, $a(t)$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dydt</strong> (NDArray):\nan array of time derivatives of A</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.tools.pt.PowSpecT.compute_ptvac", "modulename": "geff.tools.pt", "qualname": "PowSpecT.compute_ptvac", "kind": "function", "doc": "<p>Compute the vacuum power spectrum, $\\mathcal{P}_{T,\\lambda}^{\\mathrm{vac}}(t,k)$.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>k</strong> (NDArray):\nmomentum, $k$</li>\n<li><strong>uk</strong> (NDArray):\nvacuum tensor mode $u_0(t,k)$</li>\n</ul>\n\n<h6 id=\"return\">Return</h6>\n\n<p>PTvac : NDArray\n    the vacuum tensor power spectrum</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">uk</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.tools.pt.PowSpecT.compute_ptind", "modulename": "geff.tools.pt", "qualname": "PowSpecT.compute_ptind", "kind": "function", "doc": "<p>Compute the vacuum power spectrum, $\\mathcal{P}_{T,\\lambda}^{\\mathrm{vac}}(t,k)$.</p>\n\n<p>The integral is computed by integrating over the inner integral over the gauge-mode functions $A_\\mu(s,p)$ using <code>scipy.integrate.trapezoid</code>.\nThe external momentum integrals are also computed using <code>scipy.integrate.trapezoid</code> on a grid of momenta momgrid x momgrid. The mode functions\nare interpolated over momentum to match this grid.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>k</strong> (float):\nmomentum $k$</li>\n<li><strong>lgrav</strong> (NDArray):\nhelicity $\\lambda$</li>\n<li><strong>Ngrid</strong> (NDArray):\n$e$-folds $\\log a$</li>\n<li><strong>ind</strong> (integer):\nthe power spectrum is computed at $t$ corresponding to <code>Ngrid[ind]</code></li>\n<li><strong>GreenN</strong> (NDArray):\nthe Green function $kG_k(t, s)$ with $s$ corresponding to <code>Ngrid</code></li>\n<li><strong>pgrid</strong> (NDArray):\nmomenta $p$ for the mode functions $A_\\mu(s,p)$</li>\n<li><strong>l1, l2</strong> (float):\nthe gauge-field helicities $\\mu_1$, $\\mu_2$</li>\n<li><strong>A1, A2</strong> (float):\nthe gauge-field mode functions $\\sqrt{2k} A_{\\mu_1, \\mu_2}(s, p)$</li>\n<li><strong>dA1, dA2</strong> (float):\nthe gauge-field mode function derivatives $a(s)\\sqrt{2/k} \\dot{A}_{\\mu_1, \\mu_2}(s, p)$</li>\n<li><strong>momgrid</strong> (int):\nthe grid size for the momentum integrals.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>PTind</strong> (float):\nthe gauge-field induced tensor power spectrum</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">lgrav</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">Ngrid</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">ind</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">GreenN</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">pgrid</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">l1</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">A1</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">dA1</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">l2</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">A2</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">dA2</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">momgrid</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility", "modulename": "geff.utility", "kind": "module", "doc": "<p>This module defines often encountered functions and constants for the <code>geff</code>.</p>\n\n<p>For detailed documentation, see the different submodules.</p>\n"}, {"fullname": "geff.utility.boundary", "modulename": "geff.utility.boundary", "kind": "module", "doc": "<p>This module facilitates computing boundary terms which appear when computing the evolution of gauge-field bilinears like $\\langle {\\bf E}^2 \\rangle$\ndue to the time dependence of the UV-regulator scale $k_{\\rm h}$.</p>\n\n<p>All functions in this module return the same quantities, namely\n$$E_\\lambda(\\xi, s) = \\frac{1}{r^2}\\left| (i r - i \\lambda \\xi - s) W_{-i \\lambda \\xi, \\frac{1}{2} + s}(-2 i r) + W_{1-i \\lambda \\xi, 1/2 + s}(-2 i r) \\right|^2 \\, , $$\n$$B_\\lambda(\\xi, s) = \\left| W_{-i \\lambda \\xi, \\frac{1}{2} + s}(-2 i r) \\right|^2 \\, , $$\n$$G_\\lambda(\\xi, s) = \\frac{1}{r}\\left[\\operatorname{Re}\\left[W_{1-i \\lambda \\xi, 1/2 + s}(-2 i r) W_{i \\lambda \\xi, \\frac{1}{2} + s}(2 i r)\\right] -  s \\left| W_{-i \\lambda \\xi, \\frac{1}{2} + s}(-2 i r)\\right|^2 \\right]\\, ,$$\nwith $r = |\\xi| + \\sqrt{\\xi^2 + s^2 + s}$, the Whittaker-W function $W_{\\kappa, \\mu}(x)$,the instability parameter  $\\xi$ , and $s= \\sigma_{\\rm E}/(2H)$ an effective electric conductivity.</p>\n\n<p>The functions in this module return an array of shape (3,2), with the first index corresponding to $E$, $B$, $G$ and the second index to helicity $\\lambda=\\pm 1$.</p>\n"}, {"fullname": "geff.utility.boundary.boundary_pai", "modulename": "geff.utility.boundary", "qualname": "boundary_pai", "kind": "function", "doc": "<p>Compute boundary terms in the absence of Schwinger pair production.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.boundary.boundary_fai", "modulename": "geff.utility.boundary", "qualname": "boundary_fai", "kind": "function", "doc": "<p>Compute boundary terms including Schwinger pair production.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span>, </span><span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.boundary.boundary_exact", "modulename": "geff.utility.boundary", "qualname": "boundary_exact", "kind": "function", "doc": "<p>Compute boundary terms using exact Whittaker functions.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>xi</strong> (float):</p></li>\n<li><p><strong>s</strong> (float):</p></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>W</strong> (NDArray):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.boundary.boundary_approx_pai", "modulename": "geff.utility.boundary", "qualname": "boundary_approx_pai", "kind": "function", "doc": "<p>Use approximate formulas to compute boundary terms for $|\\xi| &gt; 3$ and $s=0$.</p>\n\n<p>The approximations are taken from the Appendix B in <a href=\"https://arxiv.org/abs/2109.01651\">2109.01651</a>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>xi</strong> (float):</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>W</strong> (NDArray):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.boundary.boundary_approx_fai", "modulename": "geff.utility.boundary", "qualname": "boundary_approx_fai", "kind": "function", "doc": "<p>Use approximate formulas to compute boundary terms for  $|\\xi| &gt; 4$ and arbitrary $s$.</p>\n\n<p>The approximations are taken from the Appendix B in <a href=\"https://arxiv.org/abs/2109.01651\">2109.01651</a>.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>xi</strong> (float):</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>W</strong> (NDArray):</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">xi</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.cosmo", "modulename": "geff.utility.cosmo", "kind": "module", "doc": "<p>This module defines constants and functions which are often times encountered in cosmology. These are primarily used in <code>GEFF.tools.gw</code></p>\n"}, {"fullname": "geff.utility.cosmo.G", "modulename": "geff.utility.cosmo", "qualname": "G", "kind": "variable", "doc": "<p>Newtons constant in GeV.</p>\n", "annotation": ": float", "default_value": "np.float64(6.708830746231456e-39)"}, {"fullname": "geff.utility.cosmo.M_pl", "modulename": "geff.utility.cosmo", "qualname": "M_pl", "kind": "variable", "doc": "<p>The reduced Planck mass in GeV.</p>\n", "annotation": ": float", "default_value": "np.float64(2.4353234600842885e+18)"}, {"fullname": "geff.utility.cosmo.gev_to_hz", "modulename": "geff.utility.cosmo", "qualname": "gev_to_hz", "kind": "variable", "doc": "<p>The conversion factor between Hz and GeV.</p>\n", "annotation": ": float", "default_value": "np.float64(1.519267447878626e+24)"}, {"fullname": "geff.utility.cosmo.T_0", "modulename": "geff.utility.cosmo", "qualname": "T_0", "kind": "variable", "doc": "<p>The temperatur of CMB photons today (in GeV).</p>\n", "annotation": ": float", "default_value": "np.float64(2.348654180597668e-13)"}, {"fullname": "geff.utility.cosmo.h", "modulename": "geff.utility.cosmo", "qualname": "h", "kind": "variable", "doc": "<p>The reduced Hubble parameter $h$ (from <a href=\"https://arxiv.org/abs/1807.06209\">Planck 2018</a>).</p>\n", "annotation": ": float", "default_value": "0.674"}, {"fullname": "geff.utility.cosmo.H0", "modulename": "geff.utility.cosmo", "qualname": "H0", "kind": "variable", "doc": "<p>The Hubble rate today (in GeV).</p>\n", "annotation": ": float", "default_value": "np.float64(1.4377226630738714e-42)"}, {"fullname": "geff.utility.cosmo.g_rho", "modulename": "geff.utility.cosmo", "qualname": "g_rho", "kind": "function", "doc": "<p>Effective number of relativistic degrees of freedom as a function of temperature, $g_{*}(T)$.</p>\n\n<p>Data is taken from <a href=\"https://arxiv.org/abs/2005.03544\">2005.03544</a>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">T</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.cosmo.g_s", "modulename": "geff.utility.cosmo", "qualname": "g_s", "kind": "function", "doc": "<p>Effective number of entropic degrees of freedom as a function of temperature, $g_{*,S}(T)$.</p>\n\n<p>Data is taken from <a href=\"https://arxiv.org/abs/2005.03544\">2005.03544</a>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">T</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.cosmo.g_rho_freq", "modulename": "geff.utility.cosmo", "qualname": "g_rho_freq", "kind": "function", "doc": "<p>Effective number of relativistic degrees of freedom as a function of frequency, $g_{*}(T(f))$.</p>\n\n<p>Data is taken from <a href=\"https://arxiv.org/abs/2005.03544\">2005.03544</a>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.cosmo.g_s_freq", "modulename": "geff.utility.cosmo", "qualname": "g_s_freq", "kind": "function", "doc": "<p>Effective number of entropic degrees of freedom as a function of frequency, $g_{*,S}(T(f))$.</p>\n\n<p>Data is taken from <a href=\"https://arxiv.org/abs/2005.03544\">2005.03544</a>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.cosmo.g_rho_0", "modulename": "geff.utility.cosmo", "qualname": "g_rho_0", "kind": "variable", "doc": "<p>The effective number of relativistic degrees of freedom today, $g_{*}(T_0)$.</p>\n", "annotation": ": float", "default_value": "np.float64(3.38308)"}, {"fullname": "geff.utility.cosmo.g_s_0", "modulename": "geff.utility.cosmo", "qualname": "g_s_0", "kind": "variable", "doc": "<p>The effective number of entropic degrees of freedom today, $g_{*,S}(T_0)$.</p>\n", "annotation": ": float", "default_value": "np.float64(3.93094)"}, {"fullname": "geff.utility.cosmo.omega_r", "modulename": "geff.utility.cosmo", "qualname": "omega_r", "kind": "variable", "doc": "<p>The density parameter for radiation today, $\\Omega_r$.</p>\n", "annotation": ": float", "default_value": "np.float64(9.208359428041601e-05)"}, {"fullname": "geff.utility.cosmo.feq", "modulename": "geff.utility.cosmo", "qualname": "feq", "kind": "variable", "doc": "<p>Frequency corresponding to mattter-radiation equality</p>\n", "default_value": "2.1e-17"}, {"fullname": "geff.utility.eom", "modulename": "geff.utility.eom", "kind": "module", "doc": "<p>A module containing equations of motions for common quantities in GEF models.</p>\n"}, {"fullname": "geff.utility.eom.friedmann", "modulename": "geff.utility.eom", "qualname": "friedmann", "kind": "function", "doc": "<p>Calculate the Hubble rate $H$ from the Friedmann equation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rhos</strong>: list of energy densities</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>H</strong> (float):\nthe Hubble rate</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">rhos</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.eom.check_accelerated_expansion", "modulename": "geff.utility.eom", "qualname": "check_accelerated_expansion", "kind": "function", "doc": "<p>Compute $6 M_{\\rm P}^2 \\ddot{a}/a$.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rhos</strong> (list):\nenergy densities</li>\n<li><strong>ps</strong> (list):\npressures</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rhos</span>, </span><span class=\"param\"><span class=\"n\">ps</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.eom.klein_gordon", "modulename": "geff.utility.eom", "qualname": "klein_gordon", "kind": "function", "doc": "<p>Calculate the Klein&ndash;Gordon equation (including gauge-field friction).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dphi</strong> (float):\nthe inflaton velocity, $\\dot{\\varphi}$</li>\n<li><strong>dV</strong> (float):\nthe inflaton potential gradient, $V_{,\\varphi}$</li>\n<li><strong>H</strong> (float):\nthe Hubble rate, $H$</li>\n<li><strong>friction</strong> (float):\nfriction term, (e.g., $\\beta/M_{\\rm P} \\langle {\\bf E}\\cdot {\\bf B} \\rangle$)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ddphi</strong> (float):\nthe inflaton acceleration $\\ddot{\\varphi}$</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dphi</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">dV</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">friction</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.eom.dlnkh", "modulename": "geff.utility.eom", "qualname": "dlnkh", "kind": "function", "doc": "<p>Calculate the ${\\rm d} \\log k_{\\rm h} / {\\rm d}t$.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kh</strong> (float):\nthe instability scale $k_{\\rm h}$</li>\n<li><strong>dphi</strong> (float):\nthe inflaton velocity, $\\dot{\\varphi}$</li>\n<li><strong>ddphi</strong> (float):\nthe inflaton acceleration, $\\ddot{\\varphi}$</li>\n<li><strong>dI</strong> (float):\nthe inflaton--gauge-field coupling, $I_{,\\varphi}$</li>\n<li><strong>ddI</strong> (float):\nderivative of the inflaton--gauge-field coupling, $I_{,\\varphi \\varphi}$</li>\n<li><strong>xi</strong> (float):\nthe instability parameter, $\\xi$</li>\n<li><strong>a</strong> (float):\nthe scale factor, $a$</li>\n<li><strong>H</strong> (float):\nthe Hubble rate, $H$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dlnkh</strong> (float):\n${\\rm d} \\log k_{\\rm h} / {\\rm d}t$.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kh</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">dphi</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">ddphi</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">dI</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">ddI</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">xi</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.eom.gauge_field_ode", "modulename": "geff.utility.eom", "qualname": "gauge_field_ode", "kind": "function", "doc": "<p>Calculate the derivative of</p>\n\n<p>$$\\mathcal{F}_\\mathcal{E}^{(n)} =  \\frac{a^4}{k_{\\mathrm{h}}^{n+4}}\\langle {\\bf E} \\cdot \\operatorname{rot}^n {\\bf E}\\rangle \\,  ,$$\n$$\\mathcal{F}_\\mathcal{B}^{(n)} =  \\frac{a^4}{k_{\\mathrm{h}}^{n+4}}\\langle {\\bf B} \\cdot \\operatorname{rot}^n {\\bf B}\\rangle \\, , $$\n$$\\mathcal{F}_\\mathcal{G}^{(n)} =  -\\frac{a^4}{2 k_{\\mathrm{h}}^{n+4}}\\langle {\\bf E} \\cdot \\operatorname{rot}^n {\\bf B} + {\\bf B} \\cdot \\operatorname{rot}^n {\\bf E}\\rangle \\, . $$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>F</strong> (NDArray):\narray [$\\mathcal{F}_\\mathcal{E}^{(n)}$, $\\mathcal{F}_\\mathcal{B}^{(n)}$, $\\mathcal{F}_\\mathcal{G}^{(n)}$] in shape (3,ntr)</li>\n<li><strong>a</strong> (float):\nthe scale factor, $a$</li>\n<li><strong>kh</strong> (float):\nthe instability scale $k_{\\rm h}$</li>\n<li><strong>sclrCpl</strong> (float):\nthe inflaton gauge-field coupling, $2H\\xi$</li>\n<li><strong>W</strong> (NDarray):\nboundary terms, shape (3,2)</li>\n<li><strong>dlnkhdt</strong> (float):\nlogarithmic derivative of the instability scale, ${\\rm d} \\log k_{\\rm h} / {\\rm d}t$</li>\n<li><strong>L</strong> (int):\npolynomial order for closing ode at ntr</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dFdt</strong> (NDArray):\nthe time derivative of [$\\mathcal{F}_\\mathcal{E}^{(n)}$, $\\mathcal{F}_\\mathcal{B}^{(n)}$, $\\mathcal{F}_\\mathcal{G}^{(n)}$], shape (3,ntr)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">F</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">kh</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">sclrCpl</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">W</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">dlnkhdt</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">L</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.eom.dlnkh_schwinger", "modulename": "geff.utility.eom", "qualname": "dlnkh_schwinger", "kind": "function", "doc": "<p>Calculate the ${\\rm d} \\log k_{\\rm h} / {\\rm d}t$ in presence of conductivities.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kh</strong> (float):\nthe instability scale $k_{\\rm h}$</li>\n<li><strong>dphi</strong> (float):\nthe inflaton velocity, $\\dot{\\varphi}$</li>\n<li><strong>ddphi</strong> (float):\nthe inflaton acceleration, $\\ddot{\\varphi}$</li>\n<li><strong>dI</strong> (float):\nthe inflaton--gauge-field coupling, $I_{,\\varphi}$</li>\n<li><strong>ddI</strong> (float):\nderivative of the inflaton--gauge-field coupling, $I_{,\\varphi \\varphi}$</li>\n<li><strong>xieff</strong> (float):\nthe effective instability parameter, $\\xi + \\sigma_{\\rm B}/(2H)$</li>\n<li><strong>s</strong> (float or val):\nthe effective electric conductivity, $\\sigma_{\\rm E}/(2H)$</li>\n<li><strong>a</strong> (float):\nthe scale factor, $a$</li>\n<li><strong>H</strong> (float):\nthe Hubble rate, $H$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dlnkh</strong> (float):\n${\\rm d} \\log k_{\\rm h} / {\\rm d}t$.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kh</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">dphi</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">ddphi</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">dI</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">ddI</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">xieff</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.eom.ddelta", "modulename": "geff.utility.eom", "qualname": "ddelta", "kind": "function", "doc": "<p>Calculate the derivative of the cumulative electric damping, $\\Delta = \\exp \\left(-\\int \\sigma_{\\rm E} {\\rm d} t\\right)$.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>delta</strong> (float):\ncumulative electric damping, $\\Delta$</li>\n<li><strong>sigmaE</strong> (float):\nelectric conductivity, $\\sigma_{\\rm E}$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>ddelta</strong> (float):\nthe time derivative of $\\Delta$</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">delta</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">sigmaE</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.eom.drhoChi", "modulename": "geff.utility.eom", "qualname": "drhoChi", "kind": "function", "doc": "<p>Calculate the derivative of the fermion energy density.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rhoChi</strong> (float):\nthe fermion energy density, $\\rho_{\\chi}$</li>\n<li><strong>E</strong> (float):\nthe electric field expecation value, $\\langle {\\bf E}^2 \\rangle$</li>\n<li><strong>G</strong> (float):\nthe expectation value of $-\\langle {\\bf E} \\cdot {\\bf B} \\rangle$</li>\n<li><strong>sigmaE</strong> (float):\nelectric conductivity, $\\sigma_{\\rm E}$</li>\n<li><strong>sigmaB</strong> (float):\nmagnetic conductivity, $\\sigma_{\\rm B}$</li>\n<li><strong>H</strong> (float):\nthe Hubble rate, $H$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: the time derivative of rhoChi</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rhoChi</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">E</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">G</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">sigmaE</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">sigmaB</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.eom.gauge_field_ode_schwinger", "modulename": "geff.utility.eom", "qualname": "gauge_field_ode_schwinger", "kind": "function", "doc": "<p>Calculate the derivative of</p>\n\n<p>$$\\mathcal{F}_\\mathcal{E}^{(n)} =  \\frac{a^4}{k_{\\mathrm{h}}^{n+4}}\\langle {\\bf E} \\cdot \\operatorname{rot}^n {\\bf E}\\rangle \\,  ,$$\n$$\\mathcal{F}_\\mathcal{B}^{(n)} =  \\frac{a^4}{k_{\\mathrm{h}}^{n+4}}\\langle {\\bf B} \\cdot \\operatorname{rot}^n {\\bf B}\\rangle \\, , $$\n$$\\mathcal{F}_\\mathcal{G}^{(n)} =  -\\frac{a^4}{2 k_{\\mathrm{h}}^{n+4}}\\langle {\\bf E} \\cdot \\operatorname{rot}^n {\\bf B} + {\\bf B} \\cdot \\operatorname{rot}^n {\\bf E}\\rangle \\, , $$</p>\n\n<p>in the presence of Schwinger conductivities.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>F</strong> (NDArray):\narray [$\\mathcal{F}_\\mathcal{E}^{(n)}$, $\\mathcal{F}_\\mathcal{B}^{(n)}$, $\\mathcal{F}_\\mathcal{G}^{(n)}$] in shape (3,ntr)</li>\n<li><strong>a</strong> (float):\nthe scale factor, $a$</li>\n<li><strong>kh</strong> (float):\nthe instability scale $k_{\\rm h}$</li>\n<li><strong>sclrCpl</strong> (float):\nthe inflaton gauge-field coupling, $2H\\xi_{\\rm eff}$</li>\n<li><strong>delta</strong> (float):\ncumulative electric damping, $\\Delta$</li>\n<li><strong>W</strong> (NDarray):\nboundary terms, shape (3,2)</li>\n<li><strong>dlnkhdt</strong> (float):\nlogarithmic derivative of the instability scale, ${\\rm d} \\log k_{\\rm h} / {\\rm d}t$</li>\n<li><strong>L</strong> (int):\npolynomial order for closing ode at ntr</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dFdt</strong> (NDArray):\nthe time derivative of [$\\mathcal{F}_\\mathcal{E}^{(n)}$, $\\mathcal{F}_\\mathcal{B}^{(n)}$, $\\mathcal{F}_\\mathcal{G}^{(n)}$], shape (3,ntr)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">F</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">kh</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">sclrCpl</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">sigmaE</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">delta</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">W</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">dlnkhdt</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">L</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.eom.conductivities_collinear", "modulename": "geff.utility.eom", "qualname": "conductivities_collinear", "kind": "function", "doc": "<p>Compute electric &amp; magnetic conductivities and the damping scale $k_{\\rm S}$\nassuming collinear E &amp; M fields.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>a</strong> (float):\nthe scale factor, $a$</li>\n<li><strong>H</strong> (float):\nthe Hubble rate, $H$</li>\n<li><strong>E</strong> (float):\nthe electric field expecation value, $\\langle {\\bf E}^2 \\rangle$</li>\n<li><strong>E</strong> (float):\nthe magnetic field expecation value, $\\langle {\\bf B}^2 \\rangle$</li>\n<li><strong>G</strong> (float):\nthe expectation value of $-\\langle {\\bf E} \\cdot {\\bf B} \\rangle$</li>\n<li><strong>picture</strong> (int):\nan integer specifying electric (=-1) or magnetic pictures (=1)</li>\n<li><strong>omega</strong> (float):\nthe reference frequency to convert from numerical to physical units</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: the electric damping, $\\sigma_{\\rm E}$</li>\n<li><strong>float</strong>: the magnetic damping, $\\sigma_{\\rm B}$</li>\n<li><strong>float</strong>: the damping scale, $k_{\\rm S}$</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">E</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">B</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">G</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">picture</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">omega</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.eom.conductivities_mixed", "modulename": "geff.utility.eom", "qualname": "conductivities_mixed", "kind": "function", "doc": "<p>Compute electric &amp; magnetic conductivities and the damping scale $k_{\\rm S}$\nin the mixed picture.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>a</strong> (float):\nthe scale factor, $a$</li>\n<li><strong>H</strong> (float):\nthe Hubble rate, $H$</li>\n<li><strong>E</strong> (float):\nthe electric field expecation value, $\\langle {\\bf E}^2 \\rangle$</li>\n<li><strong>E</strong> (float):\nthe magnetic field expecation value, $\\langle {\\bf B}^2 \\rangle$</li>\n<li><strong>G</strong> (float):\nthe expectation value of $-\\langle {\\bf E} \\cdot {\\bf B} \\rangle$</li>\n<li><strong>omega</strong> (float):\nthe reference frequency to convert from numerical to physical units</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: the electric damping, $\\sigma_{\\rm E}$</li>\n<li><strong>float</strong>: the magnetic damping, $\\sigma_{\\rm B}$</li>\n<li><strong>float</strong>: the damping scale, $k_{\\rm S}$</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">E</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">B</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">G</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">omega</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.general", "modulename": "geff.utility.general", "kind": "module", "doc": "<p>Some general purpose utility functions.</p>\n"}, {"fullname": "geff.utility.general.AuxTol", "modulename": "geff.utility.general", "qualname": "AuxTol", "kind": "class", "doc": "<p>A simple wrapper which passes absolute and relative tolerance parameters.</p>\n\n<p>Wraps a function <code>f(*args, rtol, atol)</code> to give <code>f(*args, self.rtol, self.atol)</code></p>\n"}, {"fullname": "geff.utility.general.AuxTol.atol", "modulename": "geff.utility.general", "qualname": "AuxTol.atol", "kind": "variable", "doc": "<p>Absolute tolerance</p>\n", "annotation": ": float", "default_value": "1e-20"}, {"fullname": "geff.utility.general.AuxTol.rtol", "modulename": "geff.utility.general", "qualname": "AuxTol.rtol", "kind": "variable", "doc": "<p>Relative tolerance</p>\n", "annotation": ": float", "default_value": "1e-06"}, {"fullname": "geff.utility.general.heaviside", "modulename": "geff.utility.general", "qualname": "heaviside", "kind": "variable", "doc": "<p>A smoothed version of the heaviside function.</p>\n\n<p>Returns 1 if x &gt; y and 0 if x &lt; y.</p>\n\n<p>The smoothness of the  transition is regulated by <code>max(abs(x)*rtol, atol))</code>.</p>\n\n<p>The function is wrapped by <code>AuxTol</code>, and will be updated according to the tolerances of a <code>GEFSolver</code>.</p>\n\n<p>It is vectorized using <code>numpy.vectorize</code></p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>x, y</strong> (floats):\nthe arguments of the heaviside function</li>\n<li><strong>rtol, atol</strong> (floats):\ntolerance parameters</li>\n</ul>\n", "default_value": "&lt;geff.utility.general.AuxTol object&gt;"}, {"fullname": "geff.utility.mode", "modulename": "geff.utility.mode", "kind": "module", "doc": "<p>A module defining equations used to define a <code>GEFF.mbm.ModeSolver</code>.</p>\n"}, {"fullname": "geff.utility.mode.bd_classic", "modulename": "geff.utility.mode", "qualname": "bd_classic", "kind": "function", "doc": "<p>Returns gauge-field modes in Bunch&ndash;Davies vacuum:</p>\n\n<p>$$A_\\lambda(k,t) \\sim \\frac{1}{\\sqrt{2k}}exp{(-i \\eta(t) k)}\\, , \\qquad -\\eta(t) k \\gg 1 \\, .$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime of initialisation $t_{\\rm init}$</li>\n<li><strong>k</strong> (float):\ncomoving momentum $k$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>y</strong> (NDArray):\n$\\sqrt{2k} A_\\lambda(t_{\\rm init},k)$ and $a\\sqrt{2/k} \\dot{A}_\\lambda(t_{\\rm init},k)$ in Bunch&ndash;Davies</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.mode.mode_equation_classic", "modulename": "geff.utility.mode", "qualname": "mode_equation_classic", "kind": "function", "doc": "<p>Mode equation for pure axion inflation:</p>\n\n<p>$$\\ddot{A}_\\lambda(t,k) + H \\dot{A}_\\lambda(t,k) + \\left[\\left(\\frac{k}{a}\\right)^2  - 2\\lambda \\left(\\frac{k}{a}\\right) \\xi H \\right]A_\\lambda(t,k) = 0 \\, .$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ncosmic time $t$</li>\n<li><strong>y</strong> (NDArray):\n$\\sqrt{2k} A_\\lambda(t_{\\rm init},k)$ and $a\\sqrt{2/k} \\dot{A}_\\lambda(t_{\\rm init},k)$</li>\n<li><strong>k</strong> (float):\ncomoving momentum $k$</li>\n<li><strong>a</strong> (Callable):\nscale factor as function of time, $a(t)$</li>\n<li><strong>xi</strong> (Callable):\ninstability parameter as function of time, $\\xi(t)$</li>\n<li><strong>H</strong> (Callable):\nHubble rate as function of time, $H(t)$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dydt</strong> (array):\nan array of time derivatives of y</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">xi</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.mode.damped_bd", "modulename": "geff.utility.mode", "qualname": "damped_bd", "kind": "function", "doc": "<p>Returns gauge-field modes in damped Bunch&ndash;Davies vaccum:</p>\n\n<p>$$A_\\lambda(k,t) \\sim \\sqrt{\\frac{\\Delta(t)}{2k}}exp{(-i \\eta(t) k)}\\, , \\qquad -\\eta(t) k \\gg 1 \\, .$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ntime of initialisation $t_{\\rm init}$</li>\n<li><strong>k</strong> (float):\ncomoving momentum $k$</li>\n<li><strong>a</strong> (Callable):\nscale factor as function of time, $a(t)$</li>\n<li><strong>sigmaE</strong> (Callable):\nelectric damping, $\\sigma_{\\rm E}(t)$</li>\n<li><strong>delta</strong> (Callable):\ncumulative electric damping $\\Delta(t) = \\exp{\\left(-\\int \\sigma_{\\rm E}(t) {\\rm d}t\\right)}$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>y</strong> (NDArray):\n$\\sqrt{2k} A_\\lambda(t_{\\rm init},k)$ and $a\\sqrt{2/k} \\dot{A}_\\lambda(t_{\\rm init},k)$ in Bunch&ndash;Davies</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">delta</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">sigmaE</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.mode.mode_equation_SE_no_scale", "modulename": "geff.utility.mode", "qualname": "mode_equation_SE_no_scale", "kind": "function", "doc": "<p>Mode equation for scale-dependent fermionic axion inflation:</p>\n\n<p>$$\\ddot{A}_\\lambda(t, k)  + \\big( H + \\sigma_{\\rm E} \\big) \\dot{A}_\\lambda(t, k) + \\left[ \\left(\\frac{k}{a}\\right)^2 - \\lambda \\frac{k}{a} \\big( 2 \\xi H + \\sigma_{\\rm B} \\big) \\right] A_\\lambda(t, k) = 0\\, .$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ncosmic time $t$</li>\n<li><strong>y</strong> (NDArray):\n$\\sqrt{2k} A_\\lambda(t_{\\rm init},k)$ and $a\\sqrt{2/k} \\dot{A}_\\lambda(t_{\\rm init},k)$</li>\n<li><strong>k</strong> (float):\ncomoving momentum $k$</li>\n<li><strong>a</strong> (Callable):\nscale factor as function of time, $a(t)$</li>\n<li><strong>xieff</strong> (Callable):\neffective instability parameter as function of time, $\\xi_{\\rm eff}(t)$</li>\n<li><strong>H</strong> (Callable):\nHubble rate as function of time, $H(t)$</li>\n<li><strong>sigmaE</strong> (Callable):\nelectric damping, $\\sigma_{\\rm E}(t)$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dydt</strong> (array):\nan array of time derivatives of y</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">xieff</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">sigmaE</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "geff.utility.mode.mode_equation_SE_scale", "modulename": "geff.utility.mode", "qualname": "mode_equation_SE_scale", "kind": "function", "doc": "<p>Mode equation for scale-independent fermionic axion inflation:</p>\n\n<p>$$\\ddot{A}_\\lambda(t, k)  + \\big( H + \\sigma_{\\rm E} \\Theta(t, k) \\big) \\dot{A}_\\lambda(t, k) + \\left[ \\left(\\frac{k}{a}\\right)^2 - \\lambda \\frac{k}{a} \\big( 2 \\xi H + \\sigma_{\\rm B}\\Theta(t, k) \\big) \\right] A_\\lambda(t, k) = 0\\, .$$</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\ncosmic time $t$</li>\n<li><strong>y</strong> (NDArray):\n$\\sqrt{2k} A_\\lambda(t_{\\rm init},k)$ and $a\\sqrt{2/k} \\dot{A}_\\lambda(t_{\\rm init},k)$</li>\n<li><strong>k</strong> (float):\ncomoving momentum $k$</li>\n<li><strong>a</strong> (Callable):\nscale factor as function of time, $a(t)$</li>\n<li><strong>xi</strong> (Callable):\neinstability parameter as function of time, $\\xi(t)$</li>\n<li><strong>H</strong> (Callable):\nHubble rate as function of time, $H(t)$</li>\n<li><strong>sigmaE</strong> (Callable):\nelectric damping, $\\sigma_{\\rm E}(t)$</li>\n<li><strong>sigmaB</strong> (Callable):\nmagnetic damping, $\\sigma_{\\rm B}(t)$</li>\n<li><strong>kS</strong> (Callable):\nno damping for $k &gt; k_{\\rm S}(t)$ from $\\Theta(t, k)$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dydt</strong> (array):\nan array of time derivatives of y</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">xi</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">H</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">sigmaE</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">sigmaB</span><span class=\"p\">:</span> <span class=\"n\">Callable</span>,</span><span class=\"param\">\t<span class=\"n\">kS</span><span class=\"p\">:</span> <span class=\"n\">Callable</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();