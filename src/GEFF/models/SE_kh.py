r"""
Defines the GEF model "SE-kh" corresponding to fermionic axion inflation with a heuristic scale dependence model through the instability scale $k_{\rm h}$.

For more details on this model, see e.g., [2408.16538](https://arxiv.org/abs/2408.16538).

---

The model knows the following variables:
* time variable: `t` - *cosmic time*, $t$ 
* dynamical variables:
    * `N` - *$e$-folds*,  $N$
    * `phi`, `dphi` - *inflaton amplitude, $\varphi$, and velocity, $\dot{\varphi}$* 
    * `kh` -  *the instability scale, $k_{\rm h}$*
    * `rhoChi` - *fermion energy density, $\rho_{\chi}$*
* static variables:
    * `a` - *scale factor, $a$* 
    * `H` - *Hubble rate, $H$* 
    * `ddphi` - *inflaton acceleration, $\ddot{\varphi}$*
    * `E`, `B`, `G` - *gauge-field expectation values, $\langle {\bf E}^2 \rangle$, $\langle {\bf B}^2 \rangle$, -$\langle {\bf E} \cdot {\bf B} \rangle$*
    * `xi` - *instability parameter, $\xi$* 
    * `sigmaE`, `sigmaB` - *electric and magnetic conductivities, $\sigma_{\rm E}$, $\sigma_{\rm B}$*
    * `xieff` - *effective instability parameter, $\xi_{\rm eff}$*
    * `kS` - *fermion momentum scale, $k_{\rm S}$*
* constants: 
    * `beta` - *coupling strength, $\beta$*
* functions: 
    * `V`,`dV` - *inflaton potential, $V(\varphi)$, and its derivative, $V_{,\varphi}(\varphi)$*
* gauge field: 
    * `GF` - *tower of gauge bilinears, $\mathcal{F}_{\mathcal X}^{(n)}$*

The model expects the following input:
* `phi`, `dphi` - *initial data on the inflaton, $\varphi$, $\dot\varphi$*
* `rhoChi` - *initial data on the fermion energy density, $\rho_{\chi}$*
* `beta` - *coupling strength, $\beta$*
* `V`, `dV` - *potential shape, $V(\varphi)$, $V_{,\varphi}(\varphi)$*

The model tracks the following events:
* end of inflation - terminate solver when $\ddot{a} < 0$
* negative energy - return an error when $\langle {\bf E}^2 \rangle$ or  $\langle {\bf B}^2 \rangle$ are negative 
"""
import numpy as np

from GEFF.bgtypes import t, N, a, H, phi, dphi, ddphi, V, dV, E, B, G, xi, kh, beta, GF, BGVar
from GEFF.solver import TerminalEvent, ErrorEvent, GEFSolver
from GEFF.mbm import ModeSolver

from GEFF.utility.aux_eom import (klein_gordon, friedmann, dlnkh, drhoChi, gauge_field_ode_schwinger,
                                        conductivities_collinear, conductivities_mixed, check_accelerated_expansion)
from GEFF.utility.boundary import boundary_approx
from GEFF.utility.auxiliary import heaviside
from GEFF.utility.aux_mode  import bd_classic, mode_equation_SE_scale
from GEFF._docs import generate_docs, docs_models

name = "SE-kh"
"""The models name."""

settings = {"pic":"mixed"}
"""The model settings.

Possible settings are "mixed", "electric", "magnetic".

Determines if conductivities are computed assuming collinear E&M fields 
("electric", "magnetic") or not ("mixed").
"""

# parse settings
def define_conductivity():
    if settings["pic"]=="mixed":
        conductivity = conductivities_mixed
    elif settings["pic"]=="electric":
        def conductivity(a, H, E, B, G, omega):
            return conductivities_collinear(a, H, E, B, G, -1, omega)
    elif settings["pic"]=="magnetic":
        def conductivity(a, H, E, B, G, omega):
            return conductivities_collinear(a, H, E, B, G, 1, omega)
    else:
        raise KeyError(f"{settings['pic']} is an unknown choice for the setting'pic'")
    return np.vectorize(conductivity)

def interpret_settings():
    global conductivity
    conductivity = define_conductivity()
    return

#Define additional variables
sigmaE=BGVar("sigmaE", 1, 0, "electric damping")
sigmaB=BGVar("sigmaB", 1, 0, "magnetic damping")
xieff=BGVar("xieff", 0, 0, "effective instability parameter")
rhoChi=BGVar("rhoChi", 4, 0, "fermion energy density")
kS=BGVar("kS", 1, 0, "fermion momentum scale")#Fermion energy density 

#Assign quantities to a dictionary, classifying them by their role:
quantities={
            "time":[t], #time coordinate according to which EoMs are expressed
            "dynamical":[N, phi, dphi, kh, rhoChi], #variables which evolve in time according to an EoM
            "static":[a, H, xi, E, B, G, ddphi, sigmaE, sigmaB, xieff, kS], #variables which are derived from dynamical variables
            "constant":[beta], #constant quantities in the model
            "function":[V, dV], #functions of variables such as scalar potentials
            "gauge":[GF] #Gauge fields whose dynamics is given in terms of bilinear towers of expectation values
            }

#State which variables require input for initialisation
input_dic = {
        "initial data":[phi, dphi, rhoChi],
        "constants":[beta],
        "functions":[V, dV]
        }


#this functions is called upon initialisation of the GEF class
def define_units(consts, init, funcs):
    #compute Hubble rate at t0
    rhoK = 0.5*init["dphi"]**2
    rhoV = funcs["V"](init["phi"])
    rhochi = init["rhoChi"]
    H0 = friedmann( rhoK, rhoV, rhochi )
    
    omega = H0 #Characteristic frequency is the initial Hubble rate
    mu = 1. #Charatcterisic amplitude is the Planck mass

    
    return omega, mu

#the new function for sys_to_yini in GEFSolver
def initial_conditions(sys, ntr):   
    yini = np.zeros((ntr+1)*3+5)

    #from the 'input' dictionary
    yini[0] = sys.N.value
    yini[1] = sys.phi.value
    yini[2] = sys.dphi.value

    #needs to be computed
    sys.initialise("kh")( abs(sys.dphi)*sys.beta )
    yini[3] = np.log(sys.kh.value)

    #initialise rhoChi
    yini[4] = sys.rhoChi.value

    #all gauge-field expectation values are assumed to be 0 at initialisation
    return yini

#define update_sys for GEFSolver
def update_values(t, y, sys, atol=1e-20, rtol=1e-6):
    #spacetime variables
    sys.t.value = t
    sys.N.value = y[0]
    sys.a.value = np.exp(y[0])

    #parse for convenience
    sys.phi.value = y[1]
    sys.dphi.value = y[2]
    sys.kh.value = np.exp(y[3])
    
    sys.rhoChi.value = y[4]

    #the gauge-field terms in y are not stored, save these values here
    sys.E.value = y[5]*np.exp(4*(y[3]-y[0]))
    sys.B.value = y[6]*np.exp(4*(y[3]-y[0]))
    sys.G.value = y[7]*np.exp(4*(y[3]-y[0]))

    #Hubble rate
    sys.H.value = friedmann(0.5*sys.dphi**2, sys.V(sys.phi), 
                                0.5*(sys.E+sys.B)*sys.omega**2, sys.rhoChi*sys.omega**2)
    
    #conductivities
    sigmaE, sigmaB, ks = conductivity(sys.a.value, sys.H.value, sys.E.value,
                                       sys.B.value, sys.G.value, sys.omega) 
    sys.kS.value = ks
    GlobalFerm = heaviside(np.log(ks), np.log(sys.a*sys.H))
    sys.sigmaE.value = GlobalFerm*sigmaE
    sys.sigmaB.value = GlobalFerm*sigmaB

    #boundary term parameters
    sys.xi.value = sys.beta*(sys.dphi/(2*sys.H))
    sys.xieff.value = sys.xi + sys.sigmaB/(2*sys.H)

    #acceleration for convenience
    sys.ddphi.value = klein_gordon(sys.dphi, sys.dV(sys.phi),  sys.H, -sys.G*sys.beta*sys.omega**2)
    return

def compute_timestep(t, y, sys, atol=1e-20, rtol=1e-6):
    dydt = np.zeros(y.shape)

    #odes for N and phi
    dydt[0] = sys.H.value
    dydt[1] = sys.dphi.value
    dydt[2] = sys.ddphi.value

    #achieving dlnkhdt is monotonous requires some care
    dlnkhdt = dlnkh( sys.kh, sys.dphi, sys.ddphi, sys.beta,
                       0., sys.xi, sys.a, sys.H )
    r = 2*abs(sys.xi)
    logfc = y[0] + np.log(r*dydt[0]) 
    dlnkhdt *= heaviside(dlnkhdt, 0)*heaviside(logfc, y[3]*(1-1e-5))
    dydt[3] = dlnkhdt

    #ode for rhoChi
    dydt[4] = drhoChi( sys.rhoChi, sys.E, sys.G,
                         sys.sigmaE, sys.sigmaB, sys.H )

    #compute boundary terms and then the gauge-field bilinear ODEs
    Fcol = y[5:].shape[0]//3
    F = y[5:].reshape(Fcol,3)
    W = boundary_approx(float(sys.xi.value))
    dFdt = gauge_field_ode_schwinger( F, sys.a, sys.kh, 2*sys.H*sys.xieff,
                    sys.sigmaE, 1.0, W, dlnkhdt )
    #reshape to fit dydt
    dydt[5:] = dFdt.reshape(Fcol*3)

    return dydt


#Event 1: Track the end of inflation:
def condition_EndOfInflation(t, y, sys):
    #compute energy densities
    rhoV = sys.V(y[1])
    rhoK = y[2]**2/2
    rhoEM = 0.5*(y[5]+y[6])*(sys.omega/sys.mu)**2*np.exp(4*(y[3]-y[0]))
    rhoF = y[4]*(sys.omega/sys.mu)**2

    #compute pressure
    pV = -rhoV
    pK = rhoK
    pEM = 1/3*rhoEM
    pF = 1/3*rhoF

    return check_accelerated_expansion([rhoV, rhoK, rhoEM, rhoF], [pV, pK, pEM, pF])/(sys.H)**2

def consequence_EndOfInflation(sys, occurance):    
    if occurance:
        #stop solving once the end of inflation is reached
        return "finish", {}
    else:
        #increase tend given the current Hubble rate
        tdiff = np.round(5/sys.H, 0)
        #round again, sometimes floats cause problems in t_span and t_eval.
        tend  = np.round(sys.t + tdiff, 0)
        return "proceed", {"tend":tend}
    
EndOfInflation = TerminalEvent("End of inflation", condition_EndOfInflation, -1, consequence_EndOfInflation)
"""Defines the 'End of inflation' event."""

#Event 2: ensure energy densities that are positive definite do not become negative
def condition_NegativeEnergies(t, y, sys):
    
    return min(y[5], y[6])
    
NegativeEnergies = ErrorEvent("Negative energies", condition_NegativeEnergies, -1)#
"""Defines the 'Negative energy' event."""


events = [EndOfInflation, NegativeEnergies]


#gather all information in the solver
solver = GEFSolver(initial_conditions, update_values, compute_timestep, quantities, events)
"""The solver used by the GEF model."""

#define mode-by-mode solver
MbM = ModeSolver(mode_equation_SE_scale, ["a", "xi", "H", "sigmaE", "sigmaB", "kS"],
                         bd_classic, [], default_atol=1e-5)
"""The mode solver used by the GEF model."""


#define default docs for the above functions
generate_docs(docs_models.DOCS)